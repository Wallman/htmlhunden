<!DOCTYPE html><html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width initial-scale=1.0">
<title>HTMLHunden | En pragmatisk höghastighetsguide till webbutveckling, använd vid Uppsala Universitet</title>
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css">
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css">
<link rel="stylesheet" href="/dist/assets/stylesheets/main.css">
<link rel="stylesheet" href="/dist/assets/stylesheets/prism.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- Feedback tab--><link rel="stylesheet" href="http://getbarometer.s3.amazonaws.com/assets/barometer/css/barometer.css">
<script src="http://getbarometer.s3.amazonaws.com/assets/barometer/javascripts/barometer.js"></script>
<script>BAROMETER.load('zFXKA2467y8YdpZaQK3gq');</script>
<script>
if(document.location.hostname.search("localhost") === -1 && document.location.origin !== "file://"){
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-45465391-1', 'htmlhunden.se');
ga('send', 'pageview');
}
</script>
</head><body id="single"><div id="toc-single" class="toc"><div class="hidden-sm hidden-xs"><img src="/dist/assets/images/logo.png" class="logo-sm"></div><a id="toggle-toc" class="btn btn-lg btn-inverse"><span class="glyphicon glyphicon-align-justify"></span></a><div class="btn-group-vertical toc-list"><a href="#01-00-intro-intro" class="toc-h1 btn btn-menu"><b>1 Introduktion</b></a><a href="#01-01-intro-forord" class="toc-h2 btn btn-menu">1.1 Om denna guide</a><a href="#01-02-intro-quickstart" class="toc-h2 btn btn-menu">1.2 Filer, filformat och webbläsare</a><a href="#01-03-intro-arkitektur" class="toc-h2 btn btn-menu">1.3 Internet, klienter och servrar</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#02-00-html-intro" class="toc-h1 btn btn-menu"><b>2 HTML</b></a><a href="#02-01-html-document-structure" class="toc-h2 btn btn-menu">2.1 Syntax, struktur och första dokumentet</a><a href="#02-02-html-common-elements" class="toc-h2 btn btn-menu">2.2 Vanligt förekommande element</a><a href="#02-03-html-semantic-elements" class="toc-h2 btn btn-menu">2.3 Semantiska element</a><a href="#02-04-html-links" class="toc-h2 btn btn-menu">2.4 Sökvägar och Hyperlänkar</a><a href="#02-09-html-forms" class="toc-h2 btn btn-menu">2.5 Formulär</a><a href="#02-10-html-doctypes" class="toc-h2 btn btn-menu">2.6 Doctypes och webbläsarstöd</a><a href="#02-11-html-encodings" class="toc-h2 btn btn-menu">2.7 Character encoding</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#03-00-css-intro" class="toc-h1 btn btn-menu"><b>3 CSS</b></a><a href="#03-01-css-intro" class="toc-h2 btn btn-menu">3.1 Introduktion till CSS</a><a href="#03-02-css-syntax-och-struktur" class="toc-h2 btn btn-menu">3.2 CSS syntax och struktur</a><a href="#03-03-css-selectorer" class="toc-h2 btn btn-menu">3.3 CSS-selectorer</a><a href="#03-04-css-placering" class="toc-h2 btn btn-menu">3.4 Vart skall jag lägga CSS:en?</a><a href="#03-05-css-cascade" class="toc-h2 btn btn-menu">3.5 Cascading</a><a href="#03-06-css-boxmodell" class="toc-h2 btn btn-menu">3.6 Boxmodellen</a><a href="#03-07-css-positionering" class="toc-h2 btn btn-menu">3.7 CSS Positionering</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#04-00-js-intro" class="toc-h1 btn btn-menu"><b>4 JavaScript</b></a><a href="#04-01-js-intro" class="toc-h2 btn btn-menu">4.1 Introduktion till JavaScript</a><a href="#04-02-js-placering" class="toc-h2 btn btn-menu">4.2 Vart ska jag skriva JavaScript?</a><a href="#04-03-js-variabler" class="toc-h2 btn btn-menu">4.3 Variabler</a><a href="#04-04-js-funktioner" class="toc-h2 btn btn-menu">4.4 Funktioner</a><a href="#04-05-js-dom" class="toc-h2 btn btn-menu">4.5 Document Object Model</a><a href="#04-05-js-events" class="toc-h2 btn btn-menu">4.6 Event listeners</a><a href="#04-05-js-objekt" class="toc-h2 btn btn-menu">4.7 Objekt</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#05-00-oss-intro" class="toc-h1 btn btn-menu"><b>5 Open source</b></a><a href="#05-01-oss-intro" class="toc-h2 btn btn-menu">5.1 Open Source</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#06-00-jquery-intro" class="toc-h1 btn btn-menu"><b>6 jQuery</b></a><a href="#06-01-jquery-intro" class="toc-h2 btn btn-menu">6.1 jQuery snabbstart</a><a href="#06-02-jquery-documentready" class="toc-h2 btn btn-menu">6.2 $(document).ready</a><a href="#06-03-jquery-jqueryobjects" class="toc-h2 btn btn-menu">6.3 Objektet jQuery</a><a href="#06-04-jquery-modify-elements" class="toc-h2 btn btn-menu">6.4 Modifiera element</a><a href="#06-05-jquery-event-listeners" class="toc-h2 btn btn-menu">6.5 Event listeners i jQuery</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#07-00-versioning-intro" class="toc-h1 btn btn-menu"><b>7 Versionshantering (kommer snart)</b></a><a href="#07-01-versioning-whatis" class="toc-h2 btn btn-menu">7.1 Vad är versionshantering?</a><a href="#07-02-versioning-install" class="toc-h2 btn btn-menu">7.2 Komma igång</a><a href="#07-03-versioning-staging-and-commiting" class="toc-h2 btn btn-menu">7.3 Staging &amp; commiting</a><a href="#07-04-versioning-branching" class="toc-h2 btn btn-menu">7.4 Branching</a><a href="#07-04-versioning-rolling-back" class="toc-h2 btn btn-menu">7.5 Rulla tillbaka</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#08-00-php-intro" class="toc-h1 btn btn-menu"><b>8 PHP &amp; Server-side-språk</b></a><a href="#08-01-php-installation" class="toc-h2 btn btn-menu">8.1 Komma igång</a><a href="#08-02-php-syntax" class="toc-h2 btn btn-menu">8.2 PHP Syntax</a><a href="#08-03-php-debugging" class="toc-h2 btn btn-menu">8.3 Felsökningstekniker</a><a href="#08-04-php-data-forms" class="toc-h2 btn btn-menu">8.4 Läsa formulärdata med PHP</a><a href="#08-05-php-oop" class="toc-h2 btn btn-menu">8.5 Objektorienterad PHP</a><a href="#08-06-php-organizing-code" class="toc-h2 btn btn-menu">8.6 Kodorganisation</a><a href="#08-07-php-ajax" class="toc-h2 btn btn-menu">8.7 AJAX och PHP</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#09-00-mysql-intro" class="toc-h1 btn btn-menu"><b>9 MySQL</b></a><a href="#09-01-mysql-installation" class="toc-h2 btn btn-menu">9.1 Kom igång med MySQL</a><a href="#09-02-mysql-syntax" class="toc-h2 btn btn-menu">9.2 MySQL syntax</a><a href="#09-03-mysql-api" class="toc-h2 btn btn-menu">9.3 MySQL PHP API</a><a href="#09-04-mysql-abstraction" class="toc-h2 btn btn-menu">9.4 Databasabstraktion &amp; ORM</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#30-00-efterord-intro" class="toc-h1 btn btn-menu"><b>10 Epilog</b></a><a href="#30-01-efterord-intro" class="toc-h2 btn btn-menu">10.1 Efterord</a></div><br><br></div><div id="chapters" class="container"><h1 href="#01-00-intro-intro" name="01-00-intro-intro" id="01-00-intro-intro">Introduktion</h1><p class="lead">Välkommen till HTMLHunden! En pragmatisk höghastighetsguide till webbutveckling. En guide som ger dig tillräckligt mycket för att ta dig ifrån den absoluta grunden till att bygga moderna/dynamiska/responsiva/snabba/pragmatiska webbsidor. Vi berättar inte bara hur du gör. Vi ger dig inte bara en massa kodexempel. Vi förklarar varför <b>och</b> ger dig kodexempel. Vår filosofi är inte att lära dig allt &mdash; utan att lära dig tillräckligt mycket för att du ska kunna lära dig själv! Det tror vi är det snabbaste sättet. Så på med rakethatten så kör vi!</p><div class="page-header"><h2 href="#01-01-intro-forord" name="01-01-intro-forord" id="01-01-intro-forord">Om denna guide</h2></div><p>Den här guiden är till för dig. Just ja. Precis just dig. Inte någon hypotetisk student någonstans. Den är inte heller mer till för dina kompisar än för dig. Eller mer till för de som du tycker kan så himla mycket mer än vad du kan. Den här guiden är till för vemsomhelst som vill lära sig att skapa webbsidor. Så oavsett om du vill lära dig ifrån grunden, eller vill förbättra dina redan existerande kunskaper, så är den här guiden till för just dig.</p><h3>Förväntade förkunskaper</h3><p>Vi förväntar oss egentligen inte att du har några förkunskaper som helst förutom en viss datorvana, och att du någon gång har sett ett programmeringsspråk. Vi försöker verkligen att täcka allt men någonstans måste det ta stopp. Men vi har satt gränsen för vad som krävs av dig på en plats som vi känner oss mycket bekväma med. Det viktiga är att du själv använder ditt intellekt och dina nätsökskunskaper för att hela tiden aktivt försöka förstå vad som sägs.</p><h3>Ett levande dokument</h3><p>HTMLHunden är ett levande dokument. Vi skriver om, skriver nytt, och skriver om konstant. Såldes kan många delar fotfarande kännas inkompletta. Men vi lovar, vi skriver för fulla muggar och det är på väg.</p><h3>Feedback</h3><p>Om du har något du vill berätta, så tryck gärna på feedback-knappen (till höger). Customer is king! Du är vår kund, och din åsikt är viktigast! Om du tycker att någonting är konstigt, bra, dåligt, kunde bli bättre, fel, eller rent utsagt helt uppåt väggarna så vill vi gärna ha in din åsikt.</p><p>Vi är medvetna om att denna guide är högst opinionerad, och således partisk. Om du står för andra åsikter än dem som presenteras här så skulle vi fantastiskt gärna vilja höra dina åsikter. Vi välkomnar olikheter. Allt för att bli bättre.</p><h3>Videomaterial</h3><p>Vi jobbar även på att skapa videos för stora delar av det här materialet. Det finns en del video nu, vilket du hittar inbäddat i löptexten. Om du är intresserad av att se alla videoklippen i ordning utan att leta omkring här så hänvisar vi dig vänligast till vår <a href="http://www.youtube.com/watch?v=wrdR5Su_Stg&amp;list=PLrhzvIcii6GOVLttYLcxO-92GxuPPwbul">playlist på YouTube</a>.</p><h3>Författare</h3><p>Den här guiden är framtagen av <a href="http://katalog.uu.se/empInfo/?id=N12-1461">Christopher Okhravi</a> (<a href="http://twitter.com/chrokh">@chrokh</a>) (Universitetsadjunkt, Uppsala Universitet) och <a href="http://katalog.uu.se/empInfo/?id=N10-407">Madelen Hermelin</a> (Universitetsadjunkt, f.d. Forskningsassistent, Uppsala Universitet). Detta är ett dokument som delvis används vid undervisning under <a href="http://www.im.uu.se/">Institutionen för Informatik och Media</a> vid <a href="http://www.uu.se/en">Uppsala Universitet</a>, men bör ses som ett uttryck för författarnas personliga åsikter och inte universitetets.</p><div class="page-header"><h2 href="#01-02-intro-quickstart" name="01-02-intro-quickstart" id="01-02-intro-quickstart">Filer, filformat och webbläsare</h2></div><p>Alldeles snart ska vi djupdyka in och skapa vår första webbsida. Men först behöver vi snabbt orientera oss. Vad är egentligen en webbsida? Vad är egentligen en webbläsare? Och vad är det som gör att en webbläsare kan läsa en webbsida? Låt oss bena ut några begrepp.</p><h3>Vad är en webbsida?</h3><p>Vi kommer sannolikt möta fler definitioner under denna resas gång. Men låt oss, för enkelhetens skull, definiera en webbsida som följande: Ett interaktivt dokument med hyperlänkar till andra interaktiva dokument.</p><p>Men vad skiljer då dessa "interaktiva" dokument ifrån helt vanliga textdokument. Låt oss se till några exempel. Webbsidor kan...<ul><li>innehålla hyperlänkar (som leder oss till andra webbsidor),</li><li>vara förändringsbara (genom t.ex. animation)</li><li>vara interaktiva (d.v.s. förändras beroende på hur vi interagerar med dem)</li><li>läsas av maskiner (t.ex. <a href="http://en.wikipedia.org/wiki/Web_crawler">sökspindlar</a> konstruerade av (t.ex.) Google, kan analysera din webbsida och skapa sig en uppfattning om dess innehåll och struktur)</li><li>konsumeras på en multitud av olika enheter. Såsom mobiler, tablets eller Smart TV-apparater.</li></ul></p><p>Alla ovan punkter har förstås inte alltid varit sanna. I webbens tidiga dagar hade vi tur om vi träffade på en animerad gif av en <a href="http://en.wikipedia.org/wiki/Hampster_Dance">hamster som dansade</a>. Idag har vi världsförändrande webbsidor såsom <a href="http://maps.google.com">Google Maps</a>. Gränsen för vad som kan täckas in av ordet webbsida börjar tänjas längre och längre, och gränsen mellan en traditionell applikation och en webbsida är nästan redan utsuddad. Men låt oss återkomma till den här diskussionen i ett senare kapitel.</p><h3>Vad är en webbläsare?</h3><p>Du har sannolikt redan en god uppfattning om vad en webbläsare är. Men det är viktigt att vi funderar över det lite närmare. Låt oss försöka bryta ned det.</p><p>Låt oss fundera lite på vad en webbläsare är genom att fundera på vad ett datorprogram är. Ett datorprogram är (oftast) en uppsättning funktioner som transformerar input till output.</p><p>I vissa fall innebär denna transformation att vi går ifrån ett filformat till ett annat. Säg t.ex. när vi konverterar en videofil ifrån ett format till ett annat. Kanske för att det ska gå att spela upp på en mobil enhet.</p><p>I andra fall innebär denna transformation att vi går ifrån ett format som endast en dator kan förstå till ett format som en människa kan tolka genom något av sina sinnen. En rå videofil är t.ex. allt för komplex för att vi som människor ska kunna läsa dess "binära" data och förstå vad filmen handlar om. Istället måste datorn successivt "koda om" detta format till en ström av bilder som visas upp på vår skärm.</p><p>Ett videouppspelningsprogram såsom VLC, Media Player Classic, Quick Time, eller Windows Media Player fungerar alltså detta fall som en slags "tolk" av information. Återigen, är programvarans uppgift alltså att transformera någonting ifrån ett format till annat.</p><p>Men vad har detta med webbläsare att göra? Fundera på vad vi nyss ha sagt, och fundera sedan på att alla webbläsare också är program. Webbläsare transformerar input till output. Nothing more, nothing less.</p><p>Webbläsarens input är (t.ex.) ett HTML-dokument, och webbläsarens output är (bl.a.) en, på skärmen, visuell representation av strukturen och innehållet av det dokumentet. HTML är med andra ord maskinens sätt att läsa ett dokument, och webbläsarens visuella representation av samma dokument är den mänskligt läsbara motsvarigheten.</p><h3>Vad är ett filformat?</h3><p>Innan vi går vidare behöver vi fundera lite på vad en fil är för någonting. Alltså helt vanliga filer som du hittar på din egen dator. Bildfilder, dokument, musik etc. Det två viktiga realisationer vi behöver göra.<ol><li>Filtyper är bara hittepå. Alla filer är rådata. Alla filer går att läsa som text. Strukturen på texten är baserad på konvention.</li><li>Filändelser på bara hittepå. De en konventionsbaserad indikator för filtyp.</li></ol></p><p>Egentligen kan vi se allting som text. (Sanningen är djupare än så. Egentligen är även mänsklig text för en dator bara hittepå och konvention. Men det är att gräva onödigt djupt för nu). Om vi accepterar att alla filer, oavsett om de är bilder, filmer, textdokument eller webbsidor egentligen bara består av text så börjar vi nå intressanta frågor. Hur i hela friden kan en biofilm representeras i text? Låt oss formalisera frågorna.<ol><li>Hur kan komplexa filer representeras med rå data?</li><li>Hur vet operativsystemet vilken typ av fil en viss fil är av, och således vilket program det ska använda för att öppna filen?</li></ol></p><p>Svaret på den första frågan är egentligen tätt bundet till svaret på den andra. Ponera t.ex. talserien <code>(0,255,255)</code>. Ponera att vi "mappar" dessa siffror emot konventionen RGB (Red, Green, Blue) (som används för att representera färg). Ponera att varje värde ska separeras med ett komma-tecken. Ponera även att <code>0</code> betyder "färgkanal på" och <code>255</code> betyder "färgkanal av". Denna tankelek göra att vi genom konvention och helt vanlig plain-text specificerat färgen röd. Poängen är alltså att om vi bara ser till texten i sig är den helt meningslös. Men när vi applicerar idéen om konventionen på texten fyller den plötsligt ett syfte.</p><p>En fil är bara en mängd arbiträr men strukturerad data. Program följer olika konventioner, och när man läser en fil med hjälp av en viss konvention kan man extrahera den information som faktiskt finns inbäddad i filen. D.v.s visa bilden, spela upp ljudet, representera dokumentet.</p><p>Så hur vet operativsystemet vilken konvention den ska applicera? Tänk tillbaka på tidigare diskussion om att ett programs enda uppgift är att transformera input till output. Om ett program är specialiserat på att transformera en viss typ av input till en viss typ av output &mdash; då är det en utmärkt kandidat för att vara en explicit konvention. Innehållet i en fil är alltså input (texten) och ett given program är alltså transformationsprocessen (konventionen).</p><p>Låt oss formulera det i andra ord. En fil innehåller egentligen bara strukturerad råtext (egentligen: data). När denna fil med strukturerad råtext sedan öppnas med det program den var ämnad att öppnas i, kommer denna till synes mumbo jumbo av text helt plötsligt spela sin roll.</p><blockquote class="text-info">Prova själv genom att öppna t.ex. en .jpeg-fil i en vanlig texteditor (såsom Notepad eller TextEdit).</blockquote><p>Egentligen kan vi slänga på vilken filändelse (alltså t.ex. .tex, .doc, .pdf, .jpg, etc.) på vilken fil som helst. Den spelar ingen roll för själva innehållet i filen. Så länge vi öppnar filen med det avsedda programmet (och så länge det avsedda programmet tillåter oss att forcera det att öppna filer med "fel" filändelse) så kommer allt fungera precis som vanligt.</p><p>Faktum är att UNIX-baserade operativsystem i grund och botten <a href="http://cs.canisius.edu/ONLINESTUFF/UNIX/files1.html">inte bryr sig om filändelser</a>. Istället för att filändelsen specificerar vilket program som bör användas för att öppna filen, så specificerar filen själv vilket program som bör användas.</p><p>Medan det konkreta beteendet skiljer sig ifrån operativssytem till operativssystem, så är dagens läxa alltså att alla program i teorin egentligen kan läsa alla filer. Det går bara mer eller mindre bra. Det gäller alltså bara att det att programmet applicerar rätt <em>konvention</em> för hur filen ska läsas. Texteditorer (t.ex.) kan öppna ljudfiler, de kan visa upp det råa innehållet i textuell representation. Men de har ingen aning om hur man faktiskt får ljudet att spelas upp.</p><p>Låt oss analysera ett scenario du själv eller någon du känner kanske redan stött på. Anta att vi har en fil: <code>bild.jpg</code>. Anta sedan att vi döper om den till <code>bild.png</code>. Har filen nu konverterats ifrån formatet JPEG till PNG? Fundera... Självklart inte! Filändelsen är ju bara en del av filnamnet. Inte en del av innehållet. Innehållet är fortfarande detsamma. JPEG är en konvention, PNG en annan. Om filens innehåll följde konventionen JPEG tidigare, och vi endast förändrade filändelsen (alltså filens namn) så innehåller den ju fortfarande data som följer JPEG-konventionen. Alltså har filen inte konverterats. Däremot kommer vi sannolikt ha det svårare att öppna filen i vissa program och/eller operativsystem. Programmet kan komma att anta att filen följer konventionen PNG (i.o.m. att filen har en filändelse som är .png) men när filen sedan faktiskt följer konventionen JPEG (eftersom innehållet i filen följer JPEG-konventionen) så blir programmet superförvirrat och ger upp. En fil med innehåll som följer JPEG-konventionen är inte en fil som följer PNG-konventionen &mdash; oavsett vilken filändelse vi slänger på. En JPEG-fil är inte en PNG-fil &mdash; oavsett vilken filändelse vi slänger på.</p><h3>Vad är HTML?</h3><p>Låt oss nu prata om HTML. Webben drivs i stor del av ett märkesspråk (<a href="http://en.wikipedia.org/wiki/Markup_language">markup language</a>) vid namn HTML. Innan vi kan börja förstå vad HTML är behöver vi förstå vad ett märkesspråk är.</p><p>Ett märkesspråk (oavsett vilket) kan ses som ett textfilsformat vi använder för att "markera upp" olika delar av en text. T.ex. kan det användas för att tilldela ett dokuments olika delar olika semantisk betydelse. Men vad menar vi då med att "markera upp"? </p><p>Reflektera över denna sida. Över denna text. Du ser att vissa delar är paragrafer och att vissa delar är rubriker. Du ser att denna paragraf inte är samma som den föregående. Hur? T.ex. är du ju en människa som vet att du ska tolka upprepade radbrytningar som paragrafskiften. Men hur visste datorn det? Eller mer specifikt. Hur vet din webbläsare (eller det program du använder för att läsa texten) vad som är vad? Hur vet webbläsaren vad som är en rubrik, vad som är en paragraf, vad som är en länk och vart länkarna pekar? Som du antagligen gissat är svaret märkesspråk &mdash; markup languages.</p><p>Vi använder alltså märkesspråk för att delimitera olika sektioner i en flödestext. Om du tänker tillbaka på vad vi tidigare diskuterat om att allting är rå text, så kan denna text i teorin representera vad som helst.Text, video, bild etc. I vilket fall så använder vi märkesspråk för att delimitera olika delar av dokumentet i olika sektioner. Låt oss se till ett snabbt exempel på hur detta fungerar i märkesspråket HTML.</p><pre><code class="language-markup">Endast ett ord i denna text, nämnligen &lt;b&gt;detta&lt;/b&gt; kommer att visas i fetstil.</code></pre><p>Om vi kör ovan genom en webbläsare så kommer webbläsaren att rendera följande resultat:</p><div class="panel panel-default"><div class="panel-body">Endast ett ord i denna text, nämnligen <b>detta</b> kommer att visas i fetstil.</div></div><p>Notera alltså hur användandet av notationen <code>&lt;b&gt;...&lt;/b&gt;</code> används för att delimitera en del av texten som är av extra semantisk vikt och bör visas upp i fetstil. Detta är vad som i HTML kallas för ett <code>element</code>. Ett element som byggs upp genom kombinationen av en start-tag (<code>&lt;b&gt;</code>) och en slut-tag (<code>&lt;/b&gt;</code>).</p><p>Användandet av bokstaven <code>b</code> i ovan exempel är något sånär arbiträrt. Bokstaven delimiterar vilket elment det är vi vill skapa. I HTML finns ett antal fördefinerade element, varvid <code>b</code> är just ett sådant. Användandet av tecknena mindre än (<code>&lt;</code>), större än (<code>&gt;</code>), och slash (<code>/</code>) är dock inte arbiträra. De tillhör märkesspråket HTML's <a href="http://sv.wikipedia.org/wiki/Syntax">syntax</a>.</p><p>Syntax är ett ord som används för att beskriva hur vi uttrycker någonting i ett visst språk. Varje programmeringsspråk och märkesspråk har en egen syntax. Olika märkesspråk har olika syntax, men idéen är densamma. Ett märkesspråk använder någon form av syntax för att "markera ut" vilka delar av en text som är av vilken typ. T.ex. rubriker, paragrafer, länkar, emfas, citat o.s.v.</p><p>Vi kommer att gräva mycket mer i hur HTML fungerar senare. Men för nu behöver du förstå att HTML är ett märkesspråk, och att märkesspråk används för att "markera upp" olika delar av en text så att en maskin kan "förstå" dokumentet.</p><div class="page-header"><h2 href="#01-03-intro-arkitektur" name="01-03-intro-arkitektur" id="01-03-intro-arkitektur">Internet, klienter och servrar</h2></div><p>Den huvudsakliga frågan vi ska försöka besvara i detta kapitel är &mdash; hur fungerar en webbsida? Alltså, hur kan det komma sig att när vi knattrar in www.google.com i en webbläsare och trycker enter, så kommer en interaktiv webbsida tillbaka.</p><p>För att kunna svara på den frågan behöver vi bena ut ett par olika begrepp och lära oss lite mer om den arkitktur som vårt kära internet bygger på. Vi behöver bl.a. prata om klienter, servrar, nätverk, requests och responses. </p><h3>Webbläsaren som program</h3><p>Förnim dig att vi redan har diskuterat att alla filformat bygger på konventioner. Och att alla program "läser" filer genom att de känner till rätt konventioner. Webbläsaren är egentligen ett helt vanligt program som bl.a. bygger på konventioner kring formatet HTML.</p><p>Webbläsaren är alltså ett program som "förstår HTML". Om du öppnar en webbläsare och säger <code>"File &gt; Open"</code> så förväntar den sig att du ska ge den en fil i (t.ex.) HTML-format.</p><p>När vi ger webbläsaren en fil i HTML-format så tolkar webbläsaren filen enligt de konventioner som specificeras av HTML-standarden. Tyvärr har olika webbläsare valt att implementera olika delar av standarden. Samt tolkat olika delar av standarden olika. Vi kommer prata mer om denna situation senare. Hur det kan komma sig att samma kod kan betee sig olika i olika webbläsare. Vad det har för konsekvenser, och hur vi kan hantera det.</p><p>Men det vi behöver fokusera på nu, är alltså att vi <b>inte</b> behöver se webbläsaren som ett program som "browsar" internet. Vi kan likväl se webbläsaren som ett program som kan rendera HTML-filer.</p><p>Så, vad menar vi då med att webbläsaren "renderar" en HTML-fil? De webbläsare vi oftast kommer i kontakt med (Google Chrome, Firefox, Internet Explorer etc.) är webbläsare vars uppgift (bl.a.) är att "läsa" HTML-filer och rendera deras visuella representation på skärmen. Vi, i egenskap av människor, vill inte se själva markup-koden utan en rimlig visuell representation av den markup-koden. Om ett antal ord t.ex. är omslutna av bold-taggen (ex: <code>&lt;b&gt;Hej&lt;/b&gt;</code>) så vill vi inte (när webbläsaren har renderat dokumentet) se själva taggen. Istället vill vi se texten som omslöts av elementet i visuell fetstil (alltså: <b>Hej</b>). En webbläsares uppgift är alltså (bl.a.) att konvertera ett HTML dokument ifrån ett machine-readable format format till ett human-readable format, som visuellt representeras på skärmen.</p><h3>Statiska webbsidor</h3><p>När vi talar om språk för webbutveckling talar vi oftast antingen om server-side- eller client-side-språk. Vi pratar också om statiska och dynamiska webbsidor. Förenklat uttryckt så kan vi med hjälp av server-side-språk uppnå dynamiska språk. Utan server-side språk kan vi endast skapa statiska webbsidor. Detta är en halvsanning (p.g.a. JavaScript), men det kommer vi tala om mer senare. För att skapa dynamiska webbsidor behöver vi introducera någon form av programmerings/scripting-språk. Med märkesspråk endast, kan vi alltså endast skapa statiska webbsidor.</p><p>Notera att ovan paragraf inte använder facktermer utan bör istället betraktas som en tolkning.</p><p>Innan vi kan gå över till att diskutera statiska, dynamiska och skillnaden emellan de &mdash; låt oss återigen påminna oss själva om hur språket HTML ser ut.<pre><code class="language-markup">Ett ord i &lt;b&gt;fetstil&lt;/b&gt; och ett &lt;i&gt;understruket&lt;/i&gt;.</code></pre><div class="panel panel-default"><div class="panel-body">Ett ord i <b>fetstil</b> och ett <i>kursivt</i>.</div></div></p><p>HTML är alltså det märkesspråk vi använder för att "märka upp" ett stycke media. Vi använder termen media eftersom HTML-dokument inte endast behöver bestå av text. De kan även innehålla bilder, ljud och video.</p><p>Med ordet statiskt menar vi (krasst) att om vi skulle öppna samma HTML-dokument två gånger i samma webbläsare så kommer vi att se ett precis likadant dokument andra gången som första. Låt oss omformulera detta. Ett icke-dynamiskt dokument är alltså ett icke-förändrande dokument. Ett statiskt dokument är ett dokument som inte förändras oavsett när vi visar upp det.</p><p>Låt oss uttrycka oss tydligare. När vi har en statisk webbsida så är det alltid samma markup (HTML) och resurser (bilder, css, javascript etc.) som levereras till webbläsaren. När vi bygger statiska sidor så har våran webbapplikation inte heller någon möjlighet att kommunicera med servern. Om sidan inte kan kommunicera med en server så kan den inte heller hålla någon form av "state". Med state menar vi minne. Om vi t.ex. vill bygga en highscore-lista för ett spel så behöver vi ett persistant state för att alla ska</p><ul><li>Samma markup serveras alltid till webbläsaren när webbläsaren begär samma URL</li><li>Samma resurser serveras alltid till webbläsaren när webbläsaren begär samma URL</li><li>Servern som serverar filerna gör det utan att något program modifierar filerna innan de serveras.</li></ul><p>Ett exempel på en statisk webbsida är denna. Alltså htmlhunden.se. De dynamiska delarna (såsom t.ex. innehållsförteckningen) av denna bok har redan genererats i förväg. När din webbläsare ber om att få den sida du är på just nu &mdash; så kommer servern alltid att servera samma HTML. Nämligen den du just nu ser på.</p><h3>Dynamiska webbsidor</h3><p>Om statiska webbsidor innebär webbsidor där den server som serverar webbsidan alltid serverar samma filer vid sina URL:er &mdash; vad är då en dynamisk webbsida? Som du kanske redan gissat, kan servrar som serverar dynamiska webbsidor servera olika HTML olika gånger trots att vi begär samma URL. Det finns alltså inga garantier för att vår webbläsare kommer att motta samma resurser när vi laddar om sidan.</p><p>Vi behöver skapa dynamiska webbapplikationer när vi behöver...</p><ul><li>... spara/hämta data till/ifrån en databas (ex. användare)</li><li>... utföra beräkningar som inte får riskera exponeras för användaren (ex. login)</li><li>... utföra "tunga" beräkningar som klientens dator kanske inte orkar med (ex. videokonvertering)</li><li>... utföra aktiviteter med beroenden av 3e-parts-applikationer (ex. zip) </li><li>... utföra aktiviteter som klienten inte har möjlighet/rättighet att utföra per automatik (ex. skicka mail)</li></ul><p>Det finns (som alltid) ett par undantag i relation till ovan lista. Men de undantagen är av för hög överkurs för att vi ska gå in på dem. I stora drag är ovan lista sann.</p><h3>State</h3><p>Kommer snart...</p><!-- Skillnaden mellan client-side-state och server-side-state--><!-- HTML5 local storage är persistant men delas inte mellan klienter--><!-- AJAX--><h3>Klient-server-arkitektur</h3><p>Innan vi kan gå djupare in på varför vi <b>inte</b> kan utföra komplex logik i html så behöver vi lära oss lite om ansvarsområden för <a href="http://sv.wikipedia.org/wiki/Klient%E2%80%93server" target="_blank">klienter och servrar</a>. Vi har tidigare i detta kapitel uttryckt oss i bemärkelsen att en "server serverar en fil". Om vi är ännu mer explicita skulle vi kunna säga att en server severar en fil som en klient konsumerar.</p><blockquote>En server <em>servererar</em> resurser som <em>konsumeras</em> av klienter. </blockquote><p>Vad i hela friden menar vi med det? Vem är servern? Vem är klienten? Vad är en resurs? Detta är förstås generella termer som kan anta många skepnader. Men i de flesta av fall är din webbläsare klienten. Klienten är den som konsumerar. Klienten är den som blir serverad en HTML-sida. Klienten ansvarar själv för att rendera sidan. Såsom vi tidigare diskuterat. Webbläsaren (klienten) är ett program som är expert HTML-konventionen. Så när webbläsaren tar emot ett dokument som följer konventionen HTML så kan den utan problem rendera den visuella representationen av det dokumentet. Oavsett om du använder din webbläsare för att öppna www.google.com eller en HTML-fil på din egen dator så är webbläsaren en klient.</p><p>Servern däremot kan variera. När du öppnar www.google.com i en webbläsare så finns servern någon helt annanstans. Din klient (webbläsaren) skickar ett request till någon av (i detta fall) Google's servrar som svarar med ett response innehållandes HTML. Eftersom din klient (webbläsaren) är expert på att läsa HTML så läser den svaret och renderar den visuella representationen i din webbläsare.</p><p>När du öppnar en HTML-fil på din egen dator så är det din egen dator som är servern. När du väljer <code>File &gt; Open</code>, väljer en fil och sedan klickar OK så pratar din webbläsare med filsystemet på din dator. Löst uttryckt, ber din webbläsare helt enkelt ditt filsystem om den fil som finns på den plats där den fil du valde finns. Du kommer senare upptäcka att vad en traditionell webbserver gör, faktiskt inte ens är särskilt annorlunda än detta triviala scenario.</p><p>För att slutligen svara på vad vi menar med ordet "resurs" i ovan citat så kan det egentligen vara nästan vad som helst. Vi ska strax prata om request-response-modellen. Allt som går att skicka som ett response är en resurs som skulle kunna serveras av en server och konsumeras av en klient. HTML-dokument, bilder, javascript-filer, musik, Word-dokument etc.</p><p>När vi som webbutvecklare utvecklar sidor är det vanligt att vi kör en lokal webbserver på vår egen dator. Detta bl.a. för att närmare efterlikna (mimik:a) den miljö som vår webbsida faktiskt kommer att leva i när den ligger "live" på Internet.</p><p>Många tänker på mörka dundrande hallar fyllda med korridorer av monstermaskiner när de tänker på servrar. Nu vet du att verkligheten absolut ibland ser ut just så. Men du vet också att det inte alls behöver vara fallet. En server är egentligen också bara ett program som kan köras på en dator. Denna dator kan lika gärna vara din egen laptop. Och programmet kan lika gärna vara väldigt litet.</p><h3>Request-response</h3><p>Internet bygger på en modell som vi kan kalla för request-response-modellen. Ett "request" är en förfrågan, och ett "response" är ett svar. Vi vet ju nu att en servers uppgift är att servera klient med resurser. Men mer specifikt så serverar en server ett (passande) response till en klient, när denne klient skickar ett request. Vi säger passande eftersom reponse:et förstås beror på vilket request vi har skickat.</p><blockquote>En server serverar ett response till den klient som skickar ett request.</blockquote><p>Det här låter kanske komplext men är egentligen väldigt enkelt. Låt oss se till det lite närmare. Aktörerna i denna klient-server-historia är alltså följande:</p><ol><li>En klient (t.ex. vår webbläsare)</li><li>En server (t.ex. någon annans dator)</li></ol><p>En konversation mellan de två parterna skulle alltså kunna låta så här:</p><pre>client request
"Hörru servern, jag skulle vilja titta på filen index.html."
 
server response
"Okidokes, här kommer den!"
 
Klienten läser filen och upptäcker att filen refererade till en bild som den också behöver
 
client request
"Du din gamle server, du berättade inte att jag behövde logo.png också, langar du över den är du snäll!"
 
server response
"Sorry, eftersom jag bygger på den gamla request-response-modellen kunde jag inte berätta det för dig på en gång, här har du!"</pre><p>Ovan figur är alltså en visualisering av hur ett request-response-scenario skulle kunna spela ut sig, när en klient ber om en webbsida. Och i essens är det ungefär det här som händer <em>varje gång</em> vi öppnar vår webbläsare och skriver in en adress såsom exempelvis www.google.com.</p><h3>Server-side-språk</h3><p>Låt oss nu istället prata om server-side språk. Ett server-side-språk är ett lös term som refererar till ett programmeringsspråk som kan användas för att leverera ett response när ett request kommer in. Tänk så här. Vi skulle kunna ha en klient-server-arkitektur helt utan ett server-side-språk. Hur? Jo, klienten ber om en sida genom ett request som vandrar över internet och når rätt server som rakt av svarar med ett response som är en html-sida.</p><p>Men nu är det ju så att det moderna internet består av mycket mer komplexitet än statiska sidor. Den enda skillnaden vi introducerar i ovanstående process handlar då om att vi introducerar ett språk som ansvarar för att konstruera html-sidor beroende på response.</p><p>Vi omformulerar ovan paragraf. Ett server-side-språks huvudsakliga uppgift är alltså att "hitta på" ett html-dokument. Ett statiskt response skulle vara att bara svara med en existerande html-fil. Men ett dynamiskt response skulle innebära att server-side-språket först utför en del logik, och sen "on the fly" skapar den html-fil som servern svarar med.</p><p>Exempel på server-side-språk är t.ex. PHP, Ruby, Python, ASP.NET etc.</p><p>Så om server-side-språket "genererar" HTML-filer &mdash; varför måste vi då lära oss att skriva det själva? Enkelt svarat &mdash; eftersom det är vi som skriver server-side-koden, och därmed även vi som definierar hur HTML-sidorna ska genereras. Det finns alltså inte någon magisk HTML-generator utan någonstans måste vi definera exakt hur HTML-sidorna ska genereras beroende på de request vi får in. Vi återkommer alltså till den gamla tanken mdash; eftersom datorer är korkade, så måste vi berätta för dem exakt vad vi vill ha.</p><h1 href="#02-00-html-intro" name="02-00-html-intro" id="02-00-html-intro">HTML</h1><p class="lead">Navet i det stora webbhjulet måste vi förstås hävda är just HTML. Detta markup-language har hängt med länge och är just det språk vi använder för att strukturera upp information på ett sätt som en webbläsare förstår. Detta kapitel kommer lära dig hur HTML fungerar och hur vi skriver det.</p><p>Innan vi verkligen ger oss på hur man använder HTML, CSS och JavaScript så kan det vara skönt att få en snabb introduktion till hur allt hänger samman. Kika igenom filmen på 25 minuter nedan.</p><div class="panel panel-default"><div class="panel-heading">Introduktionsvideo om html, css och javascript</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/wrdR5Su_Stg?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><div class="page-header"><h2 href="#02-01-html-document-structure" name="02-01-html-document-structure" id="02-01-html-document-structure">Syntax, struktur och första dokumentet</h2></div><p><a href="http://sv.wikipedia.org/wiki/HTML">HyperText Markup Language</a> (HTML) är det språk vi använder för att märka upp content vi vill kunna visa i en webbläsare. I detta kapitel diskuterar vi vad HTML är och hur vi skriver det.</p><p>Innan vi ser till ett exempel behöver vi kort diskutera vad HTML är för någonting. Låt oss utföra en tankelek. Ponera att du, på datorn, skrivit ett dokument i <i>Microsoft Word</i>, <i>Pages</i>, <i>Open Office</i> eller dylik ordbehandlare. Fundera kort över vad detta dokument består av. Vad innehåller det? Text? Jo, onekligen. Men mer exakt än så då? De flesta dokument innehåller någon kombination av rubriker, underrubriker och paragrafer. Men gräver vi djupare än så så hittar vi saker som citat, listor, understrykningar, fetstilsmarkeringar, kursivitet o.s.v.</p><p>För att förstå hur HTML fungerar behöver vi egentligen bara förstå att vår ordbehandlare omöjligen kan komma ihåg vilka delar vi anser vara rubriker eller fetstilsmarkeringar om den inte någonstans sparar den informationen när vi först berättar det. Låt oss uttrycka oss på generellare form. Nästan alla dokument &mdash; ovavsett typ &mdash; består inte bara av text. De består av text som är tätt bunden till semantik. Varje del av texten spelar någon roll i helheten som inte nödvändigtvis behöver vara samma roll som någon annan del av samma text. En term som ofta används för att referera till detta förhållande mellan text och meta-information är <a href="http://sv.wikipedia.org/wiki/Semantik">semantik</a>. Vi kommer framöver på många sätt prata om begreppet semantisk signifikans för att diskutera vad saker har för signifikans i en kontext.</p><blockquote>Dokument består inte bara av rå text, utan rå text tätt med olika semantik.</blockquote><p>En paragraf är inte en paragraf om inte den som läser paragrafen kan urskilja och förstå att det är en paragraf den läser. Det är detta vi talar om när vi talar om semantisk signifikans. Utöver att vi som människor läser texten som paragrafen består av så "läser vi in" faktumet att det är ett avgränsatt område text &mdash; i.e. en paragraf.</p><p>Om information saknade semantisk signifikans hade vi likväl kunnat representera dokument i ett enda långt flöde. All text på en enda lång rad. Men vi människor verkar gilla semantisk indelning för att t.ex. underlätta inlärning. Således har vi lärt oss att (t.ex.) extra vertikalt mellanrum (whitespace) emellan rader denoterar en paragrafindelning och således ett avslut och en påbörjan på en ny tanke/poäng. En paragrafindelning denoterar alltså slutet på en idé och antagligen början på nästa.</p><p>Men maskiner (e.g. webbläsare) har idag inte den förståelse som ovan beskrivs. En webbläsare kan inte förstå vad den ska representera som en egen paragraf genom att processa texten. Maskinen läser inte texten och börjar tänka att "hmm.. här ska vi nog ha en radbrytning". Därför behöver vi berätta för maskinen vad som är vad.</p><p>Maskiner behöver inte bara veta vad som är vad för att vi ska kunna närma oss <a href="http://sv.wikipedia.org/wiki/Artificiell_intelligens">artificiell intelligens</a>. Utan i fallet av webben behöver webbläsaren helt enkelt veta vad som är vad för att kunna presentera informationen för oss på ett rimligt sätt. Kom ihåg. Annars är vi tillbaka i den svårhantereliga värld där paragrafindelningar inte existerar och all text kommer i ett enda långt stycke ifrån början till slut rakt av. Vilken pers det hade varit.</p><p>Självklart handlar alltså inte detta om endast paragrafer. Den abstraktare poängen är alltså att vi måste denotera olika delar för att en maskin ska kunna resonera kring dem. Om vi inte berättar för maskinen vad som är rubriker, vad som är paragrafer, vad som är listor o.s.v. o.s.v.</p><h3>Dokument som hierarkier</h3><p>HTML-dokument bygger på en metafor om att alla dokument går att beskriva som hierarkiska trädstrukturer. Fundera på det. I stort sett alla dokument går att beskriva som en hierarkisk trädstruktur. Ta en bok till exempel. Högst upp i abstraktionskedjan hittar vi av ett antal delar. Boken börjar med ett förord, sen kommer första delen, sedan andra delen, och avslutningsvis efterordet. Böcker ser ju förstås olika ut men detta är ett exempel på hur en bok skulle kunna se ut. Men indelningen tar ju inte slut när vi har delat upp boken i olika delar. Under varje del hittar vi kapitel. Nu kan vi se boken som att den består av ett antal delar under vilka det finns ett antal kapitel. Letar vi vidare så upptäcker vi att varje kapitel innehåller paragrafer. Och letar vi ännu vidare så upptäcker vi att vissa paragrafer innehåller bilder. Om vi skulle försöka representera ovan bok som en linjär trädstruktur skulle den rimligen se ut så här: <code>Del &gt; Kapitel &gt; Paragraf &gt; Bilder</code>.</p><p>Vad vi nu har beskrivit är (i en trädstruktur) relationen mellan föräldrar och barn. Ett förälder kan innehålla barn, och barn kan höra till föräldrar. Ett kapitel kan innehålla paragrafer och en paragraf kan tillhöra ett kapitel. Därav användandet av notationen med större-än-tecknet (<code>&gt;</code>). Det till vänster om större-än-tecknet är alltså föräldern. Men om trädstruktur bara kunde ha barn och föräldrar så skulle de vara helt linjära. Istället behöver vi inse att barn kan ha syskon. En förälder kan alltså ha flera barn. Eller uttryckt i termer av ett träd. En gren kan ha flera förgreningar. Vi kommer att prata mer om detta när vi ser till ett par dokumenstruktursexempel.</p><h4>XML</h4><p>HTML har många likheter med ett annat märkesspråk vid namn <a href="http://sv.wikipedia.org/wiki/XML">XML</a>. XML är också ett märkesspråk som bygger på idéen om att information kan strutkrureras hierarkiskt. Den huvudsakliga skillnaden mellan HTML och XML är att HTML specifikt är skapat för att beskriva webbsidor. XML däremot är ett "general purpose" märkesspråk som kan användas för att beskriva vilken semi-strukturerad information som helst.</p><p>Men när vi nu börjar diskutera element så är det alltså viktigt att du kommer ihåg vårt mål när vi skapar HTML-dokument. Målet är att modellera den information vi önskar att beskriva i ett hierarkiskt format.</p><h3>Element</h3><p>Vi har nu alltså klargjort att HTML bygger på en metfor om att alla dokument går att modellera som hierarkiska trädstrukturer. Men hur gör vi då detta rent konkret? Svaret i HTML är något som benämns <i>element</i>. Element skapar vi genom att använda oss av <code>&lt;</code>, och <code>&gt;</code>-tecken. Följande är ett exempel på ett element som denoterar en paragraf.</p><pre><code class="language-markup">&lt;p&gt;Paragraftexten här...&lt;/p&gt;</code></pre><p>Ovan illustrerar alltså användandet av <code>p</code>-elementet, eller paragraf-elementet. Låt oss bena ut vad syntaxen är. Kom ihåg att ordet syntax handlar om <i>hur</i> vi uttrycker någonting i ett visst språk. I fallet av HTML så är de tre första tecknena i ovan exempel, samt de fyra sista del av syntaxen i HTML. Övrigt är rå text.</p><blockquote>HTML-element byggs upp av taggar.</blockquote><p>HTML-element består helt enkelt av någonting som vi referar till som taggar (tags). Element är alltså en komposition av taggar. Ett element kan komma i två former. Element kan alltså bestå av antingen...</p><ul><li>två taggar (en start- och en slut-tagg), eller</li><li>en tagg (en start-tagg utan slut-tagg)</li></ul><p>Paragraf-elementet vi såg tidigare är ett ypperligt exempel på den första formen där vi har ett tag-par som tillsammans bildar ett element. Vi öppnar en paragraf, skriver en text, och stänger sedan paragrafen. Notera alltså att vi använde slash-tecknet (<code>/</code>) och det återupprepade tagg-namnet (<code>p</code>) för att denotera stängningstaggen (<code>&lt;/p&gt;</code>). Men låt oss se till ett exempel på ett element som inte kräver en stängningstagg.</p><pre><code class="language-markup">Plötsligt...
&lt;hr&gt;
...dök en horisontell linje upp</code></pre><p>Elementet <code>&lt;hr&gt;</code> denoterar en horisontell linje (avdelare) som ritas ut rakt över sidan. En s.k. "horizontal ruler". Om vi funderar lite på det en stund så inser vi snabbt varför ensamma element existerar. En avdelare är en avdelare och det finns ingenting intelligent vi kan denotera innuti en avdelare. Andra element av denna typ är t.ex. bilder. Här ser vi också en tydlig anledning. En bild är ju alltid en bild. Det är ologiskt att anta att vi skulle vilja denotera existensen av någonting i bilden. Bilden själv beskriver vad som finns i bilden.</p><p>Om detta låter lite "lurvigt", oroa dig inte. Vi kommer att diskutera detta närmare och förhoppningsvis blir det klarare när du får se några exempel. Men för nu &mdash; kom ihåg att det finns två typer av element. De som inte behöver stängas (eftersom vi kan placera element eller content i dem), och de som behöver stängas.</p><h3>Element i element</h3><p>För att kunna bygga hierarkiska trädstrukturer så behöver vi förstå att HTML kan innehålla element i element. Ett element kan alltså vara barn till ett annat element. Med andra ord kan vi sluta oss till att ett element som öppnas och stängs kan (i sin kropp) innehålla antingen...</p><ul><li>Text, eller</li><li>Ett annat element</li></ul><p>När vi säger text så menar vi förstås även avsaknaden av text. Den tomma strängen. Så är det även tillåtet att ett element, som förväntar sig ett barn eller text, inte innehåller någonting. Med andra ord skulle elementet öppnas (starttagg) och sedan stängas på en gång (sluttagg).</p><blockquote><p>Ett element kan antingen innehålla ett annat element eller text.</p></blockquote><p>Det är när vi börjar förstå att element kan innehålla andra element som vi verkligen börjar närma oss idéen om hierarkisk informationsrepresentation. Vi kan nu alltså börja uttrycka saker såsom:</p><pre><code class="language-markup">&lt;section&gt;
  &lt;p&gt;En första paragraf.&lt;/p&gt;
  &lt;p&gt;Följd av en annan.&lt;/p&gt;
&lt;/section&gt;</code></pre><h3>Plain-text om inte annat anges</h3><p>En viktig poäng om relationen mellan text och element är att webbläsaren tolkar allt som inte denoterats som någonting annat som text. Oavsett hur många radbrytningar eller mellanslag vi slänger in i ett stycke text så kommer webbläsaren ändå att trunkera all text. Med andra ord hamnar all text på samma rad. Och upprepade mellanslag ersättsm ed ett enda.</p><p>Man skulle alltså kunna säga att HTML i någon bemärkelse är <i>addativt</i>. Vi har en mängd text, och omsluter sedan olika delar av texten med element för att skapa en semantisk indelning. Utan element, har vi ingenting annat än en enda lång sträng av text.</p><p>Anta t.ex. att vi vill lägga in ett antal radbrytningar i en paragraf. Anta att vi försöker göra det genom att helt enkelt skapa radbrytningar med hjälp av ENTER-tangenten vid de platser vi vill. Beakta nedan kod:</p><pre><code class="language-markup">&lt;p&gt;
  Oavsett<br>
  hur många       mellanslag, eller<br>
  radbrytningar   vi lägger in,<br>
  så har det ingen effekt.
&lt;/p&gt;<br></code></pre><p>Trots alla radbrytningar och mellanslag blir ändå resultatet följande...</p><div class="panel panel-default"><div class="panel-body">Oavsett
hur många     mellanslag, eller
radbrytningar vi lägger in,
så har det ingen effekt.</div></div><p>Såsom exemplets text förtäljer har traditionella radbrytningar ingen effekt i ett HTML-dokument. Detta är ett gott exempel för att illustrera att webbläsaren läser dokumentet som en enda lång sträng av text. Så länge vi inte använder HTML-element för att denotera åtskilda delar av dokumentet, så kommer webbläsaren att hantera dokumentet som en enda lång massa av text.</p><h3>Attribut</h3><p>Ett elements öppnande tag kan även innehålla attribut med värden. Attribut är i simpla termer egenskaper för ett givet element. Om vi t.ex. har en hyperlänk (<code>&lt;a&gt;</code>) kan vi använda oss av attributet <code>href</code> (hyper reference) för att denotera vart hyperlänken ska peka någonstans.</p><blockquote>Attribut är egenskaper för en instans av ett element.</blockquote><p>För att t.ex. skapa länkar använder vi elementet <code>&lt;a&gt;</code>. För att sedan denotera vart länken ska peka ger vi attributet <code>href</code> ett värde. Detta värde tar formen av en URL. Beakta nedan exempel och fundera över användandet av attributet <code>href</code>.</p><pre><code class="language-markup">&lt;a href="http://uu.se"&gt;Klicka på mig&lt;/a&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><a href="http://www.uu.se">Klicka på mig</a></div></div><p>Attribut kommer i två former där den vanligaste är nyckel-värde-par (key-value-pairs). Vi specificerar en nyckel och tilldelar den ett värde. Enligt syntaxen <code>nyckel="värde"</code>. Där ordet "nyckel" alltså ersätts med en nyckel som är tillåten för ett givet element. Och ordet "värde" ersätts med ett värde som är tillåtet för den givna nyckeln.</p><p>Alla attribut (nycklar) är inte tillåtna på alla element. Alla värden är inte heller tillåtna på alla nycklar. Anledningen till detta är helt enkelt att attribut denoterar saker som ofta är specifika för just en given typ av element. I exemplet ovan använder vi t.ex. attributet <code>href</code> &mdash; "hyper reference". En hyperreferens är logisk vid användandet av en länk eftersom en länk måste ha en målplats. En länk är inte en länk om den inte har någonstans att länka. Om vi däremot diskuterar en paragraf (<code>&lt;p&gt;</code>) så blir användandet av en hyperreferens helt meningslös. En paragraf är en paragraf av text, inte en länk. En paragraf ska inte hyperreferera någonstans. Det är inte logiskt.</p><blockquote>Olika element tillåter olika attribut.</blockquote><p>Nu kanske du tänker att en paragraf ju måste gå att göra klickbar. Och det är helt sant. Men inte genom att klistra på ett hyperreferens-attribut på paragraf-taggen. Istället kan vi omsluta en del av paragrafens text i ett <code>&lt;a&gt;</code>-element. Kom ihåg &mdash; vi kan nästla element i element!</p><p>Det finns dock några attribut som vi kan slänga på på precis vilket element som helst. Dessa är <code>id</code> och <code>class</code>. Detta är attribut som kommer att visa sig mycket användbara. Vi kommer att prata mer om dessa när vi börjar diskutera CSS och JavaScript.</p><p>Vi har nu pratat om både element och attribut. Låt oss sammanfatta. Element är alltså de "grenar" vi använder för att bygga upp vårt "dokumentträd". Attribut är egenskaper vi kan applicera på våra grenar. </p><h3>Kommentarer</h3><p>I de flesta märkes- och programmeringsspråk så finns faciliteter för vad som kallas för <i>kommentarer</i>. Text vi kan skriva i våra källkodsdokument som inte har någon effekt på det renderade resultatet.</p><p>I HTML ser en kommentar ut som följande.</p><pre><code class="language-markup">&lt;!-- Åh, en sån kommentar! --&gt;</code></pre><p>Kommentarer kan vi skriva i HTML-dokument av olika anledningar men t.ex. skulle vi kunna använda de till att skriva förklarande kommentarer, för att logiskt gruppera olika delar av HTML-dokumentet (för utvecklaren), eller kanske för att skriva en TODO-notis om någonting som måste bättras på senare.</p><p>Kommentarer är alltså en facilitet som existerar för att underlätta vårt arbete som programmerare. Kommentarer i HTML har ingen effekt på sidan mer än att de syns i källkoden. Kom ihåg att vem som helst kan visa källkoden för en HTML-sida genom att öppna den i en textredigerare istället för en webbläsare. Alltså behöver vi inse att vem som helst kommer kunna se våra HTML-kommentarer om de vill. Alltså är det inte en smart idé att skriva känslig information (som vi inte vill läcker ut) i våra kommentarer.</p><p>Beakta nedan exempel som understryker faktumet att kommentarer inte syns när en webbsida renderas.</p><p>Följande HTML...</p><pre><code class="language-markup">&lt;p&gt;Detta syns&lt;/p&gt;
&lt;!-- Detta syns inte --&gt;</code></pre><p>...renderar följande resultat...</p><div class="panel panel-default"><div class="panel-body">Detta syns<!-- Detta syns inte--></div></div><p>Men kommentaren i ovan exempel kommer alltså fortfarande att synas i källkoden. Så om användaren skulle högerklicka och välja "View Source" ("Visa källkod", eller dyl.), alternativt inspektera texten med webbläsarens <a href="http://en.wikipedia.org/wiki/Web_development_tools">Webbutvecklarverktyg</a> så kommer denne att kunna se kommentaren. Prova själv!</p><h3>Dokumenstruktur</h3><p>Vi har nu lärt oss att HTML-dokument modellerar trädstrukturer. Men hur ska då en trädstruktur för ett HTML-dokument se ut? Ett HTML-dokument behöver vara valit ("valid"), enligt standarden, för att kunna renderas korrekt av en webbläsare. Eftersom webbläsare har lite varierande implementationer av HTML-standarden så betyder det att dokumen egentligen inte måste följa standarden till hundra procent. Men det är bra att sträva efter det.</p><p>Men för att återgå till ämnet. Det finns några saker ett HTML-dokument alltid måste innehålla. En dokumenttypsdeklaration (doctype), ett html-rot-element, ett huvud med en titel, och en kropp. Det minsta html-dokumentet vi kan konstruera som fortfarande uppfyller standarden (html5) är följande:</p><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Stora hundhemsidan &lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Låt oss försöka visualisera samma dokument som ovan i en hierarkisk struktur av "lådor i lådor". En låda "i" en låda representerar alltså en barn-förälderrelation, medan en låda "bredvid" en annan låde representerar en syskonrelation.</p><div class="panel panel-default html-box"><div class="panel-heading">&lt;html&gt;</div><div class="panel-body"><div class="panel panel-default html-box"><div class="panel-heading">&lt;head&gt;</div><div class="panel-body"><div class="panel panel-default html-box"><div class="panel-heading">&lt;title&gt;</div><div class="panel-body">Stora hundhemsidan<k></k></div></div><k></k></div></div><div class="panel panel-default html-box"><div class="panel-heading">&lt;body&gt;</div><div class="panel-body">[empty]<k></k></div></div><k></k></div></div><p>Jämför ovan bilder av "boxar i boxar" med den faktiska HTML-koden i bilden högre upp. Försök förstå varför vi har ritat bilden på det sätt vi har ritat den. Notera att <code>DOCTYPE</code>-deklarationen inte är med i ovan exempel.</p><p>När vi ändå är i farten med att försöka visualisera dokumenthierarkier. Låt oss även visualisera ovan som en indenterad lista.</p><pre>DOCTYPE
html
  head
    title
      [text]
  body
    [empty]</pre><p>Detta med indentering leder oss även in på en meningsfull vana html-utvecklare respekterar.</p><blockquote><p>Om en tag är ett barn till tag:en ovan, indentera ett steg.</p></blockquote><p>Notera alltså hur <code>title</code> är indenterad i relation till <code>head</code>, men hur <code>body</code><i>inte </i>är indenterad i relation till <code>head.</code></p><p>Återigen. Vi har inte bara slängt ihop ovan text lite hursomhelst. Utan det indenterade dokumentet är en representativ omskrivning av det tidigare diskuterade HTML-dokumentet. Återigen. Jämför denna indenterade version med den faktiska HTML-koden. Föräldra-barnrelationer defineras alltså nu genom indentering in. Syskonrelationer kan vi identifiera genom att hitta element som befinner sig på samma horisontella nivå under en och samma förälder.</p><p>Detta leder oss in på en viktig poäng som du kanske redan förstått. När vi öppnar ett element måste vi stänga det innan vi stänger dess förälder.</p><blockquote>Alla barnelement behöver stängas innan vi stänger föräldern.</blockquote><div class="panel panel-danger"><div class="panel-heading">Icke-välformatterad HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;article&gt;
    &lt;p&gt;
        Hello world...
    &lt;/article&gt;
&lt;/p&gt;</code></pre></div></div><div class="panel panel-success"><div class="panel-heading">Välformatterad HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;article&gt;
    &lt;p&gt;
        Hello world...
    &lt;/p&gt;
&lt;/article&gt;</code></pre></div></div><h3>Indentering</h3><p>förhoppningsvis har du under läsningens gång märkt att vi i våra kodexempel <a href="http://sv.wikipedia.org/wiki/Indentering">indenterar</a> koden. Det vill säga "drar in" vissa linjer lite till höger. Placerar några mellanslag före vissa rader. Detta gör vi för att öka läsbarheten av koden.</p><p>Indentering är kotym bland programmerare och möjligheten till indentering finns i nästan alla moderna språk. I <a href="http://en.wikipedia.org/wiki/Python_(programming_language)">vissa</a> är det till och med obligatoriskt. Indentering kan i början kännas onödigt och krångligt. Men håll uppe glöden. Du kommer att tjäna på det i längden. De som läser din kod kommer tjäna på det. När du ber någon om hjälp kommer du tjäna på det. Indentering är en av de viktigaste kotymerna vi programmerare har.</p><p>Ok, så hur indenterar man då? Låt oss börja med några exempel.</p><div class="panel panel-success"><div class="panel-heading">Korrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;
    &lt;span&gt;Detta är ok!&lt;/span&gt;
&lt;/p&gt;</code></pre><pre><code class="language-markup">&lt;p&gt;
    &lt;span&gt;
        Också ok!
    &lt;/span&gt;
&lt;/p&gt;</code></pre><pre><code class="language-markup">&lt;p&gt;&lt;span&gt;Också ok men svårläsligt!&lt;/span&gt;&lt;/p&gt;</code></pre></div></div><div class="panel panel-danger"><div class="panel-heading">Inkorrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;
&lt;span&gt;Strunta _inte_ i indenteringen!&lt;/span&gt;
&lt;/p&gt;</code></pre><pre><code class="language-markup">&lt;p&gt;
    Indentera barn...
&lt;/p&gt;
    &lt;p&gt;
        ...men inte syskon!
    &lt;/p&gt;</code></pre></div></div><p>Ett enkelt sätt att veta när man ska indentera &mdash; alltså flytta en rad inåt, är följande minnesregel. Om vi öppnar ett element, ska allt som efterföljer indenteras, ända tills vi stängt elementet.</p><blockquote>Alla barn till ett element ska indenteras ett "steg".</blockquote><p>Öppningstaggar och stängningstaggar ska alltså vara indenterade in till samma nivå. Om vi indenterar korrekt kommer det vara busenkelt att snabbt identifiera vilka element som är barn till vilka element. Vilka element som är syskon. Vart ett element stängs. Och så vidare, och så vidare.</p><p>Att ta med sig ifrån det här stycket är alltså &mdash; indentera! Du kommer snabbt märka att de flesta programmerare är allergiska emot dålig indentering. Så skippa bara indenteringen om du vill skapa dig fiender :)</p><h3>Ett komplett dokument</h3><p>Ett validerande HTML-dokument måste alltså innehålla ett par saker. En dokumenttypsdeklaration, ett huvud, en titel och en kropp. Nyssnämnt direktäversättningar av de korrekta termerna <code>DOCTYPE</code>, <code>HEAD</code>, <code>BODY</code> och <code>TITLE</code>. Låt oss återgå till tidigare nämnt kod-exempel (se nedan), och fundera över hur dessa element ska nästlas i varandra. Med andra ord, låt oss diskutera vilka element som är barn/föräldrar till vilka.</p><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Page about kittenz!&lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Notera även att det absolut yttersta elementet är <code>&lt;html&gt;</code>. Ett HTML-dokument måste innehålla ett och endast ett <code>&lt;html&gt;</code>-element. I detta element måste det finnas ett och endast ett <code>&lt;head&gt;</code>- och respektive <code>&lt;body&gt;</code>-element. I huvudet måste vi även ange en sidtitel med hjälp av <code>&lt;title&gt;</code>. Detta är det minsta dokumentet vi kan skapa som validerar, och det är även så här <em>alla</em> html-dokument är strukturerade i botten.</p><h4>Head (meta-data)</h4><p>Så vad lägger vi då inanför <code>&lt;head&gt;</code>-taggarna? Det korta svaret är: meta-data.</p><p>Det längre svaret är att vi även laddar in externa referenser i huvudet. Följande kodruta är ett exempel på hur ett set av <code>&lt;head&gt;</code>-taggar skulle kunna se ut.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på HEAD</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">...
&lt;head&gt;
  &lt;title&gt; Hover cat &lt;/title&gt; 
  &lt;link rel="stylesheet" href="stylesheets/main.css"&gt;
  &lt;script src="javascripts/main.js"&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="keywords" content="Kittens,Hovercrafts"&gt;
&lt;/head&gt;
...</code></pre></div></div><p>Låt oss diskutera ovan kod rad för rad. </p><table class="table table-striped"><tr><th>Rad</th><th>Förklaring</th></tr><tr><td>3</td><td>Den titel som visas högst upp i en sidans "tab" i en webbläsare.</td></tr><tr><td>4</td><td>Säger åt webbläsaren att ladda in en <a href="#stylesheets">Stylesheet</a>-fil, som finns på platsen definerad av <code>href="sökväg-till-filen-här"</code>.</td></tr><tr><td>5</td><td>Säger åt webbläsaren att ladda in en <a href="#javascript">JavaScript</a>-fil, som finns på platsen definerad av <code>src="sökväg-till-filen-här"</code>.</td></tr><tr><td>6</td><td>Berättar för webbläsaren vilken "<a href="http://www.joelonsoftware.com/articles/Unicode.html">character encoding</a>" sidan är skriven i, så att tecken som åäö kan visas korrekt.</td></tr><tr><td>7</td><td>Definerar ett par <a href="http://www.w3schools.com/tags/tag_meta.asp">keywords</a> för sidan. Denna information används av bl.a. sökmotorer för att "förstå" sidans innehåll.</td></tr></table><h4>Body (Sidans faktiska innehåll)</h4><p>Om <code>&lt;head&gt;</code> beskrivs som sidans meta-content &mdash; alltså content om content. Då skulle vi kunna säga att <code>&lt;body&gt;</code> är sidans faktiska content.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på innehåll i BODY</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">...
&lt;body&gt;
  &lt;h2&gt; Sidans titel &lt;/h2&gt; 
  &lt;p&gt; Det här är en paragraf med text. &lt;p&gt;
  &lt;p&gt;
      Och det här är en till, som innehåller en
      &lt;a href="http://uu.se"&gt;länk&lt;/a&gt; till UU.
  &lt;p&gt;
&lt;/body&gt;
...</code></pre></div></div><div class="page-header"><h2 href="#02-02-html-common-elements" name="02-02-html-common-elements" id="02-02-html-common-elements">Vanligt förekommande element</h2></div><p>Låt oss nu bekanta oss med de vanligast förekommande elementen och relevanta attribut.</p><h3>Paragrafer och rubriker</h3><p>Låt oss börja genom att diskutera de två kanske vanligaste elementen. Paragrafer och rubriker. Paragrafer skapar vi genom att använda oss av elementet <code>&lt;p&gt;</code> och element genom att använda någon av rubrikelementen.</p><p>Ett exempel på användande av paragrafer följer nedan.</p><pre><code class="language-markup">&lt;p&gt;En paragraf denoterar alltså ett stycke text.&lt;/p&gt;
&lt;p&gt;Varje ny paragraf börjar, om inte annat anges, på en ny rad.&lt;/p&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>En paragraf denoterar alltså ett stycke text.</p><p>Varje ny paragraf börjar, om inte annat anges, på en ny rad.</p></div></div><p>De flesta dokument består ju inte bara av paragrafer utan även av rubriker. Vi skapar rubriker i HTML genom att använda oss av <code>&lt;hX&gt;</code>, där X ersätts med en siffra ifrån <code>1-6</code>. Alltså:</p><pre><code class="language-markup">&lt;h1&gt;En rubrik&lt;/h1&gt;
&lt;p&gt;Följd av en paragraf.&lt;/p&gt;
&lt;h2&gt;En underrubrik&lt;/h2&gt;
&lt;p&gt;Ytterligare en paragraf.&lt;/p&gt;</code></pre><p>Och så kan vi fortsätta hela vägen ned till <code>h6</code>. Rubriken <code>h1</code> är alltså den viktigaste rubriken (den högsta nivån av rubriker) och <code>h6</code> den minst viktiga. Resten följer förstås i inbördes ordning däremellan.</p><p>Om vi skulle exemplifera användandet av rubriker på den här sidan, löper vi en stor risk att skapa förvirring kring vad som faktiskt är rubriker och vad som är exempel på rubriker. Så för att se ett exempel på hur rubriker fungerar så råder vi dig att ta en snabb titt på ett <a href="http://www.w3schools.com/html/tryit.asp?filename=tryhtml_headers">exempel ifrån w3schools</a>. </p><h3>Fetstil och kursivitet</h3><p>Låt oss nu diskutera de vanligaste textformatteringselementen. Fetstil och kursivitet. För att uppnå fetstilt text, kan vi välja att använda någon av elementen <code>&lt;b&gt;</code> (bold) eller <code>&lt;strong&gt;</code>.</p><pre><code class="language-markup">All text &lt;b&gt;inom ett b-element&lt;/b&gt;
eller ett &lt;strong&gt;strong-element&lt;/strong&gt;
renderas i fetstil.</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">All text <b>inom ett b-element</b> eller ett <strong>strong-element</strong> renderas i fetstil.</div></div><p>Om vi istället skulle vilja ha kursiv text, även kallad <i>italics</i>, så kan vi välja att använda något utav elementen <code>&lt;i&gt;</code> (italics) eller <code>&lt;em&gt;</code> (emphasis).</p><pre><code class="language-markup">All text &lt;i&gt;inom ett i-element&lt;/i&gt;
eller ett &lt;em&gt;em-element&lt;/em&gt;
renderas som kursiv text.</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">All text <i>inom ett i-element</i> eller ett <em>em-element</em> renderas som kursiv text.</div></div><p>Men varför finns det två sätt att denotera fetstil text och två sätt att denotera kursiv text? Du kommer lättare förstå skillnaden mellan de olika elementen när vi börjar diskutera semantisk signifikans. Men som kort svar så denoterar alltså t.ex. <code>i</code> mer presentation snarare än semantik, och <code>em</code> mer semantik snarare än presentation. Föreställ dig en blind person. Den visuella effekten av kursiv text är inte av signifikans för den blinde. Men idéen <em>extra emfas</em> är signifikant. Att det sedan råkar sig så att visualiseringen av extra emfas sker genom samma visuella effekt som kursivitet är alltså i någon bemärkelse ett sammanträffande.</p><h3>Listor</h3><p>För att skapa punktlistor i HTML behöver vi kombinera två olika element. Ett element som denoterar vilken typ av lista vi vill skapa. Innuti detta element behöver vi upprepat använda ett annat element &mdash; en gång per punkt i vår punktlista.</p><p>Vi nämnde alltså att det första elementet denoterar vilken typ av lista vi vill skapa. Det finns, i HTML, alltså två typer av listor &mdash; numrerade listor och onumrerade listor. Numrerade listor denoteras genom elementet <code>&lt;ol&gt;</code> (<em>ordered lists</em>) och onumrerade listor genom elementet <code>&lt;ul&gt;</code> (<em>unordered lists</em>).</p><p>Som nämnt behöver vi sedan denotera varje element (punkt) i listan för sig. Detta gör vi helt enkelt genom att använda elementet <code>&lt;li<&gt;< code=""> (list item). Samma element används alltså oavsett om det skall användas i en numrerad eller onumrerad lista.</&gt;<></code></p><p>Låt oss se till ett exempel på en onumrerad lista.</p><div class="panel panel-default"><div class="panel-heading">Exempel på onumrerad lista</div><div class="panel-body"><pre><code class="language-markup">&lt;ul&gt;
  &lt;li&gt;Katt&lt;/li&gt;
  &lt;li&gt;Hund&lt;/li&gt;
  &lt;li&gt;Sköldpadda&lt;/li&gt;
&lt;/ul&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><ul><li>Katt</li><li>Hund</li><li>Sköldpadda</li></ul></div></div></div></div><p>Lagom intuitivt så är alltså skillnaden mellan en numrerad och en onumrerad lista att den numrerade listan använder nummer istället för symboler framför varje element i listan.</p><div class="panel panel-default"><div class="panel-heading">Exempel på numrerad lista</div><div class="panel-body"><pre><code class="language-markup">&lt;ol&gt;
  &lt;li&gt;Katt  &lt;/li&gt;
  &lt;li&gt;Hund&lt;/li&gt;
  &lt;li&gt;Sköldpadda&lt;/li&gt;
&lt;/ol&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><ol><li>Katt</li><li>Hund</li><li>Sköldpadda</li></ol></div></div></div></div><p>Självklart är vi inte bundna till att använda just dessa typer av symboler och/eller nummer framför varje listelement. Istället för att använda vanliga siffror skulle vi t.ex. kunna använda romerska siffror. Alltså <code>I, II, III, IV</code> o.s.v. Detta kommer vi att exemplifiera när vi börjar tala om css.</p><h3>Tabeller</h3><p>I de tidigare dagarna av HTML använde kreativa webbutvecklare ofta tabeller för att strukturera upp hela webbsidor. Tabeller i HTML är alltså helt vanliga tabeller. Kolumner, rader, rubriker och inget mer. Men eftersom tabeller betedde sig på ett mycket förutsägbart sätt så upptäckte man att det var tacksamt att strukturera sina sidor med hjälp av tabeller.</p><p>Idag används tabeller nästan uteslutande för att representera tabulär data. Såsom elementet rimligen var tänkt att användas ifrån början.</p><p>När vi kommer in på diskussionen om semantisk signifikans så kommer du förhoppningsvis förstå varför det är både viktigt och naturligt att inte använda tabeller till annat än representation av tabulär data. Men återigen handlar det om distiktionen mellan hur saker ser ut och vad de faktiskt innebär. Användandet av tabeller implicierar att ett stycke data kan behandlas tabulärt. Så om vi använder tabeller för att visuellt strukturera vår sida &mdash; så implicerar vi att vår sida är en enda stor tabell av strukturerad data. Vilket oftast inte är sant.</p><p>När vi diskuterar tabeller så finns det egentligen fyra element som vi behöver lära oss. För att skapa en tabell börjar vi alltid med elementet <code>&lt;table&gt;</code>. Detta element enkapsulerar hela tabellen. Alla dess rader, kolumner och data.</p><p>Innanför elementet <code>table</code> kan vi sedan placera ett valfritt antal element av typen <code>&lt;tr&gt;</code> (<em>table row</em>). Detta element skapar nya tabellrader. När vi skapar tabeller i HTML behöver vi alltså specificera kolumnerna i raderna och inte tvärtom. Syntaxen hade ju förstås likaväl kunnat fungera tvärtom men nu är fallet inte så.</p><blockquote>I tabeller specificerar vi först raderna &mdash; sedan kolumnerna. Aldrig tvärtom.</blockquote><p>Innanför elementet <code>tr</code> kan vi sedan placera ett valfritt antal element av typen <code>&lt;td&gt;</code> (<em>table data</em>. För att underlätta den mentala modellen kan du alltså tänka att elementet <code>td</code> skapar kolumner. Om vi använder <code>tr</code> för att skapa rader i tabellen så använder vi <code>td</code> för att skapa kolumner i en rad.</p><p>Det sista elementet vi kan använda när vi arbetar med tabeller är <code>&gt;th&lt;</code> (<em>table header</em>). Detta element kan ersätta vilket <code>&lt;td&gt;</code> som helst. Vi använder alltså elementet för att denotera att en viss cell inte innehåller vanlig celldata. Utan snarare bör behandlas som en rubrik.</p><p>Låt oss se till ett komplett exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på tabell</div><div class="panel-body"><pre><code class="language-markup">&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Djur&lt;/th&gt;
    &lt;th&gt;Storlek&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Golden Retriever&lt;/td&gt; 
    &lt;td&gt;Stor&lt;/td&gt; 
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Norsk Skogskatt&lt;/td&gt; 
    &lt;td&gt;Liten&lt;/td&gt; 
  &lt;/tr&gt;
&lt;/table&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><table style="width:auto;margin:auto 0;" class="table table-bordered"><tr><th>Djur</th><th>Storlek</th></tr><tr><td>Golden Retriever</td><td class="text-center">L</td></tr><tr><td>Norks Skogskatt</td><td class="text-center">S</td></tr></table></div></div></div></div><p>Var inte rädd för att använda tabeller! Men kom alltså ihåg att tabeller endast ska användas för data som är rimlig att presentera i tabeller.</p><h3>Definitionslistor</h3><p>Kommer snart...</p><h3>Bilder  </h3><p>Dags att bli visuella och diskutera hur vi får in bilder i våra HTML-dokument. Som vanligt när det kommer till HTML är det egentligen ganska enkelt. Genom att använda <code>&lt;img&gt;</code>-taggen tillsammans med attributet <code>src</code> kan vi infoga bilder i våra dokument. Låt oss se till ett exempel.</p><pre><code class="language-markup">&lt;img src="http://placekitten.com/g/60/60"&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><img src="http://placekitten.com/g/60/60" alt="En m&#xE4;sterkatt utan st&#xF6;vlar"></div></div><blockquote class="text-info">Prova gärna att klistra in adressen som bilden ovan pekar mot i webbläsaren och kolla vad som finns under adressen. </blockquote><p>Notera alltså att att adressen ovan (som antytt) pekar mot en URL som renderar en bild. (Tjänsten <a href="http://placekitten.com" target="_blank">placekitten</a> erbjuder helt enkelt bilder i olika storlekar under alla sina URL:er.) Således kan vi alltså ersätta den adressen med en bild som finns lokalt på vår dator, på vår egen server eller någon annanstans på internet. Attributet <code>src</code> förväntar sig helt enkelt en adress till en bild.</p><h4>Alternativ</h4><p>Men vad händer om en bild inte kan renderas? Och vad händer när en <a href="http://en.wikipedia.org/wiki/Screen_reader" target="_blank">screen reader</a> upptäcker en bild. In kommer <code>alt</code>-attributet och räddar dagen! Låt oss se till ett exempel innan vi går vidare.</p><div class="panel panel-default"><div class="panel-heading">Exempel på användning av alt-attributet</div><div class="panel-body"><pre><code class="language-markup">&lt;img src="http://placekitten.com/g/60/60" alt="En mästerkatt utan stövlar"&gt;</code></pre></div></div><p>Om vi nu försöker nå ovan bild genom någon form av läsare som inte kan rendera bilder så kommer vi istället få texten <em>En mästerkatt utan stövlar</em>. I annat fall kommer bilden att visas som vanligt och texten inte synas. Tänk på att attributet <code>alt</code> krävs för att en <code>&lt;img&gt;</code>-tagg ska vara <a href="http://www.w3schools.com/tags/tag_img.asp" target="_blank">valid</a>.</p><blockquote class="text-danger">Attributen <code>alt</code> och <code>src</code> krävs båda för att en <code>&lt;img&gt;</code>-tagg ska vara valid.</blockquote><h4>Bildtexter</h4><p>Om vi vill lägga till en bildtext till vår bild kommer de nya html5-elementen <code>&lt;figure&gt;</code> och <code>&lt;figcaption&gt;</code> väl till pass.</p><p>Dessa är <em>semantiska</em> attribut snarare än <em>visuella</em>. Med andra ord. Visst har <code>&lt;p&gt;</code>-taggen en semantisk innebörd &mdash; en paragraf representerar ju semantiskt ett stycke text, och således rimligen en tanke. Men i HTML så resulterar ju även en paragraf i någonting visuellt skillt ifrån plain-text och därmed </p><p>Elementen <code>figure</code> och <code>figcaption</code> är båda <em>semantiska</em> element snarare än direkt <em>visuella</em>. Med andra ord, om vi skulle välja att bara skriva ut vår bild följd av ett helt vanligt paragraf-element som innehåller vår bildtext, så skulle det visuella resultatet bli ungefär likadant som om vi använde figure och figcaption. Poängen med att dock istället använda figure och figcaption är att vi <a href="http://en.wikipedia.org/wiki/Semantic_HTML" target="_blank">berikar dokumentet med semantik</a>. Plus att vi har ett enhetligt sätt att angripa bildtexter ifrån våra stilmallar (css).</p><blockquote class="text-success"><code>&lt;figure&gt;</code> och <code>&lt;figcaption&gt;</code> är båda element med semantisk mening.</blockquote><div class="panel panel-default"><div class="panel-heading">Exempel på figurannotation med figcaption</div><div class="panel-body"><pre><code class="language-markup">&lt;figure&gt;
  &lt;img src="http://placekitten.com/g/130/130"&gt;
  &lt;figcaption&gt;
    En mästerkatt utan stövlar.
  &lt;/figcaption&gt;
&lt;/figure&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><figure><img src="http://placekitten.com/g/130/130" alt="En m&#xE4;sterkatt utan st&#xF6;vlar"><figcaption>En mästerkatt utan stövlar.</figcaption></figure></div></div><div class="page-header"><h2 href="#02-03-html-semantic-elements" name="02-03-html-semantic-elements" id="02-03-html-semantic-elements">Semantiska element</h2></div><p>När vi pratar om semantisk signifikans så pratar vi om vad någonting (t.ex.) ett stycke text har för kontextuell betydelse. Lite som att läsa emellan raderna. Vi har i tidigare kapitel flera gånger nämnt termerna semantik och semantisk signifikans. Nu är det dags att faktiskt bena ut vad det handlar om.</p><p>Intågandet av den "levande standarden" <a href="http://www.w3schools.com/html/html5_intro.asp">HTML5</a> &mdash; kan anses som en stark drivkraft i diskussionen om semantik och webben. Med HTML5 deprekerade man ett antal element som bl.a. var allt för fokuserade på <em>presentation</em>. Istället introducerade man ett par intressanta och nyttiga element som fokuserade på <em>semantik</em>.</p><p>Men vad pratar vi egentligen om när vi pratar om semantik? Och vad menar vi egentligen när vi säger att de var <em>för</em> fokuserade på presentation? Är inte det just presentation som är poängen med HTML? Att presentera information för en användare.</p><h3>Content är inte presentation</h3><p>Idéen om att <a href="http://en.wikipedia.org/wiki/Separation_of_presentation_and_content">separera presentation ifrån content</a> handlar i essens att det går att skilja på presentation (representation) av content ifrån faktiskt contentet. Med andra ord &mdash; att representationen av information inte är detsamma som informationen i sig. Låt oss omformulera oss &mdash; att uttrycka en tanke är inte samma sak som essansen av tanken. Den talade tanken är inte samma sak som tanken. And down the rabbit hole it goes...</p><p>Vi sniffar nu lite i gränslandet till filosofi. Vad är kunskap? Är det skillnad på kunskap och kommunicerad kunskap? Om vi kan lagra kunskap som är separerad ifrån representation borde vi inte då kunna skapa maskiner som är lika smarta som vi? Vi närmar oss kunskapsrepresentation. Vi närmar oss artificiell intelligens.</p><p>Som du märker finns det mycket att gräva i. Och det är därför vi uttrycker oss i termer av "down the rabbit hole". Men utan att gräva ned oss allt för djupt åt något håll så finns det intressanta potentiella förmåner vi kan dra nytta av genom att inse att presentation och content inte är samma sak. Och sedan agera därefter.</p><h3>Alla element denoterar någon semantik</h3><p>Varje gång vi i HTML använder ett element så säger vi någonting om det content som vi väljer att placera i just det elementet. Ta t.ex. <code>&lt;em&gt;</code>-elementet. Ett element som används för att denotera emfas. Emfas är inte bara någonting som är relaterat till presentation. Fundera över följande meningar.<ul><li>"Hon sa att du <em>skulle</em> göra det."</li><li>"Hon sa att <em>du</em> skulle göra det."</li><li>"<em>Hon</em> sa att du skulle göra det."</li></ul></p><p>Förhoppningsvis känner du, både ifrån verkliga livet och ifrån skolan, igen att emfas kan göra att samma mening betyder helt olika saker. Ovan tre meningar får tre helt olika innebörder beroende på hur vi väljer att intonera. Alltså vart vi väljer att lägga emfas.</p><h3>Accessibility</h3><p>Föreställ dig en blind person. Hur läser en blind person din webbsida? Rimligen med någon form av <a href="http://en.wikipedia.org/wiki/Screen_reader">screen reader</a>. En screen reader (t.ex.) är en maskin som läser källkoden för din webbsida och genom text-till-tal-syntes sedan läser upp relevant text på webbsidan.</p><p>När en screen-reader ska "läsa" våra webbsidor så skapar den egentligen en ny presentation. I termer av content och presentation. Screen-readern bryr sig egentligen bara om vårt content. Den vill identifiera vårt content, och sedan intelligent återrepresentera detta för användaren i ett format som är anpassat för denne.</p><p>Men vad är det screen readern behöver veta? Rimligen behöver den t.ex. veta vad som är meny-länkar så att den kan ge användaren en möjlighet att navigera ifrån den sidan den är på. Rimligen behöver den veta vilken del av sidan som är "huvud-content" (t.ex. en artikel) så att den inte börjar läsa upp annonserna för användaren. Rimligen behöver den veta vad artikeln har för rubrik så att den kan läsa upp den först, och sedan pausa i någon sekund så att användaren, lyssnaren, förstår att det är en rubrik. Rimligen behöver den veta vilka ord som ska läsas med extra emfas så att vi inte råkar ut för missförstånd såsom i det tidigare exemplet med punktlistan.</p><p>Detta är alltså varför det är viktigt att vi har element såsom t.ex. <code>&lt;em&gt;</code> som gör att vi kan denotera emfas. Eller <code>&lt;nav&gt;</code> för att kunna denotera meny-navigation. Detta är förstås inte ens en bråkdel av alla element med semantisk signifikans som existerar i HTML. Men vi återkommer till dessa strax.</p><h3>Bortom accessibility </h3><p>Låt oss bara understryka att den som tror att idéen om att separera content ifrån presentation endast är en tillgänglighetsfråga (accessibility) &mdash; är naiv. Vi diskuterar den blinde användaren för att ha ett exempel att utgå ifrån men både problemet och fördelarna gömmer sig mycket djupare än så. Vi är på väg mot en webb där <a href="http://en.wikipedia.org/wiki/Semantic_Web">information är fri ifrån presentation</a>. Där en multitud av maskiner kan läsa informationen på olika sätt. Allt ifrån TV-apparater till  <a href="http://en.wikipedia.org/wiki/Google_Glass">glasögon</a>.</p><p>Kommer snart...</p><h3>Maskinläsbarhet</h3><p>Kommer snart...</p><h3>Semantiska element i HTML5</h3><p>Kommer snart...</p><h3>Uppmaningar</h3><p>Poängen med detta kapitel är egentligen enkel. Vi vill plantera ett frö som förhoppningsvis gör att du börjar tänka på varför du väljer ett element över ett annat. Vi vill att du börjar tänka på att det finns en poäng med att hålla sin markup så "ren", minimalistisk och semantisk som möjligt. Vi vill att du börjar vara medveten om att alltid separera content ifrån presentation.</p><div class="page-header"><h2 href="#02-04-html-links" name="02-04-html-links" id="02-04-html-links">Sökvägar och Hyperlänkar</h2></div><p>Det, för HTML, kanske mest representativa elementet måste ju vara länken. En klickbar yta på skärmen som navigerar oss ifrån en webbsida till en annan. Den tagg vi använder för att denotera en länk är <code>&lt;a&gt;</code>. Ett komplett exempel på användandet av en länk skulle kunna se ut som följande.</p><pre><code class="language-markup">&lt;a href="http://www.example.com"&gt;Klicka på mig&lt;/a&gt;</code></pre><p>Vilket skulle rendera följande resultat:</p><div class="panel panel-default"><div class="panel-body"><a href="http://example.com">Klicka på mig</a></div></div><p>Notera alltså användandet av attributet <code>href</code> i ovan exempel. Attributets namn är en förkortning av "hyper reference". Det kan vara bra att fundera över vad de olika förkortningarna du kommer i kontakt med faktiskt éxpanderar till. Då blir det lättare att komma ihåg/på vad attributen faktiskt gör.</p><h3>Sökvägar</h3><p>Attributet <code>href</code> specificerar alltså en sökväg till en annan webbsida. Men vad kan ge attributet för olika typer av värden? När vi pratar om sökvägar är det viktigt att förstå att det finns två sätt att ange sökvägar.</p><ol><li>Absoluta sökvägar</li><li>Relativa sökvägar</li></ol><p>Dessa begrepp är generella och stämmer precis lika bra överens med sökvägar i operativsystemet på din dator. För att förstå skillnaden mellan de två, låt oss använda operativsystemet som exempel.</p><p>Under <i>Microsoft Windows</i> så skulle ett exempel på en absolut sökväg t.ex. vara <code>C:/Users/Jon Snow/Pictures/me.jpg</code>. Under samma operativsystem skulle ett exempel på en relativ sökväg kunna vara <code>Pictures/me.jpg</code>. Den huvudsakliga skillanden emellan de två exemplena är alltså att den första börjar med <code>C:/</code>. Förhoppningsvis är du familjär med att varje hårddisk (fysisk eller virtuell) under Windows blir tilldelad en enhetsbokstav, såsom C:, D:, E: o.s.v. Den absoluta sökvägen i ovan exempel utgick alltså ifrån en av dessa enheter. Den relativa däremot utgår inte ifrån någonting explicit. Istället utgår den ifrån den mapp "du är i just nu".</p><p>Det lättaste sättet att förstå sökvägar är att reflektera över hur vi själva navigerar igenom filsystemet i våra operativsystem. Tänk på det. När vi letar efter en fil på hårddisken så öppnar vi först någon mapp. Sedan finns det två saker vi kan göra:</p><ol><li>Öppna en ny mapp i den befintliga mappen,</li><li>Gå ett steg uppåt/bakåt, eller</li></ol><p>Det är även dessa tre verktyg vi har att arbeta med när vi specificerar sökvägar. Varje ord motsvarar en mapp eller en fil. Varje slash-tecken (<code>/</code>) motsvarar idéen om att klicka sig in i en ny mapp. Där ordet efter slash-tecknet denoterar namnet på mappen. Notationen punkt-punkt (<code>..</code>) motsvarar idéen om att gå upp/bakåt en mapp i hierarkin.</p><p>Vi pratade tidigare lite om absoluta och relative sökvägar i relation till <i>Microsoft Windows</i>. Låt oss även prata om absoluta och relativa sökvägar i <a href="http://en.wikipedia.org/wiki/Unix-like">*nix-baserade system</a>. I nästan alla operativsystem fungerar idéen om sökvägar på samma sätt. Punkt refererar relativt till den nuvarande mappen. Punkt-punkt till en mapp uppåt. Ett ord till en fil eller mapp i nuvarande mapp. Och slash används för att koppla ihop dessa. Varje slash denoterar alltså i någon bemärkelse "nästa steg".</p><blockuote>Slash-tecknet denoterar "nästa steg" i en sökväg.</blockuote><p>I t.ex. <i>Mac OS</i> och <i>Linux</i> så fungerar alltså sökvägar på samma sätt som ovan nämnt, med en skillnad. För att specificera absoluta sökvägar i *nix-baserade system så anger vi inte namnet på en enhet (ex: <code>C:</code>) såsom i Windows. Isället börjar vi helt enkelt med tecknet slash (<code>/</code>). Följande är alltså en absolut sökväg:</p><pre><code>/Users/jon-snow/pictures/me.jpg</code></pre><p>Om vi i ett *nix-baserat system vill nå en annan enhet, på samma sätt som vi i Windows kan nå ex. D: så fungerar det ofta som så:</p><pre><code>/Volumes/MyOtherDisk</code></pre><p>För att sammanfatta absoluta och relativa sökvägar så vill vi understryka att det egentligen alltså är mycket enkelt. En relativ sökväg utgår ifrån den mapp där den som använder sökvägen befinner sig. En absolut sökväg utgår ifrån "roten" av den nuvarande enheten.</p><blockquote>En relativ sökväg utgår ifrån nuvarande mapp. En absolut sökväg utgår ifrån någontings rot.</blockquote><p>Förhoppningsvis blir du lite förvirrad av att ovan uttrycker sig i termer av "någontings rot". Det finns olika typer av absoluta sökvägar när vi börjar tala om nätverk, och det är dessa vi ska se närmare på strax.</p><h3>Protokoll och URL:er</h3><p>För att kunna diskutera sökvägar på internet behöver vi skapa oss en förståelse för två saker: protokoll och URL:er. Låt oss diskutera de en för en.</p><p>Som du nu vet baseras webbsidor på standarden HTML. När vi med andra ord ber webbläsaren hämta en webbsida så anropar den en server som ger oss ett response som innehåller ett HTML-dokument. Vi har kort diskuterat request-response-modellen. Men vi har inte diskuterat de protokoll som möjliggör det. TCP, IP och HTTP bl.a. För att hålla oss fokuserade kommer vi inte att gräva i dessa. Men för att kunna intelligent angripa idéen om URL:er måste vi skapa oss en viss förståelse för protokollet HTTP.</p><p>Men först, vad är ett protokoll? Kom ihåg att vi sa att en klient skickar ett request och en server svarar med ett response. Ett protokoll är helt enkelt en överenskommelse kring hur klienten och servern ska tala med varandra. När vi skickar saker över nätet så skickar vi de i fragmenterade paket och för att routrar, ISP:er och servrar ska veta vart våra paket är på väg, behöver vi protokoll. Här kommer TCP/IP in i bilden. För att servern ska kunna förstå vårt request och för att webbläsaren ska kunna förstå serverns response behöver vi protokollet HTTP (HyperText Transfer Protocol). Protokoll kan alltså liknas vid ett överenskommet språk emellan två parter.</p><blockquote>För att två parter ska kunna kommunicera krävs ett överenskommet språk &mdash; ett protokoll.</blockquote><p>Du har säkert kommit i kontakt med både protokollet <code>http</code> och den säkrare varianten <code>https</code>. Varje gång du skriver in en adress i webbläsaren så anger vi <code>http://</code>. Om vi inte gör det själva är webbläsarna idag tillräckligt smarta för att slänga in det protokollet åt oss.</p><p>Nu när vi vet vad ett protokoll är &mdash; vad är då en URL (Uniform Resource Locator)? En URL är helt enkelt en webbadress. Den pekar på en plats på internet där en webbresurs bör finnas.</p><blockquote>En URL är en webbadress till en resurs på internet.</blockquote><p>När vi skriver in en webbadress i vår webbläsare så skriver vi alltså in en URL. Som tidigare nämnt så hjälper de flesta moderna webbläsare oss att skriva korrekta URL:er. En URL måste nämligen bl.a. innehålla ett protokoll. Var sig det är HTTP, HTTPS, FTP, SFTP o.s.v.</p><h3>Webbadresser i HTML</h3><p>Låt oss nu prata om sökvägar/webbadresser i HTML. Som tidigare nämnt så hanterar webbläsaren endast adresser i URL-format. Oavsett om det är en adress som pekar internt inom samma sida eller externt ut till en annan sida så behöver de vara i URL-format.</p><p>En webbläsare behöver alltså ha en absolut sökväg i URL-formatet. Men när vi specificerar hyperlänkar i vår HTML. T.ex. genom att använda <code>&lt;a&gt;</code>-taggen, så behöver vi faktiskt inte alltid ange kompletta URL:er enligt URL-formatet. De fall då vi inte behöver göra det är alltså när vi refererar till resurser inom vår egen sida (domän). Om vi däremot vill referera till en resurs utanför vår domän så behöver vi ange en komplett adress i URL-formatet.</p><blockquote>I HTML behöver vi inte ange protokoll när vi refererar till en URL inom samma domän.</blockquote><p>När vi refererar till en resurs inom vår egen domän så använder vi ett format som närmast liknar det *nix-system använder. Förnim dig det vi tidigare diskuterat! Alltså slash för att denotera nästa mapp, punkt-punkt för att vandra en mapp upp i hierarkin, och en initial slash för att denotera roten.</p><p>Detta blir antagligen enklare genom att diskutera ett par exempel. Anta att vi befinner oss på följande sida: <code>http://example.com/pages/links.html</code>. Nedan följer ett par exempel på hur webbläsaren kommer att översätta våra adresser, om vi specificerar de inom (t.ex.) en <code>&lt;a&gt;</code>-tagg.</p><table class="table table-condensed table-striped"><tr><th>Hyperlänk</th><th>Typ</th><th>Webbläsarens tolkning...</th></tr><tr><td>images.html</td><td>Relativ</td><td>http://example.com/pages/images.html</td></tr><tr><td>../images.html</td><td>Relativ</td><td>http://example.com/images.html</td></tr><tr><td>/images.html</td><td>Absolut</td><td>http://example.com/images.html</td></tr><tr><td>/images/album.html</td><td>Absolut</td><td>http://example.com/images/album.html</td></tr><tr><td colspan="3">Ovan gäller alltså om vi antar att användaren befinner sig på sidan <code>http://example.com/pages/links.html</code></td></tr></table><blockquote class="text-danger">Om vi inte anger ett protokoll kommer webbläsaren att tolka vår URL som intern! Även om vi börjar URL:en med www.</blockquote><p>Notera alltså att om vi inte anger ett protokoll så kommer webbläsaren att tolka våra URL:er som interna till vår domän. Ett vanligt misstag är således att glömma att ange protokollet när vi försöker ange en extern adress. Anta att vibefinner oss på <code>http://example.com</code> och skriver följande:</p><pre><code class="language-markup">&lt;a href="www.google.com"&gt;Klicka här&lt;/a&gt;</code></pre><p>Vi antar att länken ska ta användaren till google.com. Fallet är dock inte så. Eftersom vi inte angett protokoll tolkar webbläsaren adressen som intern. Webbläsaren översätter således adressen till följande:</p><pre>http://example.com/www.google.com</pre><p>Inte riktigt vad vi menade förstås. Det korrekta sättet att skapa ovan URL är alltså genom att även ange protokollet.</p><pre><code class="language-markup">&lt;a href="http://www.google.com"&gt;Klicka här&lt;/a&gt;</code></pre><h3>Ankare</h3><p>En typ av länkar vi ännu inte pratat om är ankare. Ankare är ett sätt att länka till en specifik del av en sida. Föreställ dig en lång sida. Alltså en sida med mycket content där du kan scrolla långt. Ankare hjälper dig då att skapa länkar <b>inom samma sida</b>.</p><blockquote>Ett ankare kan appliceras i slutet av vilken URL som helst.</blockquote><p>Ett ankare börjar med fyrkants-tecknet (hashtag) (<code>#</code>) och sedan vilken sträng som helst.</p><pre><code>#my_anchor</code></pre><p>Vi applicerar alltså ett ankare i slutet av en vanlig URL.</p><pre><code>http://example.com/index.html#my_anchor </code></pre><p>Vi kan alltså använda oss av ankare för att ge användaren en möjlighet att navigera inom samma sida. När vi klickar på en länk med ett ankare så kommer alltså webbläsaren inte bara att ladda den sida vi angett &mdash; utan även scrolla ned till ankarets målposition. Vi kan med andra ord se ankare som en form av "bokmärken" för långa sidor.</p><p>Ankaren har även fler, mer avancerade tillämpningsområdet men det kommer vi in på mycket senare. </p><p>Eftersom ankare är en del av URL:er så är det så att vi inte bara kan använda ankare när vi vill ge användaren en möjlighet att navigera inom samma sida. Vi kan även använda oss av dem när vi vill skicka användaren till ett visst ankare på en annan sida.</p><p>Låt oss exemplifiera för att göra det tydligare. Ponera att vi har en HTML-sida med följande länk i sig.</p><pre><code class="language-markup">&lt;a href="#images"&gt;Bildgalleriet&lt;/a&gt;</code></pre><p>Ovan länk kommer alltså inte att byta sida. Ovan länk är en relativ URL som i browsern kommer att översättas till samma URL som vi är vid, fast med ankaret "#images" pålagt i slutet.</p><p>Ponera om vi istället hade skapat en länk som pekade på en full URL med ett ankare i slutet, såsom nedan...</p><pre><code class="language-markup">&lt;a href="http://example.com/index.html#images"&gt;Bildgalleriet&lt;/a&gt;</code></pre><p>Om vi hade specificerat en URL såsom ovan, hade vi skickat användaren till index.html under domänen example.com. Oavsett vilken sida vi råkade vara på vid tillfället. Det viktiga att förstå är dock att ankaret kommer att fungera i vilket fall. När webbläsaren har nått den sida vi skickat användaren till så kommer den automatiskt att scrolla ned till den plats där ankaret är specificerat.</p><p>Det finns en sak vi ännu inte pratat om vad gäller ankare. Nu vet vi hur man skapar en länk <b>till</b> ett ankare. Men vi har inte pratat om hur man skapar ett ankare som man kan skickas till på en sida. Tidigare så använde vi exemplet <code>#my_anchor</code>, men vart hamnar användaren när den klickar på ankaret? Vart är "målet" för detta ankare specificerat?</p><p>Egentligen är det ganska enkelt. En länk till ett ankare specificeras där vi kan ange en URL, och ett mål för ett ankare specificeras i vilket element som helst, under attributet ID.</p><blockquote>Ankare pekar på egenskapen <code>id</code> i element.</blockquote><p>Låt oss se till ett exempel.</p><pre><code class="language-markup">&lt;!-- Om vi har någonting med ett ID --&gt;
&lt;h1 id="images"&gt;Bildgalleriet&lt;/h1&gt;
 
&lt;!-- Så kan vi sedan länka till det som ett ankare --&gt;
&lt;a href="#images"&gt;Gå till bildgalleriet&lt;/a&gt;</code></pre><p>Med andra ord så kan vi skapa "bokmärken" på våra sidor genom att ge olika element ID:n. När vi sedan vill att en användare snabbt ska kunna navigera till en viss del av sidan (ett "bokmärke") så skapar vi en länk som pekar på just det ID:t, som ett ankare.</p><p>Detta är bara en av många funktioner som ID:n fyller, men det återkommer vi till senare.</p><!-- TODO: This does not belong here--><!-- h4 Länkar och CSS--><!-- p Med hjälp av CSS så kan man skapa olika effekter på sina länkar beroende på vilket state som länken har. Exempelvis--><!--   | kan man få en länk att bli understruken när man "hovrar" över länken. följande CSS på till en länk gör detta. --><!-- pre--><!--   code.language-css--><!--     | a:link{ text-decoration:none; color:#CC3333; }--><!--     | a:visited{ text-decoration:none; color:#CC3333; }--><!--     | a:active{ text-decoration:none; color:#CC3333; }--><!--     | a:hover{ text-decoration:underline; }--><!-- p Det finns flera andra rollover-effekter och du ser några exempel nedan.--><!-- pre--><!--   code.language-css--><!--     | a:hover{ color:#CC6600; }--><!--     | a:hover{ background-color:#99CCFF; }--><!--     | a:hover{ text-decoration:underline overline; }--><!--     | a:hover{ font-style: italic; }--><!--     | a:hover{ background-image:url('egen_bild.gif'); }--><!--     | a:hover{ letter-spacing:5px}--><!--     | a:hover{ cursor:help; }--><!--     | a:hover{ cursor:e-resize}--><!--     | a:hover{ color:#FFFFFF; background-color:#006699; }--><div class="page-header"><h2 href="#02-09-html-forms" name="02-09-html-forms" id="02-09-html-forms">Formulär</h2></div><p>För att användare ska kunna interagera med våra webbsidor har vi flera tillgänglia faciliteter. Vi har pratat om länkar som ger en användare möjligheten att navigera emellan sidor. Vi har pratat om ankare som ger användare möjligheten att navigera inom en och samma sida. Men om användaren vill ge oss data? Om vi t.ex. vill fråga användaren om dennes namn? In kommer formulär och räddar dagen.</p><p>Låt oss, innan vi går vidare se till ett exempel för hur ett formulär skulle kunna se ut.</p><div class="panel panel-default"><div class="panel-heading">Exempelformulär</div><div class="panel-body"><form action="#" method="GET"><div class="form-group"><label for="field-email">E-post</label><input type="text" id="field-email" name="email" placeholder="Din e-post" required="required" class="form-control"></div><div class="form-group"><label for="field-current-name">Lösenord</label><input type="password" id="field-current-name" name="password" placeholder="Ditt l&#xF6;senord" required="required" class="form-control"></div><div class="form-group"><div class="checkbox"><input id="field-gender-man" type="checkbox" name="remember" required="required"><label for="field-gender-man">Kom ihåg mig?</label></div></div><div class="form-group"><input type="submit" value="Skicka!" class="btn btn-default"></div></form></div></div><p>Vanliga scenarion där vi använder formulär är t.ex. användarregistrering, inloggning, kontaktformulär, undersökningar, chat, forum, kommentarsfält, sökfält, etc. Listan är lång. Tänk på sidor som du vanligen brukar besöka. Varje gång du skriver in någon form av fritext på sidan, kryssar i en checkbox, radioknapp eller dyl. så interagerar du nästan alltid med ett formulär. Tänk </p><h3>Att spara data</h3><p>Viktigt att förstå är att vi med endast HTML inte kan göra särskilt mycket med formulär. Vi kan presentera de för användaren, men vi kan inte på några sätt "processa" den data som användaren matar in. För att bearbeta den data som användarna matar in i formulär behöver vi ett script- eller programmeringspråk. Med andra ord t.ex. <code>JavaScript</code>, <code>PHP</code>, <code>Ruby</code>, <code>ASP.NET</code>, eller dyl. För att persistent spara data som kan delas emellan flera datorer behöver vi någon form av <a href="http://sv.wikipedia.org/wiki/Databas">databas</a>. Om vi vill spara data på klientens dator och det inte spelar någon roll ifall andra kan komma åt datan eller ej &mdash; så räcker det med JavaScript och HTML5 (genom <a href="http://diveintohtml5.info/storage.html">persistant storage</a>). Men det viktiga är alltså att förstå att vi med hjälp av endast HTML inte kan spara eller processa datan användare matar in i våra formulär. Men vi kommer prata mer om att processa/spara data ifrån formulär när vi pratar om script- och programmeringsspråk.</p><h3>Att skapa formulär</h3><p>Låt oss skapa formulär. Vi tar det del för del och steg för steg.</p><p>Vi börjar helt enkelt med att använda <code>&lt;form&gt;</code>-element. På samma sätt som <code>table</code> enkapsulerar allt innehåll av en tabell &mdash; så enkapsulerar <code>form</code> allt innehåll av ett formulär. Vi skapar alltså "skalet" för ett formulär som så...</p><pre><code class="language-markup">&lt;form method="POST" action="process-data.php"&gt;
   ...
&lt;/form&gt;</code></pre><p> Ovan kod resulterar rent visuellt inte i någonting alls. På den renderade sidan syns inget formulär. Däremot kommer sidan förstås onekligen innehålla markupen för formuläret. Men eftersom vi ännu inte placerat några formulärkomponenter i vårt formulär så syns ju ingenting.</p><h4>Fritext</h4><p>Låt oss börja med att kika på hur vi ger användaren möjlighet att mata in fritext. Vi har två alternativ att välja emellan.</p><ul><li><code>&lt;textarea&gt;</code></li><li><code>&lt;input type="text"&gt;</code></li></ul><p>Den förstnämnda använder vi när vi vill ge användaren att skriva en längre text. Såsom t.ex. en kommentar eller ett blogginlägg. När vi däremot bara söker kortare information ifrån användaren, såsom t.ex. ett namn eller en adress så passar det andra alternativet ypperligt.</p><p>Låt oss börja med att kika på ett exempel på användande av <code>input</code>. Elementet används för att denotera <a href="http://www.w3schools.com/tags/att_input_type.asp">en mängd olika formkontroller</a>. Allt ifrån checkboxar och radioknappar till fritext och datum. För att webbläsaren ska veta vilken typ av inputkontroll vi vill skapa behöver vi ge ett värde för <code>type</code>-attributet. Det enklaste alternativet är förstås fritext, vilket vi alltså denoterar genom att sätta <code>type="text"</code>.</p><p>Så om vi med andra ord skriver...</p><pre><code class="language-markup">&lt;input type="text" placeholder="Vänligen skriv förnamn här..."&gt;</code></pre><p>Så renderar webbläsaren följande resultat...</p><div class="panel panel-default"><div class="panel-body"><input type="text" placeholder="V&#xE4;nligen skriv f&#xF6;rnamn h&#xE4;r..." class="form-control"></div></div><p>Som du kanske märkte är alltså <code>placeholder</code> ett annat attribut vi kan använda på <code>input</code>-element. Detta attribut anger vi för att helt enkelt specificiera en platshållare för kontrollen. Undersök hur detta fungerar genom att skriva någonting i exempelfältet ovan. En platshållartext är helt enkelt en text som visas när kontrollen är "tom". Det vill säga både innan användaren har skrivit någonting i textfältet, men även så fort som användaren rensar nuvarande text i fältet. Notera att detta attribut <em>inte</em> stöds av alla äldre webbläsare.</p><div class="panel panel-info"><div class="panel-heading">Notera!</div><div class="panel-body">Tänk på att <code>input</code>-elementet endast består av en tagg. Vi behöver alltså inte (och bör inte) ange en stängningstagg. I Tidigare versioner av standarden för HTML var det möjligt att ange en sluttagg. Således kommer detta inte att orsaka något fel i de flesta webbläsare. Men om vi följer standarden HTML5 så finns det ingen anledning att ange en stängningstagg.</div></div><p>Om vi behöver ge användaren en möjlighet att skriva mer än endast en rad text så passar elementet <code>textarea</code> utmärkt. Detta element består, till skillnad ifrån <code>input</code>, utav ett taggpar. Med andra ord en öppningstagg och en stängningstagg. Allt däremellan är text som kommer att visas i textfältet. Låt oss se till ett exempel.</p><pre><code class="language-markup">&lt;textarea placeholder="Textarea stödjer placeholders"&gt;
  Denna text renderas i textarean
&lt;/textarea&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><textarea placeholder="Textarea st&#xF6;djer placeholders" class="form-control">Denna text renderas i textarean</textarea></div></div><h4>Labels</h4><p>Platshållare (i.e. placeholders) kan onekligen användas för att ge användaren ett hum om vad som ska skrivas i vilket fält. Men i många fall behöver vi mer än bara platshållare.</p><p>Till exempel så stödjer inte alla webbläsare placeholders. Vilket skulle rendera fälten helt tomma. Och användaren skulle inte ha en aning om vad som ska skrivas vad. Ett annat problem är förstås att om det redan finns någonting skrivet i fältet (t.ex. eftersom användaren har skrivit det men sen glömt, eller för att webbläsaren har sparat texten). Detta skulle ju alltså göra att platshållartexten inte visas. Eftersom platshållartexten ju endast visas när det faktiskt inte finns en text i formkontrollen.</p><p>Istället för att bara använda placeholders så kan vi alltså även använda elementet <code>label</code>.</p><p>Det som huvudsak skiljer labels ifrån helt vanlig text är att vi kan associera en label med en formkontroll. Detta betyder att webbläsaren t.ex. kan göra så att när användaren klickar på etiketten (label) så hamnar respektive formkontroll i "fokus". Detta betyder även förstås att robotar (t.ex. sökspindlar) lättare kan läsa av vad en viss formkontroll är till för, eftersom de kan läsa etiketten.</p><p>Så låt oss associera en etikett med den fritextkontroll vi såg i tidigare exempel. Kom ihåg att prova klicka på etiketten.</p><pre><code class="language-markup">&lt;label for="firstname"&gt;Förnamn&lt;/label&gt;
&lt;input type="text" placeholder="Vänligen skriv förnamn här..." id="firstname"&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label for="4750685-example-form-name">Förnamn</label><input type="text" placeholder="V&#xE4;nligen skriv f&#xF6;rnamn h&#xE4;r..." id="4750685-example-form-name" class="form-control"></div></div><h4>Radio buttons</h4><p>Radioknappar ger oss möjligheten att låta användaren välja ett och endast ett alternativ, givet flera. Låt oss se till ett exempel. Kom ihåg hur vi (som tidigare diskuterat) använder attributet <code>for</code> för att associera en ettikett med en formkontroll.</p><pre><code class="language-markup">&lt;label for="alt-yes"&gt;Ja&lt;/label&gt;
&lt;input type="radio" id="alt-yes" name="yes-or-no" value="yes"&gt;
&lt;label for="alt-no"&gt;Nej&lt;/label&gt;
&lt;input type="radio" id="alt-no" name="yes-or-no" value="no"&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form><div class="radio"><label for="alt-yes">Ja</label><input type="radio" name="yes-or-no" id="alt-yes"></div><div class="radio"><label for="alt-no">Nej</label><input type="radio" name="yes-or-no" id="alt-no"></div></form></div></div><p>Prova knapparna! Både genom att klicka på själva radioknapparna, men även genom att klicka på dess etiketter.</p><p>Fundera på vad de olika attributen i ovan exempel faktiskt gör. Vi har inte pratat om attributet <code>name</code> tidigare. Attributet går att använda på alla formkontroller och är ett sätt att tilldela ett namn på en viss kontroll. Detta namn är av relevans när det kommer till att processa data i formuläret. Vi kommer som sagt inte riktigt att prata om detta än men du bör ändock veta om att det är vad attributet är till för.</p><p>De två radioknapparna i ovan exempel har ju alltså samma värde för attributet <code>name</code>. Detta innebär att de tillhör samma grupp. Vi sa ju tidigare att radioknappar gör att användaren kan välja ett och endast ett val. Men om vi har flera set av radioknappar på en och samma sida &mdash; hur ska då webbläsaren veta vilka radioknappar som inte får vara valda samtidigt. Jo, genom grupper. Så vi kan alltså omformulera oss som så: En och endast en radioknapp får vara vald per grupp. Och en grupp definierar vi ju alltså genom att ge flera radioknappar samma värde för attributet <code>name</code>.</p><p>Låt oss se till ett exempel.</p><pre><code class="language-markup">&lt;label&gt;Ja eller nej?&lt;/label&gt;
 
&lt;label for="4307904643-alt-yes"&gt;Ja&lt;/label&gt;
&lt;input type="radio" name="yes-or-no" id="4307904643-alt-yes"&gt;
 
&lt;label for="4307904643-alt-no"&gt;Nej&lt;/label&gt;
&lt;input type="radio" name="yes-or-no" id="4307904643-alt-no"&gt;
 
&lt;label&gt;Vilken frukt?&lt;/label&gt;
 
&lt;label for="4307904643-alt-apple"&gt;Äpple&lt;/label&gt;
&lt;input type="radio" name="fruit" id="4307904643-alt-apple"&gt;
 
&lt;label for="4307904643-alt-banana"&gt;Banan&lt;/label&gt;
&lt;input type="radio" name="fruit" id="4307904643-alt-banana"&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label>Ja eller nej?</label><div class="radio"><label for="4307904643-alt-yes">Ja</label><input type="radio" name="yes-or-no" id="4307904643-alt-yes"></div><div class="radio"><label for="4307904643-alt-no">Nej</label><input type="radio" name="yes-or-no" id="4307904643-alt-no"></div><label>Vilken frukt?</label><div class="radio"><label for="4307904643-alt-apple">Äpple</label><input type="radio" name="fruit" id="4307904643-alt-apple"></div><div class="radio"><label for="4307904643-alt-banana">Banan</label><input type="radio" name="fruit" id="4307904643-alt-banana"></div></div></div><h4>Checkboxes</h4><p>Checkboxes använder vi till skillnad ifrån radio buttons när vi vill ge användaren möjligheten att välja ett, eller flera alternativ av många. Mycket användbart när det kommer till frukt! I övrigt fungerar de i stort sett som radioknappar.</p><pre><code class="language-markup">&lt;input type="checkbox" name="fruit" value="apple" id="alt-apple"&gt;
&lt;label for="alt-apple"&gt;Apple&lt;/label&gt;
&lt;input type="checkbox" name="fruit" value="banana" id="alt-banana"&gt;
&lt;label for="alt-banana"&gt;Banan&lt;/label&gt;
&lt;input type="checkbox" name="fruit" value="grapes" id="alt-grapes"&gt;
&lt;label for="alt-grapes"&gt;Vindruvor&lt;/label&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><div class="checkbox"><input id="8769832-alt-apple" type="checkbox" name="fruit" value="apple"><label for="8769832-alt-apple">Äpple</label></div><div class="checkbox"><input id="8769832-alt-banana" type="checkbox" name="fruit" value="banana"><label for="8769832-alt-banana">Banan</label></div><div class="checkbox"><input id="8769832-alt-grapes" type="checkbox" name="fruit" value="grapes"><label for="8769832-alt-grapes">Vindruvor</label></div></div></div><p>Attributet <code>value</code> specificerar alltså vilket värde som kommer att associeras med respektive nyckel (alltså checkboxgruppen "fruit"). Vi återkommer till detta när vi pratar om vad som händer när man skickar ett formulär.</p><h4>Select list</h4><p>Ibland har vi så många alternativ vi vill erbjuda en användare, att det skulle bli absurt att försöka presentera alla som t.ex. radioknappar. Ett vanligt use-case är t.ex. att välja land. Det finns så många länder i världen att sidan skulle bli jättelång om vi skulle presentera alla. In kommer <code>&lt;select&gt;</code>-listor och räddar dagen.</p><pre><code class="language-markup">&lt;select name="fruit"&gt;
  &lt;option value="banana"&gt;Banan&lt;/option&gt;
  &lt;option value="apple"&gt;Äpple&lt;/option&gt;
  &lt;option value="grapes"&gt;Vindruvor&lt;/option&gt;
  &lt;option value="orange"&gt;Apelsin&lt;/option&gt;
&lt;/select&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label for="select-fruit">Vad vill du äta till frukost?</label><select id="select-fruit" name="fruits" class="form-control"><option value="banana">Banan </option><option value="apple">Äpple</option><option value="grapes">Vindruvor</option><option value="orange">Apelsin</option></select></div></div><p>Återigen så använder vi alltså attributet <code>value</code> för att denotera vad som kommer att skickas om användaren har valt just det valet (<code>option</code>).</p><p>I vanliga <code>select</code>-listor kan användaren bara välja ett alternativ i listan. Men om vi istället sätter egenskapen <code>multiple</code> så tillåter listan användaren att välja flera alternativ. Beroende på vilken webbläsare användaren befinner sig i så fungerar detta på lite olika sätt. Men oftast fungerar det att (1) klicka och dra, (2) hålla in <code>ctrl</code> (Windows) eller <code>cmd</code> (Mac) och välja en i taget, eller (3) hålla in shift för att välja två stycken och alla däremellan. Du känner rimligen igen dessa konventioner ifrån när vi markerar filer i operativsystemet. Nästan oavsett operativsystem.</p><p>Att implementationen av denna <code>select</code>-kontroll skiljer sig ifrån webbläsare till webbläsare understryker en viktig poäng. Webbläsare väljer själva hur de ska implementera standarden. Detta betyder att vissa element (du kommer t.ex. att märka detta när vi pratar om elementet <code>&lt;video&gt;</code>) renderas på helt olika sätt i olika webbläsare. Detta av naturliga skäl. En webbläsare för mobiltelefoner måste rimligen hantera en (t.ex.) <code>select</code>-lista annorlunda. Det senare eftersom mobilanvändare ju interagerar med (t.ex.) touch, och inte mus + tangentbord.</p><pre><code class="language-markup">&lt;select name="fruit" multiple&gt;
 ...
&lt;/select&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label for="89437059324-select-fruit">Vad vill du äta till frukost?</label><select id="89437059324-select-fruit" name="fruits" multiple="multiple" class="form-control"><option value="banana">Banan</option><option value="apple">Äpple</option><option value="grapes">Vindruvor</option><option value="orange">Apelsin</option></select></div></div><h4>Submit</h4><p>Så när vi har komponterat ihop det formulär vi vill ha så måste vi ju ge användaren en möjlighet att skicka iväg formuläret. För det behöver vi en submit-knapp. Vi använder då åter elementet <code>&lt;input&gt;</code>, men sätter attributet <code>type</code> till <code>submit</code>.</p><p>Easy as pancakes! Låt oss se till ett exempel.</p><pre><code class="language-markup">&lt;input type="submit" value="Skicka!"&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><input type="submit" value="Skicka!" class="btn btn-default"></div></div><h3>Att skicka formuläret</h3><p>Men vad händer egentligen när användaren skickar ett formulär? Vart skickas datan? Hur kan vi hantera den? Försök förnimma dig om att vi tidigare i detta kapitel talade om att HTML i sig inte är tillräckligt för att processa formulär. Det är fortfarande sant.</p><p>När användaren klickar på en submit-knapp i ett formulär så skickas det ifyllda datat med i nästa request. Vad betyder det? Ett request är ju alltså när vår webbläsare ber om en ny sida. Vår webbläsare skickar ett HTTP request som tas emot av en server, som i sin tur svarar med ett response. Ett response som slutligen renderas av vår webbläsareKnappen leder oss till en ny sida som defineras genom attributet <code>action</code>.</p><p>Så, när användaren klickar på en submit-knapp i ett formulär så skickas det ifyllda datat med i nästa request. Det betyder att när requestet kommer till servern som ska hantera request:et och svara med ett response, så har servern tillgång till den data användaren fyllde i formuläret.</p><p>Men vart skickas datat mer specifikt? Jo, det request som kommer göras är alltså det som finns specificerat i <code>action</code>-attributet i formulärets <code>form</code>-tagg. Med andra ord är submit-knappar egentligen som en helt vanlig länk. När vi klickar på knappen så skickas vi dit där attributet <code>action</code> pekar. När vi klickar på en vanlig länk så skickas vi dit där attributet <code>href</code> pekar. Men den huvudsakliga skillnaden mellan en vanlig länk och en submit-knapp för ett formulär är alltså att datat i formuläret kodas och skickas med i request:et.</p><p>Action-attributet används alltså som så:</p><pre><code class="language-markup">&lt;form action="put/target/url/here"&gt; &lt;/form&gt;</code></pre><h4>HTTP Methods</h4><p>När användaren klickar på en submit-knapp i ett formulär så skickas alltså datat med i ett request som görs emot den url som specificeras i action-attributet. Ok, men hur skickas datat med? För att förstå det måste vi förstå att det finns två olika metoder att skicka formulärdata över HTTP.</p><ul><li>POST, och</li><li>GET</li></ul><p>Anta att vi skapar ett formulär på sidan <code>http://example.com/login.php</code>. Anta att formulärets action pekar på <code>http://example.com/process_login.php</code>. Om vi använder oss av HTTP-metoden <code>GET</code> så skulle det request som konstrueras se ut något sånt här:</p><pre>http://example.com/process_login.php?username=snow&amp;password=supersecret&amp;remember=1</pre><p>Formulärdatat skickas alltså direkt i URL:en. Allting efter frågetecknet (<code>?</code>) är en urlkodad sträng av formulärdatat. Datat är kodat enligt principen nyckel/värde. Om vi analyserar strängen lite närmare upptäcker vi att den följer följande konvention.</p><pre><code>key=value</code></pre><p>Där <code>key</code> ersätts med det värde vi gett <code>name</code>-attribuet för respektive formkontroll. Ordet <code>value</code> ersätts i sin tur av det faktiska värdet för den formkontrollen.</p><p>Sedan märker vi även att varje nyckel-värde-par avdelas med hjälp av ett och-tecken (<code>&amp;</code>). Som så...</p><pre><code>key1=value1&amp;key2=value2&amp;key3=value3...</code></pre><div class="panel panel-warning"><div class="panel-heading">Varning!</div><div class="panel-body">Viss formulärdata (såsom t.ex. login) bör <strong>inte</strong> skickas i <code>GET</code>. Du kommer att få förklaringar till varför när vi pratar om den andra metoden &mdash; <code>POST</code>.</div></div><h3>URL Encoding</h3><p>Både nycklarna såväl som värdena kodas med en teknik som kallas <a href="http://www.w3schools.com/tags/ref_urlencode.asp">urlencoding</a>. Detta innebär icke-numeriska och icke-alfabetiska tecken ersätts med någon form av kod. Varför? Jo, för att undvika <a href="http://en.wikipedia.org/wiki/Parsing">parsing</a>-problem. Eftersom värdena skickas konkatenerade i en enda lång sträng, så betyder det att den som ska använda värdena måste parse:a dem. Att parse:a ett givet stycke text betyder innebär i stort sett att "tolka" det givna stycket enligt ett givet set "grammatiska" regler.</p><p>För att göra behovet av urlencoding mer uppenbart. Föreställ dig ett formulär med ett fritextfält. Föreställ dig sedan att användaren fyller i någon text med ett och-tecken (<code>&amp;</code>) i mitten. Eftersom och-tecknet används som avdelare emellan set av nyckel-värde-par, så kommer parser:n (alltså det program/maskin som parse:ar strängen) bli tokförvirrad. Så fort parser:n stöter på ett och-tecken kommer den att avsluta nuvarande nyckel-värde-par och anta att nästa börjar. </p><p>Urlencoding är alltså anledning till att mellanslag ersätts med <code>%20</code> i url:er. Detta vilket du kanske redan stött på.</p><h4>HTTP POST vs HTTP GET</h4><p>Vi nämnde tidigare att det finns två sätt att skicka formulärdata över HTTP. <code>POST</code> och <code>GET</code>. Vi har även kort nämnt att de olika metoderna är olika passande för olika situationer. Detta reflekteras även av deras namn. Tänk på det. Post och get. Förstnämnda är designad för att posta data. Sistnämnda är designad för att hämta data. Distinktionen mellan dessa är förstås varken solkar eller svartvit. Men om vi ser det som en tumregel kan det bli lättare att välja vilken teknik (POST eller GET) vi ska använda.</p><p><code>POST</code> bör vi alltså huvudsakligen använda när vi på något sätt vill skicka data till servern. Föreställ dig till exempel ett registreringsformulär. Vi vill skicka data till servern. Vi vill säga "det här är mina uppgifter, vänligen skapa ett konto åt mig". Eller föreställ dig ett kommentarsfält. Vad säger vi till servern? "Här har du min kommentar! Vänligen posta den."</p><p>Den mer formella tumregeln är att requests som riskerar att ha <a href="http://en.wikipedia.org/wiki/Side_effect_(computer_science)">sidoeffekter</a> bör utföras över POST. Vi kommer att prata mer om vad sidoeffekter när vi pratar om programmering. Men med requests som riskerar sidoeffekter, så menar vi här requests som riskerar att förändra state på servern. T.ex. förändra något i en databas. Därav t.ex. registrering.</p><p><code>GET</code> å andra sidan bör vi alltså huvudsakligen använda när vi på något sätt vill hämta data. Exempel på detta kan t.ex. vara <a href="http://en.wikipedia.org/wiki/Pagination">paginering</a>. Med paginering menar vi alltså när en stor mängd content delas upp på flera sidor. Det är då vanligt förekommande att man använder sig av <code>GET</code>-tekniken för i request:et skicka med vilket sidnummer vi vill se.</p><p>Ett annat lämpligt scenario för GET är t.ex. sökningar och filtrering. Föreställ dig en webbshop med en sökruta. När vi söker efter en produkt så förändrar vi ju självklart inte några produkter på webbshop:ens server. Vi använder då GET för att berätta för servern vilken/vilka term/-er vi har sökt &mdash; så att servern kan svara med rätt response.</p><p>Den kanske mest uppenbara skillnaden emellan <code>GET</code> och <code>POST</code> är förstås <em>hur</em> formulärdatan skickas. Med förstnämnda tekniken skickas formulärdatat i URL:en själv. Således är formulärdatat uppenbart synligt för användaren. Genom att däremot använda sistnämnda tekniken (POST) så skickas formulärdatan som en HTTP-header. Således är datan inte synlig i URL och inte uppenbart synlig för användaren.</p><p>Notera att vi uttrycker oss i termer av <em>uppenbart synlig</em>. Detta är medvetet. Även HTTP headers går att analysera. Så bara för att vi skickar data genom POST betyder det inte att vi är helt säkra. Även POST-data går att analysera. Dock krävs det då en lite mer tekniskt händig användare.</p><table class="table table striped"><tr><th>Metod</th><th>Skickas..</th><th>Användningsområde</th></tr><tr><td>GET</td><td>..i slutet av URL:en</td><td>När vi vill använda formulärdatat för att hämta någonting.</td></tr><tr><td>POST</td><td>..som en HTTP-header</td><td>När vi vill använda formulärdatat för att förändra någonting på servern.</td></tr></table><h3>Komplett exempel</h3><p>Låt oss, innan vi snurrar ihop detta kapitels säck, kolla in ett komplett formulärexempel.</p><pre><code class="language-markup">&lt;form action="#" method="GET"&gt;
  &lt;label for="field-name"&gt;Ditt namn&lt;/label&gt;
  &lt;input type="text" id="field-name" name="name" placeholder="Ditt namn" required&gt;
 
  &lt;label&gt;Vad vill du äta till frukost?&lt;/label&gt;
 
  &lt;label for="field-pancakes"&gt;Pannkakor&lt;/label&gt;
  &lt;input type="radio" id="field-pancakes" name="breakfast" value="pancakes"&gt;
 
  &lt;label for="field-scrambled"&gt;Äggröra&lt;/label&gt;
  &lt;input type="radio" id="field-scrambled" name="breakfast" value="scrambled"&gt;
 
  &lt;label for="field-toast"&gt;Övrigt&lt;/label&gt;
  &lt;input type="radio" id="field-toast" name="breakfast" value="toast"&gt;
 
  &lt;input type="submit" value="Skicka!"&gt;
&lt;/form&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form action="#" method="GET"><div class="form-group"><label for="99986458-field-name">Ditt namn</label><input type="text" id="99986458-field-name" name="name" placeholder="Ditt namn" required="required" class="form-control"></div><label>Vad vill du äta till frukost?</label><div class="form-group"><div class="radio"><input id="99986458-field-pancakes" type="radio" name="breakfast" value="pancakes" required="required"><label for="99986458-field-pancakes">Pannkakor</label></div><div class="radio"><input id="99986458-field-scrambled" type="radio" name="breakfast" value="scrambled" required="required"><label for="99986458-field-scrambled">Äggröra</label></div><div class="radio"><input id="99986458-field-toast" type="radio" name="breakfast" value="toast" required="required"><label for="99986458-field-toast">Toast</label></div></div><input type="submit" value="Skicka!" class="btn btn-default"></form></div></div><p>Prova att skicka formuläret och notera dels vad attributet <code>required</code> orsakar, samt vad som händer i webbläsarens adressfält.</p><div class="page-header"><h2 href="#02-10-html-doctypes" name="02-10-html-doctypes" id="02-10-html-doctypes">Doctypes och webbläsarstöd</h2></div><p>HTML har funnits i fler än ett par år, och med de åren på nacken kommer en mer än brokig historia. Det har länge funnits fler än en enda browser. Och eftersom de flesta browsers (självklarligen) vill äga majoriteten av marknaden har gett upphov till uttrycket <a href="http://en.wikipedia.org/wiki/Browser_wars" target="_blank">The Browser Wars</a>. Webbläsare slåss om att vinna den stora majoriteten av användare.</p><p>Detta har (bland andra anledningar) gett upphov till att webbläsare i olika skeden implementerat olika delar av HTML-, CSS- och JavaScript-specifikationerna. Med andra ord, att olika "dialekter" av samma språk varit tillåtet i olika webbläsare. Med andra ord att vi kan skriva vissa saker i vissa webbläsare och andra i andra, vilket gör att webbläsare A kanske inte förstår uttryck B, som webbläsare C förstår.</p><p>För att försöka vara i framkant har webbläsare implementerat experimentell funktionalitet. Sedan har webbutvecklare börjat använda dessa funktioner, och börjat förlita sig på existensen av dessa funktioner. Vilket har lett till problem när dessa webbsidor sedan läses i webbläsare som inte implementerat dessa funktioner. Kort sagt, så är det en soppa.</p><h3>Kan jag använda...</h3><p>Om du ska ta med dig en poäng ifrån det här kapitlet så bör det vara denna. Anta aldrig att alla webbläsare stödjer den funktionalitet du vill använda. För att ta reda på vilka webbläsare som stödjer en viss funktionalitet du vill använda brukar en enkel webbsökning på funktionaliteten plus termen "browser support" göra jobbet. Om du vill undersöka någonting som är relaterat till HTML5- eller CSS3-standarden så är även <a href="http://caniuse.com/">caniuse.com</a> en mycket bra resurs.</p><h3>Doctypes</h3><p>Webbläsarkrigen har (bland andra anledningar) gjort att det är viktigt att deklarera vilken HTML-standard våra dokument följer. Detta så att webbläsaren, "intelligent" (utan att gissa) kan parse:a (tolka) vår fil enligt rätt specifikation.</p><p>Om du har svårt att förstå varför vi behöver dessa standarder, stanna upp och fundera över faktumet att html-dokument egentligen bara är text. Ingenting annat. Precis som med naturligt språk, så måste mottagaren av meddelandet förstå hur den ska avkoda informationen. Vi kan alltså se doctype-deklarationen lite som att vi berättar för webbläsaren som ska läsa filen vilket dialekt av HTML vi pratar. Eller kanske snarare vilken grammatik vi använder i vårt dokument. Tänk tillbaka till filtypskapitlet.</p><p>Eftersom det finns olika HTML-standarder så finns det alltså olika sätt att uttrycka HTML. Således betyder samma sak olika saker beroende på vilken standard vi använder när vi läser dokumentet.</p><p>FÖr att berätta för webbläsaren vilken standard dokumentet bör läsas med behöver vi på den absolut första raden i dokumentet ange en doctype. Vi definerar doctypes med syntaxen <code>&lt;!DOCTYPE x&gt;</code>. Där <code>x</code> ersätts med den faktiska doctype:en. Nedan följer ett par exempel för hur man deklarerar doctypes.</p><p>För att deklarera att ett dokument följer standarden HTML5 skriver vi helt enkelt följande...</p><pre><code class="language-markup">&lt;!DOCTYPE html&gt;</code></pre><p>Och i kontexten av ett HTML-dokument skulle det se ut som följande...</p><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Min sida&lt;/title&gt;
    ...
  &lt;/head&gt;
  &lt;body&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Om du inte har en medveten anledning till att använda någonting annat än HTML5, så hävdar vi att det inte finns någon anledning att göra det. Med andra ord, så skulle vi uppmana dig till att antingen hålla dig till HTML5 eller läsa på mer om doctypes om du vill använda någon annan.</p><blockquote>Håll dig till HTML5, alltså <code>&lt;DOCTYPE html&gt;</code>, så länge du inte har en annan medveten anledning.</blockquote><h4>Äldre doctypes</h4><p>Men det finns ju onekligen ett antal äldre doctypes som motsvarar äldre standarder. Låt oss snabbt diskutera igenom några stycken för att skapa oss en uppfattning om varför de har funnits och vad de har gjort.</p><p><code>HTML 4.01 Strict</code> tillåter alla HTML 4.01-element och -attribut, men tillåter <em>inte</em> de som deprekerats ("deprecated") i HTML 4.01-standarden. Närmare bestämt, element och attribut som rör visuell presentation snarare än struktur och content, såsom elementet <code>&lt;font&gt;</code> eller attributet <code>bgcolor="#000000"</code>.</p><div class="panel panel-default"><div class="panel-heading">Doctype för HTML 4.01 Strict</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</code></pre></div></div><p>Även <code>HTML 4.01 Transitional</code> tillåter alla element och attribut som är tillåtna i HTML 4.01, <em>inklusive</em> de som rör presentation (se förklaring i ovan paragraf).</p><div class="panel panel-default"><div class="panel-heading">Doctype för HTML 4.01 Transitional</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</code></pre></div></div><p>Det finns som sagt markant fler doctypes än dessa. Men vi rekommenderar alltså att du helt enkelt håller dig till <code>HTML5</code>. Genom att således deklarera dokumenttypen <code>&lt;!DOCTYPE html&gt;</code>. Vill du läsa mer om doctypes kan du t.ex. göra det hos <a href="http://www.w3schools.com/tags/tag_doctype.asp">W3 Schools</a> eller på <a href="http://en.wikipedia.org/wiki/Document_type_declaration">Wikipedia</a>.</p><div class="page-header"><h2 href="#02-11-html-encodings" name="02-11-html-encodings" id="02-11-html-encodings">Character encoding</h2></div><p>Kanske har du redan märkt att när man skapar html-dokument som innehåller tecken såsom <code>å</code>, <code>ä</code>, <code>ö</code> kan det hända att de ersätts med en uppsjö a mystiska tecken. Lösningen på detta är <code>character sets</code>.</p><p>För att göra en lång historia kort så var det alltså så att man i datorernas tidiga dagar representerade tecken som <a href="http://sv.wikipedia.org/wiki/ASCII" target="_blank">ASCII</a>-koder. T.ex. så representerades <code>A</code> genom <code>65</code> och <code>a</code> genom <code>97</code>.</p><p>ASCII-tabellen använde sig av 7 bitar, vilket resulterade i 128 olika tecken (eftersom <code>2^7=128</code>), varvid vissa var "unprintable" kontroll-tecken. Som du säkert kan tänka dig upptäckte man snabbt att detta var fullt otillräckligt för att lagra all världens olika tecken. Vi har ju förstås inte bara åäö att arbeta med, utan även kinesiska, grekiska, arabiska o.s.v.</p><blockquote>There is no such thing as plain text<footer>&mdash; <a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></footer></blockquote><p>Ovan citat understryker faktumet att datorer egentligen är väldigt korkade och bara gör det vi säger åt dem. Utan att berätta för en dokumentläsare på vilket sätt vi sparat ett visst tecken så har den ingen chans att veta vad det är för tecken, hur det ska visas, eller ens vart tecknet slutar.</p><p>In kommer <a href="http://sv.wikipedia.org/wiki/UTF-8" target="_blank">utf-8</a> och räddar dagen! Detta är kort sagt är ett sätt att representera <a href="http://sv.wikipedia.org/wiki/Unicode_transformationsformat" target="_blank">Unicode</a>-tecken. Och kort sagt möjliggör användning av världens alla tecken. Och som kort sagt blivit den vanligaste teckenkodningen för webbsidor.</p><p>Ett dokuments teckenkodning sätter vi genom att skapa en <code>&lt;meta&gt;</code>-tag med attributet <code>charset</code> satt till valfritt charset (såsom just utf-8). Eftersom detta tillhör meta-information om dokumentet skall vi placera taggen under <code>&lt;head&gt;</code>. Vidare bör vi även specificera vårt <code>charset</code> så <a href="http://stackoverflow.com/questions/5572471/in-head-which-comes-first-meta-or-title" target="_blank">tidigt som möjligt</a> i <code>&lt;head&gt;</code> eftersom webbläsaren behöver veta vilken teckenkodning vi använt för att ordentligt kunna läsa det dokument den redan läser.</p><div class="panel panel-default"><div class="panel-heading">Ett dokument som definierar character set:et utf-8</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;The utf-8, I speak!&lt;/title&gt;
  &lt;/head&gt;
&lt;/html&gt;</code></pre></div></div><h1 href="#03-00-css-intro" name="03-00-css-intro" id="03-00-css-intro">CSS</h1><p class="lead">Om HTML beskriver en webbsidas innehåll så beskriver CSS hur detta innehåll ser ut. Om webben var en teaterpjäs skulle HTML vara manuset och CSS regissören. "Du ska stå där, du där och du där! Vänta nu, du behöver ha en grön hatt, och du behöver ha en mask och en cape!"</p><div class="page-header"></div><h2 href="#03-01-css-intro" name="03-01-css-intro" id="03-01-css-intro">Introduktion till CSS</h2><p>CSS &mdash; (Cascading StyleSheets) är stilmallar i praktiken används till att formge dokument. Formge färg, teckensnitt, positionering, justering, backgrunder, scroll, o.s.v. En enda CSS-mall kan styra tusentals dokument och det är då enkelt att ändra formateringen genom att det bara i CSS-mallen.</p><p>CSS har tagit HTML ett steg längre och möjliggjort formateringar och effekter som inte fanns i HTML standarden. En av fördelarna med CSS är att flera mallar kan användas  och de har då företräde inbördes så att en "huvudmall" med de övergripande formateringarna kan ersättas på en lägre nivå av en "lokal mall" som då gäller före huvudmallen. Det är detta som åsyftas när man säger att css är <code>cascading</code>.</p><blockquote>Med css kan vi separera innehåll och presentation.</blockquote><p>CSS är ett initiativ till att separera <b>innehåll</b> och <b>presentation</b>. Att definiera allt relaterat till presentation i en extern mall har många fördelar. Bland annat att:</p><ul><li>Vi kan återanvända presentationsreglerna över många sidor.</li><li>Sidorna laddas snabbare eftersom CSS-filen kan cachas av webbläsaren.</li><li>HTML-sidan lever rimligen längre eftersom vi kan förändra presentationen utan att behöva ändra avsevärt i innehållets struktur.</li></ul><h3>Tillgänglighet &amp; responsivitet</h3><p>En målsättning och effekt av att presentation separeras ifrån innehåll -- är adaptivitet. Om innehållet är helt "befriat ifrån" presentation så skulle man i teorin kunna visa innehållet med vilken typ av presentation som som helst.</p><p>För att göra det mer uppenbart, låt oss fundera över hur situationen såg ut tidigare. Om vi beblandar presentation (css) med vårt innehåll (html) så kommer det vara svårt för en maskin att avgöra vad som hör till presentationen och vad som hör till innehållet. Tänk t.ex. på radbrytningar. Används en radbrytning för att understryka att två paragrafer är skilda ifrån varandra, eller används den för att skapa ett bekvämt visuellt avstånd? Både fallen kan vara sanna. Detta är svårt för en maskin att avgöra.</p><p>I praktiken har detta t.ex. varit ett problem för syn- och hörselskadade. Tänk på <a href="http://en.wikipedia.org/wiki/Screen_reader">screen readers</a> t.ex. som genom text-to-speech försöker läsa upp en sidas innehåll för en användare. Hur skulle det vara om den började läsa saker som "blå bakgrund". </p><p>Ett av målen för W3C (standardsorganisationen för bl.a. css) är att underlätta för konumptionen av webbaserat innehåll på plattformar än just en dator. Det kan handla om allt ifrån Smartphones till enheter för talsyntes och punktskrift (Braille). Genom att separera innehåll ifrån presentation är det alltså markant lättare, eftersom maskinen inte behöver bry sig om att filtrera ut presentationen ifrån innehållet.</p><p>Detta betyder förstås att vi sedan lång tid tillbaka behövt lägga gamla troll som Frames, Iframes, Imagemaps, java applets, javascript, bilder utan ALT-text, GIF-animationer, Flash, Shockwave, PDF-dokument osv. Många funktioner som används idag går då alltså bort helt.</p><div class="page-header"><h2 href="#03-02-css-syntax-och-struktur" name="03-02-css-syntax-och-struktur" id="03-02-css-syntax-och-struktur">CSS syntax och struktur</h2></div><p>För att enklare förstå hur CSS hanteras, föreställ dig att webbläsaren består av två ninjateams. Det första ninjateamet läser HTML-filen och skriver ut en massa text, bilder, listor, tabeller och länkar på skärmen. När första teamet hittar en referens till en CSS-fil, skickar de det till det andra ninjateamet. Det andra ninjateamet går då lös med färgkritor och klipper och klistrar tills allt ser snyggt ut.</p><p>Även om ovanstående exempel är orimligt oseriöst är poängen att rendering av en webbsida (metaforiskt) sker i olika "pass". Där det första är att få ut resultatet av HTML:en på skärmen, och det andra att visuellt ändra på resultatet av HTML:en enligt det som definierats i CSS-filen. Du kommer upptäcka att det finns fler "pass" (och att ordningen kan variera) när vi kommer till JavaScript, men det lämnar vi för nu.</p><p>Varför är det då viktigt att förstå att CSS kommer i det "andra passet"? Jo, eftersom det är viktigt att förstå att CSS <em>appliceras</em> på ett befintligt dokument. Med andra ord, ett CSS-dokument är i sig helt meningslöst. Eftersom ett CSS-dokument då appliceras på ett HTML-dokument så måste varje CSS-regel veta <em>vad</em> den ska appliceras på. Och det är här <code>selectors</code> kommer in i bilden. Låt oss se till ett exempel.</p><blockquote>En css-<code>selector</code> definierar vilka html-<code>element</code> som ska påverkas av en viss effekt.</blockquote><div class="panel panel-default"><div class="panel-heading">CSS-selector för HTML-element</div><div class="panel-body"><p>index.html</p><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;The morning&lt;/title&gt;
    &lt;link rel="stylesheet" href="main.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;As Gregor Samsa awoke one morning from uneasy dreams [..]&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>main.css</p><pre class="line-numbers"><code class="language-css">body{
  background-color: lightblue;
}
p{
  color: #ffffff;
}</code></pre><p>Resultat</p><div class="panel panel-default"><div style="background-color:lightblue; color:#ffffff;padding-top:23px;" class="panel-body"><p>As Gregor Samsa awoke one morning from uneasy dreams [..]</p></div></div></div></div><p>Hur ska vi nu tänka kring det här? De viktigaste sakerna att poängtera är:</p><ul><li><em>Rad 5</em> i html-dokumentet är det som gör att det som säger åt HTML-ninjorna att de behöver hämta CSS-ninjorna och att de ska läsa filen <code>main.css</code>.</li><li><em>Rad 1</em> i css-dokumentet är en <code>selector</code> vars <code>target</code> är <code>&lt;body&gt;</code>-elementet. Det betyder att allt mellan följande <a href="http://en.wikipedia.org/wiki/Bracket#Curly_brackets_or_braces_.7B_.7D" target="_blank">måsvingar</a> (<code>{...}</code>) kommer att appliceras på <em>alla</em> <code>&lt;body&gt;</code>-element i html-dokumentet. Nu bör det ju förstås bara finnas ett body-element men förhoppningsvis har du redan förstått att vi hade kunnat välja vilket annat html-element som helst.</li><li><em>Rad 2 och 5</em> i css-dokumentet är faktiskt css-<code>deklarationer</code>. Det är de som således bestämmer vilken visuell effekt som ska appliceras på just den selector vi definierat.</li></ul><blockquote>En css-<code>selector</code> kan vara vilket html-<code>element</code> som helst.</blockquote><p>Låt oss se det rent generellt. Syntaxen är alltså som följande.</p><div class="panel panel-default"><div class="panel-heading">CSS-syntax uttryckt generellt</div><div class="panel-body"><pre class="line-numbers"><code class="language-css">css-selector{
  declaration-property: declaration-value;
}</code></pre></div></div><p>Så, låt oss uttrycka syntaxen för <code>deklarationer</code> i ord: En css-<code>deklaration</code> består av en <code>egenskap</code> (även kallat: property, nyckel, key), följt av ett kolon (<code>&#58;</code>) som fungerar som en avgränsare mellan nyckeln och värdet. Vidare följt av det faktiska <code>värdet</code> (som kan ges i en mängd olika format, såsom exempelvis <code>left</code>, <code>-32px</code>, <code>233%</code> eller <code>light</code>, beroende på vilken egenskap vi sätter värdet för). Slutligen anger vi ett semikolon (<code>&#59;</code>) för att terminera raden. Det sistnämnda gör det möjligt att skriva flera deklarationer på samma rad (vilket dock oftast gör filen väldigt svårläslig).</p><blockquote>En css-<code>deklaration</code> består av en <code>property</code> (även kallat: nyckel, key, egenskap), ett kolon (<code>&#58;</code>), ett <code>värde</code> och slutligen ett semikolon (<code>&#59;</code>).</blockquote><h3>Exempel på selectors genom klass och ID</h3><p>Utöver att skriva css-selectors som träffar html-element så kan vi även skriva selectors för <code>ID</code>:n och <code>klasser</code>.</p><p>Vi använder ID:n för att defineira "unika" element. Vad menar vi med unika? Jo att om någonting har id:et <code>container</code> så får det endast finnas ett enda element på sidan som har just det ID:et. Vi kan självklart skriva flera css-regler som använder just den selectorn. Men i html-dokumentet får ID:t alltså endast förekomma en enda gång.</p><p>Behöver vi kunna referera till flera element så använder vi oss av klasser. Klasser fungerar på exakt samma sätt som ID:n förutom just det att det är tillåtet att flera element använder samma klass.</p><p>Enklast är nog att som vanligt se till ett exempel över hur detta fungerar.</p><div class="panel panel-default"><div class="panel-heading">Klasser och ID:n</div><div class="panel-body"><p>index.html</p><pre class="line-numbers"><code class="language-markup">...
&lt;p class="redish"&gt;As Gregor Samsa awoke one morning&lt;/p&gt;
&lt;p id="blueish"&gt;from uneasy dreams&lt;/p&gt;
&lt;p&gt;he found himself transformed in his bed&lt;/p&gt;
&lt;p class="redish"&gt;into a monstrous vermin.&lt;/p&gt;
...</code></pre><p>main.css</p><pre class="line-numbers"><code class="language-css">p{
  color: orange;
}
.redish{
  color: red;
}
#blueish{
  color: blue;
}</code></pre><p>Resultat</p><div class="panel panel-default"><div class="panel-body"><p style="color:red;">As Gregor Samsa awoke one morning</p><p style="color:blue;">from uneasy dreams</p><p style="color:orange;">he found himself transformed in his bed</p><p style="color:red;">into a monstrous vermin.</p></div></div></div></div><!-- TODO: This really needs more flesh when it comes to selectors--><!-- There is yet nothing about pseudo elements, nesting nor siblings or--><div class="page-header"><h2 href="#03-03-css-selectorer" name="03-03-css-selectorer" id="03-03-css-selectorer">CSS-selectorer</h2></div><h3>Vanliga selektorer och atttribut</h3><p>Man kan ju tycka att det borde räcka med att kunna hänvisa till element bara via deras typ, klass eller typer. Detta är dock inte sant, suck! Det går att använda att komma åt element på andra sätt och detta gör det lättare man slipper sätta klass eller id på allt. Nedanför finner ni olika selektorer och exempel. Observera att det finns flera....Never ending story! </p><h4>Selektor: *</h4><div class="panel panel-default"><div class="panel-heading">Exempel på HTML och CSS med * </div><div class="panel-body"><pre><code class="language-markup">&lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
&lt;p&gt;En paragraf, yay!&lt;/p&gt;</code></pre><pre><code class="language-css">*{
  font-size: 24px; 
  background:#ff6600;
 }</code></pre></div></div><h4>Selektor: E</h4><div class="panel panel-default"><div class="panel-heading">Exempel på HTML och CSS med E </div><div class="panel-body"><p>E står i detta fall att man använder elementets typ som selektor. </p><pre><code class="language-markup">&lt;p&gt;En paragraf, yay!&lt;/p&gt;</code></pre><pre><code class="language-css">p{
  font-size: 24px; 
  background:#ff6600;
}</code></pre></div></div><h3>PseudoKlasser</h3><h4>E:link</h4><div class="panel panel-default"><div class="panel-heading">Exempel på ett element som är en länk som inte besökts än.</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;</code></pre><pre><code class="language-css">a:link{
  color:pink;
}</code></pre></div></div><h4>E:visited</h4><div class="panel panel-default"><div class="panel-heading">Exempel på ett element som har blivit besökt.</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;</code></pre><pre><code class="language-css">a:visited{
  color:blue;
}</code></pre></div></div><h4>E:hover</h4><div class="panel panel-default"><div class="panel-heading">Exempel på element som har muspekaren över sig.</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;</code></pre><pre><code class="language-css">a:hover{
  color:green;
}</code></pre></div></div><h4>E:active</h4><div class="panel panel-default"><div class="panel-heading">Exempel på länk som är aktivt (exempelvis när användaren trycker ner knappen)</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;</code></pre><pre><code class="language-css">a:active{
  color:purple;
}</code></pre></div></div><h3>Kombinationer</h3><h4>E F</h4><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><p>Alla element F som kommer efter E. Alltså i detta fall alla fyra första paragrafer. </p><pre><code class="language-markup">&lt;div class="yttre"&gt;
  &lt;p&gt;En första paragraf&lt;/p&gt;
  &lt;p&gt;En andra paragraf&lt;/p&gt;
  &lt;p&gt;En tredje paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En fjärde paragraf&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre><pre><code class="language-css">.yttre p{
  color:pink;
}</code></pre></div></div><h4>E+F</h4><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><p>alla element som direkt föregås av E. Alltså i detta fall kommer andra och tredje paragrafen att påverkas. </p><pre><code class="language-markup">&lt;div class="yttre"&gt;
  &lt;p&gt;En första paragraf&lt;/p&gt;
  &lt;p&gt;En andra paragraf&lt;/p&gt;
  &lt;p&gt;En tredje paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En rubrik, yay!&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre><pre><code class="language-css">p + p{
  color:pink;
}</code></pre></div></div><h4>E > F </h4><div class="panel panel-default"><div class="panel-heading">Exempel på element som är direkt barn av ett annat element. </div><div class="panel-body"><p>Anta att vi har följande html...</p><pre><code class="language-markup">&lt;div class="yttre"&gt;
  &lt;p&gt;En första paragraf&lt;/p&gt;
  &lt;p&gt;En andra paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En inre paragraf!&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre><p>Och sedan skriver denna regel..</p><pre><code class="language-css">.yttre > p{
  color:pink;
}</code></pre><p>Så kommer vi således alltså endast "träffa" de två första <code>&lt;p&gt;</code>-elementen eftersom endast de är <b>direkta</b> barn till elementet med klassen <code>.yttre</code>.</p><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><div><p style="color:pink;">En första paragraf</p><p style="color:pink;">En andra paragraf</p></div><div><p>En inre paragraf</p></div></div></div></div></div><!-- TODO: This really needs more flesh when it comes to selectors--><!-- There is yet nothing about pseudo elements, nesting nor siblings or--><div class="page-header"><h2 href="#03-04-css-placering" name="03-04-css-placering" id="03-04-css-placering">Vart skall jag lägga CSS:en?</h2></div><p>När du använder CSS för att formatera en sida kan du infoga CSS-formateringen på tre sätt:</p><ol><li>Extern CSS-mall<br>en extern CSS-mall som kopplas till dokumentet</li><li>I dokumentet<br>i dokumentets huvud head-taggen</li><li>Direkt i element)<br>i elementet där CSS-formateringen ska utföras </li></ol><h3>Extern CSS-mall</h3><p>Det här är den vanligaste användningen av CSS där ett externt dokument som innehåller formateringen kopplas till alla de 
sidor som ska tillämpa formatet. Namnet på CSS-mallen måste ha filtilläget .css och namnet på mallen i exemplet nedan är 
"mall.css". 
Den här metoden är mest effektiv, om formateringen ska ändras behöver du bara göra det i ett enda mall-dokument. 
Här uppfylls målet med att separera innehåll och struktur i dokumenten.
Så här kan koden för sidorna som kopplas till mallen se ut:</p><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;link href="mall.css" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Du kan koppla flera externa CSS-mallar till samma dokument. Om samma selektorer förekommer i båda
mallarna men med olika formatering gäller den mall som angivits senast i radvis ordning. I exemplet nedan 
gäller alltså "mall2.css" före "mall.css": </p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med referenser till flera stilmallar</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;link href="mall.css" rel="stylesheet"&gt;
    &lt;link href="en_till_mall.css" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h3>I dokumentet</h3><p>CSS-formatering angiven direkt i dokumentet kan användas när vissa sidor ska avvika från 
huvudmallens formatering. Den här metoden är inte lika effektiv som att använda en extern CSS-mall.
Om formateringen ska ändras måste det utföras i varje dokument som använder formateringen.
Här formateras rubriken direkt i dokumentet:</p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med css definierad direkt i HEAD</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;style type="text/css"&gt;
      h2 { font-size: 24px; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h3>Direkt i elementet som ska formateras </h3><p>Den här metoden är minst effektiv och här uppfylls inte målet med att separera innehåll och
struktur i dokumenten. CSS-formateringen anges i anslutning till de elementsom ska formateras. 
När formatet ska användas i ett nytt elememnt måste CSS-koden anges på nytt och det innebär att sidorna 
innehåller mycket kod och tar längre tid att laddas i webbläsaren.
Så här kan koden se ut när rubriken formateras direkt i elementet:</p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med css definierad i ett element (även kallat: inline)</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2 style="font-size:24px;"&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Prioriteringsordningen av formateringen är följande:</p><ol><li> HTML-formatering</li><li>CSS-kod i element eller avsnitt där formateringen ska tillämpas</li><li>CSS-kod i dokumentet</li><li>CSS i extern mall</li></ol><p>Detta innebär att du kan börja formateringen i en extern CSS-mall som du kopplar till dina dokument.
Vill du sedan ange avvikande format lokalt i ett dokument formaterar du CSS direkt i dokumentet 
(gäller då före den externa CSS-mallen). Om någon del av dokumentet ska avvika från övrig CSS-formatering 
anger du detta direkt i avsnittet/objektet (gäller då före både CSS i dokumentets HEAD och CSS i en extern
CSS-mall)</p><div class="page-header"><h2 href="#03-05-css-cascade" name="03-05-css-cascade" id="03-05-css-cascade">Cascading</h2></div><p>Tänk på namnet &mdash; <em>Cascading Stylesheets</em> &mdash; stilmallar som "kaskadar". Vad menas egentligen med att de "kaskadar" och hur kan vi använda det till vår fördel?</p><p>Just ordet "<a href="http://sv.wikipedia.org/wiki/Kaskad" target="_blank">kaskad</a>" åsyftar idén om att någonting "faller" ned ifrån en nivå till en annan och så vidare i etapper. I relation till just CSS så handlar detta om att (de flesta) CSS-regler som appliceras på en förälder även gäller för alla förälderns barn.</p><p>Låt oss se till exempel för att bättre förstå vad vi pratar om.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en regel kaskadar igenom ifrån föräldern till barnen</div><div class="panel-body"><pre><code class="language-markup">&lt;body&gt;
  &lt;p&gt;First paragraph&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;Second paragraph&lt;/p&gt;
  &lt;div&gt;
&lt;/body&gt;</code></pre><pre><code class="language-css">body {
  color: green;
}</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="color: green;" class="panel-body"><p>First paragraph</p><div><p>Second paragraph</p></div></div></div></div></div><blockquote>Mer specifika regler skriver över mindre specifika regler oavsett i vilken ordning de dyker upp i css-filerna.</blockquote><p>Att mer specifika regler skriver över mindre specifika regler innebär att vi kan utnyttja kaskadet till vår fördel. Genom att således definiera generella regler på en "hög" nivå och sedan skriva över med de specika ändringar som vi vill göra.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en mer specifik regel <em>skriver över</em> en mindre specifik (kaskadad) regel</div><div class="panel-body"><pre><code class="language-markup">&lt;body&gt;
  &lt;p&gt;First paragraph&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;Second paragraph&lt;/p&gt;
  &lt;div&gt;
&lt;/body&gt;</code></pre><pre><code class="language-css">body { color: green; }
div p { color: blue; }</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="color: green;" class="panel-body"><p>First paragraph</p><div><p style="color: blue;">Second paragraph</p></div></div></div></div></div><p>Låt oss se till ett till exempel där vi använder ett elements ID för att kunna skriva över stilarna specifikt. Notera hur den andra paragrafen fortsätter att vara <b>fetstilad</b> eftersom den "ärver" den regeln av sin förälder. Alltså, egenskapen kaskadar ned ifrån föräldern till barnet.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en mer specifik regel <em>skriver över</em> en mindre specifik (kaskadad) regel</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;First paragraph&lt;/p&gt;
&lt;p id="selected"&gt;Second paragraph&lt;/p&gt;
&lt;p&gt;Third paragraph&lt;/p&gt;</code></pre><pre><code class="language-css">p {
  color: red;
  font-weight: bold;
}
#selected {
  color: orange;
}</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="font-weight:bold; color:red;" class="panel-body"><p>First paragraph</p><p style="color: orange">Second paragraph</p><p>Third paragraph</p></div></div></div></div><div class="page-header"><h2 href="#03-06-css-boxmodell" name="03-06-css-boxmodell" id="03-06-css-boxmodell">Boxmodellen</h2></div><p>Varje element som finns på en sida är egentligen en box. Därav så brukar man ofta prata om Boxmodellen för att se vad som </p>händer runt varje element<pre><code class="language-markup"> -------------------------------------------------------------------------
|                            Margin                                       |
|  ---------------------------------------------------------------------  |
| |                          Border                                     | |
| |  -----------------------------------------------------------------  | |
| | |                        Padding                                  | | | 
| | |  -------------------------------------------------------------  | | |
| | | |                      Content                                | | | |
| | | |                                                             | | | |
| | |  -------------------------------------------------------------  | | |
| | |                                                                 | | |
| |  -----------------------------------------------------------------  | |
| |                                                                     | |
|  ---------------------------------------------------------------------  |
|                                                                         |
--------------------------------------------------------------------------|</code></pre><p>Förklaring av de olika delarna:</p><ul><li>Margin är en transparant area runt ramen. </li><li>Border är en area runt som man kan sätta att ha en viss färg eller typ av border. </li><li>Padding är en area runt ett innehåll och den kommer att ha färgen som själva boxen är färgad i.</li><li>Content är helt enkelt innehållet av boxen som exempelvis kan vara text. </li></ul><div class="page-header"><h2 href="#03-07-css-positionering" name="03-07-css-positionering" id="03-07-css-positionering">CSS Positionering</h2></div><p>Om man tar en sväng på internet och funderar lite på det vi hittills lärt oss om HTML och CSS så inser man snabbt att saker inte alls bara ligger rakt upp och ned i dokumentet. Texter ligger i mitten, vi har kolumner och rader, marginaler och boxar som verkar vara "sticky".</p><p>I det här kapitlet går vi igenom de olika värden vi kan ge css-attributet <code>position</code>, närmare bestämt <code>absolute</code>, <code>relative</code> och <code>static</code>.</p><p>Om vi inte anger någonting annat så är alla element statiskt placerade. Det är värt att notera att även om namnet på attributet <code>position</code> verkar antyda det så är det verkligen inte det enda sättet webbutvecklare positionerar saker genom. Men med rätt förståelse för attributet finns det knappt någon positionering vi inte kommer kunna åstadkomma.</p><h3>Static</h3><p>Om du inte anger någonting annat, kommer element att positioneras statiskt. Alltså följa sin naturliga plats i dokumentet.</p><p>Det är viktigt att uppmärksamma att ett statiskt element på de (tänk dig en sida som ett koordinatsystem) koordinaterna <code>{0,0}</code>, omöjliggör att ett statiskt placerat syskon också placeras på <code>{0,0}</code>. Med andra ord tar statiskt placerade element upp plats och således kan syskon inte ligga på varandra utan placeras istället under (om de är <a href="http://en.wikipedia.org/wiki/HTML_element#Block_elements" target="_blank">block-level element</a>) eller bredvid (om de är <a href="http://en.wikipedia.org/wiki/HTML_element#Inline_elements" target="_blank">inline-level element</a>) varandra.</p><blockquote>Statiska element tar upp plats</blockquote><p>Att ett statiskt element inte kan placeras på ett annat element gäller förstås bara element som är syskon. Ett elements barn placeras förstås naturligt "innuti" förälderelementet.</p><p>Med andra ord. Om ett förälderelement har de (hypotetiska) koordinaterna <code>{0,0}</code> så kommer även första barnet till det elementet ha koordinaterna <code>{0,0}</code>.</p><p>Låt oss se till några exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på statisk positionering för två <code>&lt;div&gt;</code>:ar efter varandra.</div><div class="panel-body"><div style="width:100px;height:100px;background:red; margin-bottom:12px;"></div><div style="width:100px;height:100px;background:blue;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på statisk positionering för en <code>&lt;div&gt;</code> i en <code>&lt;div&gt;</code></div><div class="panel-body"><div style="width:100px;height:100px;background:red;"><div style="width:70px;height:70px;background:blue;"></div></div></div></div><h3>Fixed</h3><blockquote>Fixerade element tar inte upp plats</blockquote><p>Med fixerad positionering säger vi åt ett element att ignorera sin "normala" plats i dokumentflödet och istället placera sig på en position i relation till webbläsarfönstret.</p><p>Med andra ord så är alltså (den tänkta koordinaten) <code>{0,0}</code> högst upp till vänster i webbläsaren. Detta förutsatt att vi sätter föregående värden för egenskaperna <code>left</code> och <code>top</code> vilket då i ett kordinatsystem skulle motsvaras av <code>x</code> och <code>y</code>. Således kan vi sluta oss till att origo är högst upp till vänster i webbläsaren.</p><p>Vad som gör positionering i css intressant är att vi även kan vända steken och istället sätta värden för egenskaperna <code>right</code> och <code>bottom</code>. Vi hanterar då fortfarande <code>x</code> och <code>y</code> i bemärkelsen horisontellt och vertikalt men vi har nu flyttat origo ner till högra hörnet. Plus att vårt koordinatsystem nu fungerar "baklänges". Ett högre värde för right innebär att vi flyttar vårt element längre åt vänster. Sätt detta i relation till att ett högre värde för left flyttar vårt element längre åt höger.</p><blockquote>Tänk på positioneringsteknikerna <code>fixed</code>, <code>absolute</code> och <code>relative</code> som positionering genom i ett  koordinatsystem.</blockquote><p>Medan ovan kommentarer gäller för alla <code>position</code>-värden utom <code>static</code>, gäller följande endast för <code>position</code>-värdet <code>relative</code>.</p><p>Relative ignorerar hur användaren scrollar i ett dokument. En tänkt koordinat, säg <code>{100,120}</code>, står i relation till browserns storlek och endast browserns storlek och det "fönster" där browsern renderar sidan. Med andra ord, kommer elementet alltid att befinna sig 120px ifrån fönstrets topp, <em>inte</em> ifrån dokumentets topp (vilket är hur <code>absolute</code> positionering beteer sig).</p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#blue {
  position: fixed;
  top:  20px;
  left: 30px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Bilden i detta exempel har fixed positionering</div><div class="panel-body"><iframe id="example-css-position-fixed" style="width:100%; height:200px; border:1px solid #dedede; overflow:scroll;"></iframe></div></div><h3>Absolute</h3><p>Även med absolut positionering så säger vi åt ett element att ignorera sitt "normala" dokumentsflöde och istället placera sig på precis de koordinater vi specificierar.</p><p>Frågan är då bara &mdash; precis på de koordinaterna i relation till vad? I det normala fallet så betyder det i relation till fönstret. Men om någonting absolut positionerat befinner sig i någonting annat som är absolut eller relativt positionerat så räknar vi då i relation till den föräldern.</p><p>Ovan blir nog enklare att förstå om vi ser till ett par exempel.</p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#red {
  position: absolute;
  top:   0;
  right: 0;
}
#blue {
  position: absolute;
  bottom: 0px;
  left:   0px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på absolut positionering för två <code>&lt;div&gt;</code>:ar</div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:absolute;top:0;right:0;"></div><div style="width:70px;height:70px;background:blue;position:absolute;bottom:0;left:0;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på absolut positionering för en <code>&lt;div&gt;</code> i en absolut positionerad <code>&lt;div&gt;</code></div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:absolute;top:0;right:0;"><div style="width:70px;height:70px;background:blue;position:absolute;bottom:0;left:0;"></div></div></div></div><h3>Relative</h3><p>När vi positionerar ett element relativt så är det som om vi kombinerar metoderna statisk och absolut. Vi positionerar ett element relativt till dess statiska position.</p><p>Med andra ord, elementet antar först den position den bör få i det statiska flödet, och vi ser nu den platsen som "nollpunkten" (origo). Sedan tas elementet ut ur dokumentflödet och vi placerar det absolut (enligt de koordinater vi angett) i relation till sin statiska placering. </p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#red {
  position: relative;
  top:  0;
  left: 0;
}
#blue {
  position: relative;
  top: -10px;
  left: 10px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på relativ positionering för två <code>&lt;div&gt;</code>:ar</div><div style="height:200px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:relative;top:0;left:0;"></div><div style="width:70px;height:70px;background:blue;position:relative;top:-10px;left:10px;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på relativ positionering för en <code>&lt;div&gt;</code> i en relativt positionerad <code>&lt;div&gt;</code></div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:relative;top:0;right:0;"><div style="width:70px;height:70px;background:blue;position:relative;top:-10px;left:10px;"></div></div></div></div><h3>Video om centrering</h3><p>Om du finner ovan lite konfunderande finns nedan en film som applicerar några av dessa metoder i praktiken.</p><p>I videon är målet att centrera en <code>&lt;div&gt;</code> horisontellt och vertikalt på sidan. Detta vilket bl.a. leder oss in på en teknik som använder sig av positionering genom <code>absolute</code>.</p><div class="panel panel-default"><div class="panel-heading">En video om horisontell &amp; vertikal centrering med css</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/GqCj_sHxzGE?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><h1 href="#04-00-js-intro" name="04-00-js-intro" id="04-00-js-intro">JavaScript</h1><p class="lead">Den största limitationen med HTML och CSS skulle kunna beskrivas med ett att de är ett ord &mdash; statiska. De båda språken klarar av en viss nivå av interaktivitet, men i huvudsak behöver vi någonting mycket mer dynamiskt för att kunna uppnå seriös interaktivitet. Ridån faller.. och in kommer JavaScript!</p><div class="page-header"><h2 href="#04-01-js-intro" name="04-01-js-intro" id="04-01-js-intro">Introduktion till JavaScript</h2></div><p>Om du börjar jobba med HTML och CSS kommer du snabbt upptäcka att de båda teknikerna har sina limitationer. Limitationen skulle enkelt kunna beskrivas som avsaknaden av ett ord &mdash; interaktivitet!</p><h3>Problemet</h3><p>Visst, vi kan använda HTML för att strukturera content, och visst, vi kan använda CSS för att positionera, och style:a innehållet så att det inte bara är snyggt utan även kognitivt lättillgängligt för en människa. Men hur är det egentligen med interaktiveten?</p><p>Förvisso kan vi använda pseudo-selektorn <code>:hover</code> i css för att skapa effekter när användaren låter musen rulla över länkar (såsom t.ex. understrykning). Och visst, vi kan ju genom HTML skapa olika sidor som vi sedan sammanlänkar genom hyperlänkar (<code>&lt;a&gt;</code>-taggen), vilket alltså betyder att användaren interaktivt kan navigera sig emellan dessa sidor.</p><p>Onekligen är ovan två nämnda exempel just det, exempel på interaktiviet vi kan uppnå genom HTML och CSS. Men finns det interaktivitet vi skulle vilja skapa som vi inte kan uppnå med bara HTML och CSS? Föreställ dig en delete-knapp. Föreställ dig att vi har en applikation, vilken som helst, och det finns en knapp som säger "Ta bort mitt konto". Vore det inte då rimligt att be användaren att konfirmera att denne verkligen vill ta bort sitt konto när den trycker på knappen? Självklart.</p><p>Tänk på ovan exempel en stund. Hur skulle vi lösa det genom HTML? Om vi ignorerar galna lösningar (som jag inte alls skulle rekommendera) med <code>&lt;iframe&gt;</code>'s så har vi egentligen bara ett val. Säg att knappen ligger på en sida som heter <code>delete.html</code>. När man trycker på den knappen behöver vi skicka användaren till en annan sida, vi kallar den för <code>confirm_delete.html</code> där användaren presenteras med två möjligheter till. Alltså två nya länkar till två andra sidor. Kanske är dessa länkar samma sidor som innan, kanske inte. Om inte, så har vi skapat två sidor till, nämligen: <code>yes_delete.html</code> och <code>no_delete.html</code>. Rimligen ser du vilken soppa av sidor det här snabbt blir. Och rimligen har du nu kommit på att det är här JavaScript kommer in i bilden.</p><p>Vi diskuterar nu förstås lite halvsanningar eftersom lösningen skulle kunna bli enklare med ett server-side-språk. Men lita på oss när vi säger att JavaScript kommer göra det ännu enklare.</p><p>Låt oss se till hur vi skulle kunna lösa samma sak genom JavaScript.</p><script>$(function(){
  (function(){
    var $container = $('#example-js-confirmation');
    var setup = function(){
      $container.find('a').click(function(){
        if(confirm("Do you really want to delete your account?")){
          var photo = $container.html();
          $container.html('<p style="color:red !important;">La résistance est futile...... <br><br> ALL YOUR BASE ARE BELONG TO US. <br><br> Your account is sleeping with the fishes..<br><br> <a href="#" class="btn btn-info">Oh noes, click to turn back time!</a>');
          $container.find('a').click(function(){
            $container.html(photo);
            setup();
            return false;
          });
        }
        return false;
      });
    }
    setup();
  })();
});</script><div class="panel panel-default"><div class="panel-heading">Exempel på en confirmation dialog genom JS</div><div id="example-js-confirmation" class="panel-body"><a href="#" class="btn btn-large btn-danger">Delete my account</a></div></div><p>När du provat ovan exempel, finns det en till viktig sak att inse. Interaktiveten i ovan exempel sker "isolerat" i den lilla exempelrutan. Resten av sidan påverkas inte. Slutsatsen vi drar är alltså att vi kan använda JavaScript till att uppnå en nivå av interaktivet vi omöjligen kan uppnå med endast HTML och CSS utan att använda flera sidor.</p><blockquote>Med JavaScript kan vi låta användaren interaktivt interagera med sidan utan att den behöver "laddas om".</blockquote><div class="page-header"><h2 href="#04-02-js-placering" name="04-02-js-placering" id="04-02-js-placering">Vart ska jag skriva JavaScript?</h2></div><p>Innan vi lärt oss ett dugg om JavaScript ska vi köra en djupdyk med näsan först, och skriva vårt första skript. Samtidigt kommer vi att diskutera var vi väljer att placera vår kod och hur man bör arbeta med JavaScript.</p><h3>Ett exempelskript</h3><p>Om det enkla skriptet i nästföljande figur körs på en webbsida så tar den helt sonika bort allt dokumentet innehåller och ersätter det med texten "Evil rabbits... osv". När vi använder det här skriptet som ett exempel i detta dokument så får du låtsas som om varje exempel-ruta är en egen webbsida. För om vis kulle köra <code class="language-javascript">document.write("");</code> på hela denna sida skulle vi ju rensa hela sidan vilket skulle göra det väldigt svårt för dig att fortsätta läsa denna text.</p><div class="panel panel-default"><div class="panel-heading">Exempelskriptet</div><div class="panel-body"><pre><code class="language-javascript">document.write("Evil rabbits are taking over our servers! Must find carrots!");</code></pre></div></div><p>Hursomhelst, låt oss nu istället diskutera lite olika platser vi skulle kunna lägga in detta skript på.</p><h3>Direkt i HEAD</h3><p>Ett ställe vi kan placera vår JavaScript på är rakt upp och ner i <code>&lt;HEAD&gt;</code>-taggen. Så länge som vi snurrar in vår JavaScript emellan starttaggen <code>&lt;script&gt;</code> och sluttaggen <code>&lt;/script&gt;</code>. Nedan följer ett exempel i ett minimalistiskt HTML-dokument. När du läser exemplet, tänk framförallt på vart <code>&lt;script&gt;</code>-taggarna och ovan nämn javascript-rad är placerad/-e.</p><div class="panel panel-danger"><div class="panel-heading">JavaScript i <code>&lt;HEAD&gt;</code>-taggen</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
    &lt;script&gt;
      document.write("Evil rabbits...");
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Denna text kommer inte att synas eftersom JavaScriptet skriver över den.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">Evil rabbits...</div></div><p>För att illustrera att detta är någonting som verkligen skapas av JavaScript, så tar vi och <em>kommenterar ut</em> rad 6 såsom nedan. Att kommentera ut en rad gör att den ignoreras av webbläsaren och således inte exekveras.</p><pre data-start="6" class="line-numbers"><code class="language-javascript">// document.write("Evil rabbits...");</code></pre><p>...så får vi istället nedan resultat.</p><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">Denna text kommer inte att synas eftersom JavaScriptet skriver över den.</div></div></div></div><h3>onClick</h3><p>Ett annat ställe vi kan placera vår JavaScript-kod på är i onClick-attributet. Som namnet <code>onClick</code> antyder kommer då koden att exekveras just då &mdash; "on click". Alltså när användaren klickar på elementet i fråga.</p><p>Låt oss se till ett exempel, som använder sig av samma kod.</p><div class="panel panel-danger"><div class="panel-heading">Anonym funktion vid onClick</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;button&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;a onClick="document.write('Evil rabbits...');"&gt;Engage descrution!&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div id="example-js-onclick" class="panel-body"><button class="btn btn-warning">Click to engage destruction!</button><script>$(function(){
  $('#example-js-onclick button').click(function(e){
    $('#example-js-onclick').text('Evil rabbits...');
    e.preventDefault();
  });
});</script></div></div></div></div><p>I ovan exempel finns det tre viktiga skillnader att notera i relation till det första exemplet. Först och främst. Vår JavaScript ligger nu inte längre inom <code>&lt;HEAD&gt;</code>-taggen utan inom <code>&lt;BODY&gt;</code>. Det betyder alltså att vi har specificerat vårt skript bland vårt content och inte vårt meta-content. Eftersom skript inte är content så borde det här ringa en varningssignal om att vi sysslar med en dålig "practice", men det återkommer vi till senare.</p><p>Den andra viktiga skillnaden vi bör inse är att vi inte längre kör vårt JavaScript när sidan laddas utan istället när användaren klickar på en knapp. Vi har alltså inte bara lagt vårt skript rakt av, utan vi har lagt det som en <em>anonym funktion</em> som kommer att köras när <em>event lyssnaren</em> <code>onClick</code> avfyras. Vi kommer att prata mer om <em>event listeners</em> senare men för nu kan du helt enkelt tänka dig det så här. Egenskapen <code>onClick</code> är ett nyckel-värde-par där värdet är en sträng. Denna sträng kommer inte att tolkas som vilken sträng som helst, utan kommer att exekveras som JavaScript. Vi hade således kunnat skriva vilken arbiträr mängd JavaScript som helst mellan de två citationstecknena som delimiterade värdet. Låt oss se till ett exempel till för att verkligen förstå hur det fungerar.</p><div class="panel panel-danger"><div class="panel-heading">Anonym funktion vid onClick</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;a onClick="alert('Hello...'); alert('...you!');"&gt;Welcome me!&lt;/a&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div id="example-js-onclick" class="panel-body"><button onclick="alert(&apos;Hello...&apos;);alert(&apos;...you!&apos;);" class="btn btn-warning">Welcome me!</button></div></div></div></div><blockquote class="text-danger">Glöm nu allt du lärt dig om att skriva inline-javascript i <code>onClick</code> och glöm nästan allt du lärt dig om att skriva JavaScript direkt i <code>&lt;head&gt;</code> &mdash; det finns bättre sätt!</blockquote><p>Som vanligt är detta bättre sätt baserat på idéen om "<a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>" och innebär att vi flyttar vår JavaScript till en separat fil. Och det är detta vi kommer göra i nästa stycke.</p><h3>JS i separat fil</h3><p>Om du inte har en medveten anledning till varför du inte ska göra det så är det bästa sättet att hantera JavsScript &mdash; i en separat fil. På precis samma sätt som vi arbetar med CSS så skapar vi en ny fil som vi döper till <code>ett-schysst-filnamn.js</code>. Notera alltså ändelsen <code>.js</code>. Sedan gör vi på precis (nästan) samma sätt som när vi har en extern CSS-fil. Alltså, vi lägger in ett element i <code>&lt;head&gt;</code> som pekar på vår JavaScript-fil. Som så:</p><div class="panel panel-success"><div class="panel-heading">Ladda in en extern javascript-fil</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">document.write("Oh noes evil rabbits...");</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Oh noes evil rabbits...</p></div></div></div></div><p>Notera alltså rad 5 i ovan exempel. Det är just rad 5 som berättar för webbläsaren vart JavaScript-filen finns. Vi anger .js-filens plats med en relativ sökväg genom att bara skriva <code>filnamnet.js</code> rakt upp och ned. Så webbläsaren kommer alltså leta efter en fil vid namn <code>filnamnet.js</code> i <em>samma mapp</em> som index.html ligger.</p><div class="panel panel-warning"><div class="panel-heading">Överkurs</div><div class="panel-body"><p>Kanske har du märkt att många webbutvecklare laddar in sina JavaScript-filer i <code>&lt;body&gt;</code> och inte i <code>&lt;head&gt;</code>. Detta har med performance och göra, och är egentligen en superb idé! Låt oss prata om varför.</p><p>När en webbläsare renderar en webbsida så går den uppifrån och ned. Och när den stöter på ett request till en extern resurs, såsom en bild, en css-fil, eller en javascript-fil etc. så behöver den stanna, vänta, och ladda in filen. Tänk på det en stund. När vi lägger in en bild i ett html-dokument så lägger vi ju faktiskt inte in bilden utan endast en <em>referens till den plats <code>url</code> där bilden befinner sig</em>. Detta innebär att webbläsaren alltså måste <em>hämta</em> ("ladda ner") denna bild för att faktiskt kunna visa den.</p><p>Eftersom webbläsare endast kan hantera ett limiterat antal requests parallelt så betyder det att sidan lätt fastnar i en <a href="http://en.wikipedia.org/wiki/Bottleneck">flaskhals</a>. Standarden HTTP/1.1 specificerar att en browser max bör hålla <a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">två öppna connections per server</a>, detta vilket uppenbart orsakar en flaskhals ifall vi hämtar 10 bilder, 2 css-filer och 1 javascript-fil ifrån vår egen server.</p><p>Moderna browsers har dock valt att ignorera dessa maxtal och hanterar faktiskt fler <a href="http://www.browserscope.org/?category=network&amp;v=top">parallella uppkopplingar</a> men trots detta har det blivit praxis att låta JavaScript-filerna laddas in allra sist i <code>&lt;body&gt;</code>. Anledningen till detta är alltså att om webbläsaren får en chans att parse:a hela <code>&lt;body&gt;</code>:n innan den krockar med det element som pekar på en javascript-fil, så betyder det att webbläsaren kommer ha en chans att visuellt printa ut sidan för användaren och <em>SEN</em> börja hämta denna javascript-fil.</p><p>Faktum är att det t.o.m. är <a href="http://www.w3schools.com/js/js_howto.asp">tillåtet enligt specifikation</a> att placera <code>&lt;script&gt;</code>-taggar i <code>&lt;body&gt;</code>. Låt oss se till ett exempel över hur detta skulle kunna se ut.</p><div class="panel panel-default"><div class="panel-heading">Ladda in JavaScript-filer i slutet av <code>&lt;body&gt;</code></div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Först lägger vi allt vårt content&lt;/p&gt;
    &lt;p&gt;Och sen sist, laddar vi in js:&lt;/p&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Således används alltså denna teknik för att ge användaren en känsla av att sidan har laddat klart snabbare än den egentligen gör. Om vi lägger våra javascript-filer i <code>&lt;head&gt;</code> kommer webbläsaren alltså att "blocka" sidan och inte printa ut någonting visuellt förrän <em>hela</em> javascript-filen har laddats ned. Men om vi lägger referensen till vår javascript fil i slutet av <code>&lt;body&gt;</code> kommer webbläsaren att rendera hela <code>&lt;body&gt;</code>:n innan den börjar blocka och ladda in javascript-filen.</p><p>Såsom mycket annat i världen så är detta inte svart eller vitt, utan det finns många fall där vi faktiskt bör ladda in JavaScript i <code>&lt;head&gt;</code>. Du kan läsa mer om detta bl.a. <a href="http://stackoverflow.com/questions/14328449/when-do-you-put-javascript-in-body-when-in-head-and-when-use-doc-load">här</a>.</p></div></div><div class="page-header"><h2 href="#04-03-js-variabler" name="04-03-js-variabler" id="04-03-js-variabler">Variabler</h2></div><p>Eftersom JavaScript, som namnet antyder, är ett skriptspråk har vi tillgång till mäktiga koncept såsom variabler och funktioner. En variabel kan metaforiskt ses som en box vi lägger någonting i, och det är just denna box vi kommer att fokusera på i detta kapitel.</p><h3>Vad är variabler?</h3><p>Variabler kan ses som en arbiträr box, av arbiträr storlek, där vi kan placera ett stycke, och endast ett stycke, arbiträr data. Tänk på det en stund. Låt oss formulera om samma sak. En variabel är en pekare mot en arbiträr plats i minnet, av arbiträr storlek, som innehåller arbiträr data. Det är lite närmare sanningen men fortfarande en metafor.</p><blockquote>Variabler kan ses som en arbiträr box, av arbiträr storlek, där vi kan placera ett och endast ett stycke arbiträr data.</blockquote><p>Så hur deklarerar vi då en variabel? Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Variabeldeklaration och tilldelning</div><div class="panel-body"><pre><code class="language-javascript">var name = "Dr. Zaius";</code></pre></div></div><p>I ovan exempel deklarerar ("skapar") vi alltså en variabel och tilldelar den värdet av texten "Dr. Zaius". Således finns det alltså två saker vi gör här. Vi (1) deklarerar, och vi (2) tilldelar. Låt oss se till ett nytt exempel där vi gör dessa steg för steg.</p><div class="panel panel-default"><div class="panel-heading">Deklarering och tilldelning</div><div class="panel-body"><pre><code class="language-javascript">// Deklaration
var name;     // name =&gt; undefined
var age;      // age  =&gt; undefined
 
 // Tilldelning
name = "Dr. Zaius";   // name =&gt; "Dr. Zaius"
age = 42;             // age  =&gt; 42
 
// Deklaration och tilldelning samtidigt
var species = "Orangutang";</code></pre></div></div><p>Notera alltså att ovan exempel illustrerar att det är fullt möjligt att först deklarera en variabel och sedan tilldela den ett värde, i två steg. Detta kommer sig av den enkla anledningen att tilldelning och deklaration är två olika saker.</p><dl class="dl-horizontal"><dt>Deklaration</dt><dd>Att säga att någonting <em>existerar</em>
(<code class="language-javascript">var foo;</code>)</dd><dt>Tilldelning</dt><dd>Att säga vad någonting <em>innehåller</em>
(<code class="language-javascript">foo = "bar";</code>)</dd></dl><p>I många språk deklarerar vi variabler som olika <em>typer</em> beroende på vad för typ av innehåll vi vill kunna lagra i variabeln (text, heltalsnummer, decimaltal etc.) men i JavaScript räcker det med att vi deklarerar att variabeln <em>finns</em>. Vilken typ den sedan är av, avgörs av vad vi sedan väljer att lagra i den. JavaScript är alltså vad vi brukar kalla för ett <a href="http://sv.wikipedia.org/wiki/Typsystem">Dynamiskt typat språk</a>.</p><h3>Video</h3><p>Nedan följer en kort videointroduktion till variabler i JavaScript.</p><div class="panel panel-default"><div class="panel-heading">Videointroduktion till variabler i JavaScript</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/J_XO0AzXE6Q?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><h3>Datatyper</h3><p>Vad kan vi lagra? Kort sagt: vad som helst som faller under JavaScripts tre <a href="http://msdn.microsoft.com/en-us/library/ie/7wkd9z69(v=vs.94).aspx" target="_blank">datatypskategorier</a>: primära datatyper, komposit-datatyper, eller speciella datatyper. Dessa är som följer:</p><table class="table table-condensed"><tr><th>Datatyp</th><th>Förklaring</th><th>Exempel (separerade med ;)</th></tr><tr><td colspan="3" class="table-divider">Primary datatypes</td></tr><tr><td><code>number</code></td><td>Siffror</td><td><code class="language-javascript">0;   12;   -432;   11.4;   -32.4;</code></td></tr><tr><td><code>string</code></td><td>Text</td><td><code class="language-javascript">"Ekonomikum 1A";</code></td></tr><tr><td><code>boolean</code></td><td>Sant eller falskt</td><td><code class="language-javascript">true;   false;</code></td></tr><tr><td colspan="3" class="table-divider">Composite datatypes</td></tr><tr><td><code>array</code></td><td>Listor innehållandes andra datatyper</td><td><code class="language-javascript">[1, 3, 2];   ["Hello", 123];</code></td></tr><tr><td><code>object</code></td><td>Nycklar som pekar på värden</td><td><code class="language-javascript">{ title:"Dr", name:"Snuggles" }</code></td></tr><tr><td colspan="3" class="table-divider">Special datatypes</td></tr><tr><td><code>null</code></td><td>Värdet för ingenting</td><td><code class="language-javascript">null;</code></td></tr><tr><td><code>undefined</code></td><td>Värdet för avsaknaden av ett värde</td><td><code class="language-javascript">undefined;</code></td></tr></table><h3>Likhetstecknet</h3><p>Någonting som ofta är förvirrande när det kommer till programmering är att likhetstecknet (<code>=</code>) i programmering skiljer sig signifikant ifrån likhetstecknet i matematik. Likhetstecknet i matematik implicerar ekvivalens medan likhetstecknet i programmering implicerar tilldelning. Vad är då skillnaden?</p><p>Om två uttryck är ekvivalenta menar vi att vi kan ersätta det första uttrycket med det andra och det betyder samma sak. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Ekvivalens i matematik</div><div class="panel-body"><pre>(1 + 1)  =  (2)</pre>De två uttrycken, isolerade av paranteser, är ekvivalenta och vänstra ledet kan således ersättas med det högra. Detta gäller inte i programmering.</div></div><blockquote>Likhetstecknet i matematik implicerar ekvivalens medan likhetstecknet i programmering implicerar tilldelning.</blockquote><p>Men om ekvivalens inte gäller i programmering, vad gäller då istället? Jo, tilldelning. Med matematisk ekvivalens menar vi att evalueringen (resultatet av att beräkna) av det vänstra ledet är exakt samma sak som evalueringen av det högra ledet. Med tilldelning däremot, menar vi att evalueringen (resultatet av beräkningen) av det högra ledet <em>representeras</em> av det vänstra ledet.</p><p>I matematik tänker vi ofta i termer av sanning, men för att lättare förstå hur imperativ programmering fungerar kan det vara fördelaktigt att istället försöka tänka i termer av att vi "räknar ut värden och lägger de i lådor (variabler)". Boxarna har ingen aning om vart värdena kom ifrån, och värdena har ingen aning om i vilka boxar de kommer placeras.</p><p>Kanske hade det varit lättare att förstå tilldelning om syntaxen (notationen) istället hade varit <code>a &lt;= 23</code>. Alltså: lagra värdet 23 i variabeln a.</p><div class="panel panel-default"><div class="panel-heading">Tilldelning i programmering</div><div class="panel-body"><pre><code class="language-javascript">var a = 1;            // a =&gt; 1
var b = a + 3;        // b =&gt; 4
var c = a + b;        // c =&gt; 5
var d = a + b + c;    // d =&gt; 10</code></pre>Läs ovan, rad för rad, och fundera över varför det resultat som sparas i variabeln blir det som visas i kommentaren till höger.</div></div><blockquote>När vi pratar om programmering är det lättare att tänka att vi "räknar ut värden och lägger resultaten i boxar".</blockquote><div class="page-header"><h2 href="#04-04-js-funktioner" name="04-04-js-funktioner" id="04-04-js-funktioner">Funktioner</h2></div><p>Nu börjar vi närma oss de signifikant mer intressanta delarna av programmering. Funktioner! Funktioner i programmering kan med fördel jämföras med funktioner i matematik. En funktion är som en maskin. En maskin där du kan stoppa in ett ting och få ut ett annat ting. Alltså en funktion (<code>F</code>) som tar emot ett ting (<code>x</code>) och returnerar ett annat ting (<code>y</code>), där detta andra ting, i matematik, kan uttryckas som en funktion applicerad på det första (<code>F(x)</code>).</p><p>PS. Vänligen anmäl oss inte till Högeskoleverket om det skulle vara så att våra matematiska metaforer är inkorrekta. Vi försöker bara använda de här för att skapa en förståelse.</p><p>Innan vi fortsätter prata om hur funktioner fungerar, låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Funktionsdefinition</div><div class="panel-body"><pre><code class="language-javascript">var addition = function(x, y){
  return x + y;
}</code></pre><p>Ovan definerar vi en funktion, som vi namnger <code>addition</code>, och som returnerar resultatet av en addition av dess två parametrar. Motsvarande funktion skulle matematiskt kunna uttryckas:</p><pre>F(x, y) = x + y</pre></div></div><p>Vi har nu sett hur man definierar en funktion. Men hur använder vi den då? Låt oss återigen se till några exempel.</p><div class="panel panel-default"><div class="panel-heading">Funktionsanrop</div><div class="panel-body"><pre><code class="language-javascript">// Först definierar vi en funktion
var addition = function(x, y){
  return x + y;
}
 
// Sen anropar vi funktionen
addition(1, 1);                         // =&gt; 2
addition(30, 5);                        // =&gt; 35
addition(addition(1,2), 4)              // =&gt; 7
addition(addition(1,addition(1,1)), 4)  // =&gt; 7</code></pre><p>Låt oss uttrycka samma sak i matematik för att skapa ytterligare förståelse för vad vi gör:</p><pre><code>Först definierar vi funktionen...
F(x, y) = x + y
 
Sen använder vi den...
         F(1, 1) = 2
        F(30, 5) = 35
    F(F(1,2), 4) = 7
F(F(1,F(1,1), 4) = 7</code></pre></div></div><p>Notera alltså att vi kan skicka resultatet av en funktion som parameter (input) till en annan funktion. Precis som i matematik så måste den innersta beräkningen utföras först innan vi kan utföra den yttre.</p><blockquote>Precis som i matematik behöver det innersta uttrycket räknas ut först innan vi kan fortsätta "utåt".</blockquote><h3>Olika sätt att deklarera funktioner</h3><p>Eftersom JavaScript på gott och ont är väldigt flexibelt finns det olika sätt att deklarera funktioner.</p><h4>Function statement</h4><p>Detta är det klassiska sättet att deklarera funktioner i JavaScript.</p><pre><code class="language-javascript">function myFunc(){ //work };</code></pre><p>Denna metod gör att funktionsnamnet är tillgängligt i hela sitt scope. Även innan den är deklarerad.</p><pre><code class="language-javascript">console.log(myFunc());  // => Hello
function myFunc(){ return "Hello" };</code></pre><h4>Function expression</h4><p>Detta sätt att deklarera kan ses som att vi tilldelar en anonym funktion till en variabel.</p><pre><code class="language-javascript">var myFunc = function(){ //work };</code></pre><p>När vi deklarerar en funktion så här så är den inte tillgänglig före deklarationen, endast efter.</p><pre><code class="language-javascript">console.log(myFunc()); // => TypeError
var myFunc = function(){ return "Hello" };</code></pre><h4>Kombination</h4><p>Vi kan även kombinera ovan två metoder som så:</p><pre><code class="language-javascript">var myFunc = function myFunc(){ // work };</code></pre><h4>Vilket sätt bör vi använda?</h4><p>Så, istället för att gräva ned oss i vilket sätt man bör använda så föreslår vi att du följer <a href="http://www.unicodegirl.com/function-statement-versus-function-expression.html">Douglas Crockford's rekommendation</a> om att använda function expressions. Alltså:</p><pre><code class="language-javascript">var myFunc = function(){ //work };</code></pre><blockquote class="text-info">Välj function expressions över function statements, tills den dag kommer du då intresserar dig av att lära dig varför.</blockquote><div class="page-header"><h2 href="#04-05-js-dom" name="04-05-js-dom" id="04-05-js-dom">Document Object Model</h2></div><p>Document Object Model(DOM) är ett API för HTML och XML dokument. Den definierar den logiska strukturen och hur man kommer åt ett dokument och manipulerar det. </p><h3>Javascript och DOM </h3><p>Med denna modell kan vi nu med hjälp av Javascript kunna modifiera trädet och skapa dynamiska hemsidor. Det handlar alltså om att vi kan ta bort, komma åt, modifiera och lägga till element.</p><h3>Document</h3><p>Document är ett objekt som "Äger" alla andra objekt, med det menas att utifall du vill komma åt andra objekt i DOM:en görs detta genom <code> document.method()</code>. </p><table class="table table-condensed"><tr><th>Metod</th><th>Förklaring</th></tr><tr><td colspan="3" class="table-divider">Hitta element</td></tr><tr><td><code>document.getElementById()</code></td><td>Hämtar ett element med hjälp av dess ID </td></tr><tr></tr><tr><td><code>document.getElementsByTagName()</code></td><td>Hämtar alla element med hjälp av dess tagnamn </td></tr><tr></tr><tr><td><code>document.getElementsByClassName()</code></td><td>Hämtar ett element med hjälp av dess klassnamn</td></tr></table><h3>Element</h3><p>När vi hämtar ett element ur DOM:en genom någon av de metoder som diskuterades ovan, så kan vi sedan läsa och skriva information till det elementet. Ett element är alltså bara ännu ett objekt med ett antal egenskaper och metoder. Med andra ord kan vi inte bara läsa ifrån DOM:en, utan vi kan även förändra den. Nedan ser du några exempel på vad vi kan göra med ett element</p><table class="table table-condensed"><tr><td colspan="3" class="table-divider">Antag att vi har ett element i variabeln elem</td></tr><tr><td><code>elem.innerHTML</code></td><td>Ändrar den inre HTML:en av ett element</td></tr><tr><td><code>elem.attribute</code></td><td>Ändrar ett elements attribut.</td></tr><tr><td><code> elem.style</code></td><td>Ett objekt som vi kan läsa/skriva css från/till</td></tr></table><h3>Exempel</h3><p>Låt oss se till ett par exempel på hur vi kan manipulera DOM:en.</p><div class="panel panel-default"><div class="panel-heading">Exempel på att gömma ett element.</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="secret"&gt; LYSSNA PÅ MIG! &lt;/p&gt; </code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var p = document.getElementById("secret");
p.style.display = "none";</code></pre></div></div></div></div><p>Vad vi gör ovan är alltså helt enkelt att vi först hämtar elementet med hjälp av dess ID. Sedan hämtar vi <code>style</code>-objektet på elementet. På <code>style</code>-elementet sätter vi egenskapen <code>display</code> till värdet <code>none</code>. JavaScriptkoden skulle kunna komprimeras till att skrivas på en enda rad, vet du hur?</p><div class="panel panel-default"><div class="panel-heading">Exempel på att hämta med tagnamn.</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt; A &lt;/p&gt;
&lt;p&gt; B &lt;/p&gt;
&lt;p&gt; C &lt;/p&gt;
&lt;p&gt; D &lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript"> var as = menu.getElementsByTagName('p');  
 as[0].innerHTML = "Ett";
 as[1].innerHTML = "Två";
 as[3].innerHTML = as[1].innerHTML;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Ett</p><p>Två</p><p>C</p><p>Två</p></div></div></div></div><p>Ok, nu kanske det krävs en liten förklaring. Om vi som i första exemplet hämtar med id då vet vi att vi endast får ett objekt tillbaka. I andra exemplet ovan ber vi om objekten med hjälp av tagnamnet och därför returneras dessa i en array. Med andra ord: när vi hämtar ett element genom ett ID kan vi alltid vara hundra på att det bara finns ett (eftersom ett ID endast får förekomma en gång i ett HTML-dokument). Men när vi söker element via tagnamn så kan vi omöjligen veta hur många instanser det finns av just den taggen. Således har man valt att låta <code>getElementsByTagName</code> returnera en array. Således är det även därför vi ovan använder bracket-notationen (<code>[x]</code>) för att arbeta med resultatet.</p><blockquote class="text-warning">Se till att du förstår varför outputen i exemplet ovan blir som den blir innan du går vidare</blockquote><h3>onload</h3><p>När vi skriver JavaScript som på något sätt interagerar med DOM:en, är det viktigt att vi är säkra på att DOM:en är redo (inladdad) innan vi börjar försöka nå den. Detta gör vi enkelt genom att använda oss av metoden <code>onload</code>.</p><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi använder onload.</div><div class="panel-body"><pre><code class="language-javascript">window.onload = function(){
  // do all fancy work here
}</code></pre></div></div><p>Varför gör vi alltså detta? Jo, om vi inte skulle göra det så finns alltså risken för att de element vi försöker komma åt inom funktionskroppen i ovan exempel ännu inte finns.</p><p>Ovan kan förstås lika gärna göras i två steg, genom att registrera en redan deklarerad funktion.</p><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi använder onload.</div><div class="panel-body"><pre><code class="language-javascript">// Declare the init function
var init = function(){
}
 
// Register it as a listener to the onload event
window.onload = init;</code></pre></div></div><p>Vad vi har gjort nu kallas mer generellt för att registrera en funktion (en <code>event handler</code>) till ett <code>event</code>. Mer om detta i avsnittet om events.</p><div class="page-header"><h2 href="#04-05-js-events" name="04-05-js-events" id="04-05-js-events">Event listeners</h2></div><p>Nästa ämne vi ska prata om är eventlyssnare. Något som finns i många programmeringsspråk och som ofta beteer sig liknande, om än med olika syntax. För att förstå event listeners, fundera över följande: hur vet vi att en användare har klickat på en knapp?</p><p>Mer generellt uttryckt: Event listeners hjälper oss att exekvera specifik kod vid en specifik händelse. Det kan tyckas trivialt. Men tänk på när vi skriver ett program. Om vi inte hade events skulle hela programmet endast kunna köras i ett svep (rufft uttryckt). Programmet börjar exekveras, och oavsett hur mycket klasser och funktioner vi använder så kommer programmet att köras ifrån början till slut. Med events så kan vi däremot registrera vad som kallas för <code>lyssnare</code>. Programmets exekvering "fryser" inte. Programmet stannar alltså inte när vi registrerar en event listener utan fortsätter exekvera som vanligt. När den händelse som eventlyssnaren lyssnar efter (exempelvis en knapptryckning) händer så exekveras koden lyssnaren pekar på. Detta kallas ofta för <a href="http://en.wikipedia.org/wiki/Event-driven_programming">event-driven programming</a>.</p><p>Vi ska i det här kapitlet prata om metoden <code>addEventListener()</code>, men för att enklare förstå hur de fungerar behöver vi först prata om vad det betyder att JavaScript har en <code>Asynkron Event Model</code>. Beakta följande kodexempel:</p><div class="panel panel-default"><div class="panel-heading">Exempel på asynkron exekvering i JavaScript</div><div class="panel-body"><pre><code class="language-javascript">console.log("a");
 
 
// setTimeout är en funktion som kör en annan
// funktion efter en given väntetid i millisekunder
 
setTimeout(function(){
  console.log("b");
}, 1000)
 
 
console.log("c");</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>a</p><p>c</p><p>b</p></div></div></div></div><p>Hur kan det komma sig att vi fick outputen i ovan ordning? Detta har alltså att göra med den asynkrona event modellen i JavaScript. Den funktion som körs av <code>setTimeout</code> körs inte förrän väntetiden på <code>1000 ms</code> har passerat. Men, eftersom JavaScript har asynkrona event, så registreras denna funktion som ett event. Således kommer programmet fortsätta att exekvera. När tiden sedan gått ut, och event-loopen är "ledig" så exekveras den givna funktionen.</p><p>Om <code>setTimeout</code> hade varit en synkron metod hade exekveringen avstannat ("fryst") vid anropet till <code>setTimeout</code>, och inte fortsatt förrän väntetiden passerat.</p><div class="panel panel-info"><div class="panel-heading">Kuriosa</div><div class="panel-body"><p>Även om vi hade satt timeout-tiden ovan till 0ms så hade vi fått samma output. Varför? Jo, för att även om väntetiden för <code>setTimeout</code> är 0 så registrerar den funktionen till event-loopen utan att exekvera den på en gång. Således kan den givna funktionen inte exekveras förrän nästa lediga "tick" i event-loopen.</p></div></div><p>Varför är detta då viktigt? Jo, detta gäller alltså även för när vi registrerar event-lyssnare.</p><h3>addEventListener</h3><p>Istället för att gräva ned oss i mer teori, låt oss kolla på ett exempel kring hur vi kan använda <a href="p Varf&#xF6;r &#xE4;r detta d&#xE5; viktigt? Jo, detta g&#xE4;ller allts&#xE5; &#xE4;ven f&#xF6;r n&#xE4;r vi registrerar event-lyssnare.">addEventListener</a>.</p><div class="panel panel-default"><div class="panel-heading">Exempel på asynkron exekvering i JavaScript</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="eventlistener-example-1"&gt;
  hello
&lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var tag = document.getElementById('eventlistener-example-1');
tag.addEventListener("click", function(){
  if(tag.innerHTML == "hello")
    tag.innerHTML = "world";
  else
    tag.innerHTML = "hello";
});</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat (prova att klicka på texten!)</div><div class="panel-body"><p id="eventlistener-example-1">hello</p></div></div></div></div><script>var tag = document.getElementById('eventlistener-example-1');
tag.addEventListener("click", function(){
  if(tag.innerHTML == "hello")
    tag.innerHTML = "world";
  else
    tag.innerHTML = "hello";
});</script><h4>Webbläsarstöd</h4><p>Nu är en bra tid att prata om webbläsarstöd. Äldre webbläsare stödjer inte metoden addEventListener, så om ovan exempel inte fungerar för dig så betyder det att din webbläsare är för gammal. Internet Explorer, tidigare och upp till, 8 har en alternativ implementation där metoden heter <code>attachEvent</code>. Så för att ovan exempel även ska fungera i Internet Explorer 8 behöver vi välja vilken metod vi använder berodende på vilken som finns. Läs mer om det i denna tråd på <a href="http://stackoverflow.com/questions/6927637/addeventlistener-in-internet-explorer">Stack Overflow</a>.</p><h4>Återanvändbara event handlers</h4><p>Den funktion som körs när ett event avfyras, kallas för en <code>event handler</code>. Självklart hade vi ju kunnat skriva denna event handler som en function declaration eller function expression istället för att bara skriva den inline. Detta är bra eftersom vi då kan återanvända beteende. Såsom nedan:</p><div class="panel panel-default"><div class="panel-heading">Exempel på användning av addEventListener</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="eventlistener-example-2"&gt;
  hello
&lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var onClick = function(element){
  if(element.target.innerHTML == "hello")
    element.target.innerHTML = "world";
  else
    element.target.innerHTML = "hello";
}
 
document.getElementById('eventlistener-example-2-1').addEventListener('click', onClick);
document.getElementById('eventlistener-example-2-2').addEventListener('click', onClick);</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat (prova att klicka på olika texterna!)</div><div class="panel-body"><p id="eventlistener-example-2-1">hello</p><p id="eventlistener-example-2-2">world</p></div></div></div></div><script>var onClick = function(element){
  if(element.target.innerHTML == "hello")
    element.target.innerHTML = "world";
  else
    element.target.innerHTML = "hello";
}
document.getElementById('eventlistener-example-2-1').addEventListener('click', onClick);
document.getElementById('eventlistener-example-2-2').addEventListener('click', onClick);</script><p>Styrkan i ovan exempel är ju alltså att vi nu kan återanvända vår eventhandler och attacha den till flera olika events. En annan lärdom vi kan dra av ovan exempel är att eventhandlers anropas med argument. Detta kan vi använda för att upptäcka vilket element som faktiskt har avfyrat eventet.</p><!-- TODO: Need to write more about event handler arguments--><!-- TODO: Need to write about event--><div class="page-header"><h2 href="#04-05-js-objekt" name="04-05-js-objekt" id="04-05-js-objekt">Objekt</h2></div><p>JavaScript är inte ett <a href="http://sv.wikipedia.org/wiki/Objektorienterad_programmering">objektorienterat</a> språk i den klassiska bemärkelsen utan istället ett <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototypbaserat</a> språk. Vad detta innebär kommer vi inte fokusera på i denna sektion, och därmed kommer vi inte syssla med instansiering. Istället kommer vi använda objekt som ett sätt att organisera vår kod.</p><h3>Vad är ett objekt?</h3><p>Om du programmerat i ett tidigare språk så kan du jämföra JavaScript-objekt med <code>map</code>'s eller <code>dictionary</code>'s. Om du inte har programmerat tidgare så kan du jämföra objekt med uppslagsverk. Va? Jo, precis så! Helt vanliga gamla bokuppslagsverk. Vänta nu? Va? Jo men tänk dig. Hur fungerar ett uppslagsverk. Om jag undrar vad ordet "katt" betyder så tar jag mitt fysiska uppslagsverk (objektet) och börjar leta efter uppslagsordet "katt" (nyckeln), och när jag väl hittat det så läser jag beskrivningen av vad en katt är (värdet).</p><p>Låt oss analysera de tre nyckelorden vi identifierat i ovan stycke.</p><dl class="dl-horizontal"><dt>Objekt</dt><dd>En datatyp som innehåller en kollektion av nycklar som pekar på värden (nyckel-värde-par)</dd><dt>Nyckel</dt><dd>En unik identifierare, såsom "namn", eller "nummer".</dd><dt>Värde</dt><dd>Ett värde kan vara av vilken annan datatyp som helst. Ett värde kan således vara 1 såväl som 32 såväl som "Kapten Haddock" såväl som ett annat objekt.</dd></dl><p>Innan vi snurrar vidare är det nog bäst att vi börjar undersöka syntaxen vi använder för att skapa objekt och således diskutera ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Object literals</div><div class="panel-body"><pre><code class="language-javascript">var haddock = {
  name : 'Kapten Haddock',
  beard: 'black as the night',
  rank: 1
}</code></pre><p>Nu har vi skapat ett objekt och lagrat det i variabeln <code>haddock</code>. Låt oss nu se hur vi kan interagera med objektet.</p><pre><code class="language-javascript">haddock.name;         // =&gt; "Haddock"
haddock.rank;         // =&gt; 1
haddock.beard;        // =&gt; "black as the night"
haddock.weapon;       // =&gt; undefined</code></pre><p>Vi kan nu alltså använda <em>punkt-notation</em> för att nå de värden som gömmer sig bakom ett objekts nycklar. Men faktum är att vi även kan nå värdena genom att använda samma notation vi använder för att nå värdena i en array. Enda skillnaden är att vi istället för att be om en arrays numeriska index ber vi om värdet bakom en viss nyckel. Låt oss se till ett exempel, och tänk på att det är exakt samma objekt som vi arbetar med i båda dessa två exempel.</p><pre><code class="language-javascript">haddock['name'];         // =&gt; 'Haddock'
haddock['rank'];         // =&gt; 1
haddock['beard'];        // =&gt; "black as the night"
haddock['vegetables'];   // =&gt; undefined</code></pre></div></div><div class="panel panel-warning"><div class="panel-heading">Överkurs</div><div class="panel-body"><p>Om vi jämför de två olika sätten att nå ett objekts värden märker vi snabbt att vi i det första exemplet skriver nyckelns namn rakt av, medan vi i det andra exemplet skriver nyckeln i formen av en sträng. Det betyder att vi skulle kunna byta ut denna <em>sträng</em> emot ett <em>uttryck</em>. Alltså en variabel, eller t.o.m. en funktion! Låt oss prova:</p><pre><code class="language-javascript">var prop = 'name';
haddock[prop];        // =&gt; 'Haddock'
prop = 'rank'
haddock[prop];        // =&gt; 1
prop = 'beard'
haddock[prop];        // =&gt; "black as the night"
prop = 'fruit'
haddock[prop];        // =&gt; undefined</code></pre><p>Beroende på vilket värde vi lägger i variabeln hämtar vi värdena vid olika nycklar. Men om det är så att vi inom klammrarna kan ha ett uttryck vilket som helst så skulle vi ju förstås kunna göra ännu galnare grejer.</p><pre><code class="language-javascript">haddock['na' + 'me'];     // =&gt; 'Haddock'
prop = 'na';
haddock[prop + 'na'];     // =&gt; 'Haddock'
 
// eller vad sägs om funktioner..
function getKey(){
  return 'name'
}
haddock[getKey()];        // =&gt; 'Haddock'</code></pre></div></div><h1 href="#05-00-oss-intro" name="05-00-oss-intro" id="05-00-oss-intro">Open source</h1><p class="lead">Mycket av världens mjukvara drivs av open source. Alltså mjukvara vars källkod är öppen för allmänheten. Men vad är egentligen open source? Hur kan vi använda det? Hur kan vi bidra?</p><div class="page-header"><h2 href="#05-01-oss-intro" name="05-01-oss-intro" id="05-01-oss-intro">Open Source</h2></div><p>Open-source, eller öppen källkod på svenska, är idéen om att lämna ut sin källkod till allmänheten så att vemsomhelst kan använda, modifiera eller bygga vidare på den. Idag är det nästan omöjligt att surfa omkring på internet utan att använda sådant som del- eller helvis står på axlarna av open-source.</p><p>Ett par exempel på lösningar som är drivna med öppen källkod är bloggmotorn <a href="http://sv.wikipedia.org/wiki/Wordpress">WordPress</a>, operativsystemet <a href="http://sv.wikipedia.org/wiki/Linux">Linux</a>, webbservern <a href="http://sv.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a> och databashanteraren <a href="http://sv.wikipedia.org/wiki/MySQL">MySQL</a>.</p><p>Om man ska diskutera de projekt som storskaligt verkligen haft influens på hur vi webbutvecklar är det nästan hädelse att inte nämna <a href="http://jquery.com">jQuery</a>. JavaScript-biblioteket med stort B, som hjälper oss att göra allt ifrån <a href="http://api.jquery.com/animate/">animation</a>, <a href="http://api.jquery.com/each/">iteration</a>, <a href="http://api.jquery.com/jQuery.post/">ajax</a> och att fånga <a href="http://api.jquery.com/category/events/keyboard-events/">tangentbordstryckningar</a>.</p><h1 href="#06-00-jquery-intro" name="06-00-jquery-intro" id="06-00-jquery-intro">jQuery</h1><p class="lead">Att koda JavaScript är en fröjd i många avseenden, men framförallt för att språket genomsyras av en fantastisk open-source-kultur där en multitud av problem redan är lösta. I den här sektionen pratar vi lite om open-source och js-bibliotek generellt. Men framförallt ska vi lära oss att skaka fram webbläsareffekter som en annan jQuery-Houdini. <code>slideIn(); fadeOut();</code></p><div class="page-header"><h2 href="#06-01-jquery-intro" name="06-01-jquery-intro" id="06-01-jquery-intro">jQuery snabbstart</h2></div><p><a href="http://jquery.com/">jQuery</a> är verkligen JavaScript-biblioteket med stort B. Biblioteket hjälper oss att göra allt ifrån <a href="http://api.jquery.com/animate/">animation</a>, <a href="http://api.jquery.com/each/">iteration</a>, till att bygga <a href="http://en.wikipedia.org/wiki/Single-page_application">one-pagers</a> som använder <a href="http://api.jquery.com/jQuery.post/">ajax</a> för att ladda in data, eller att bygga tangentbordsvänliga applikationer genom att fånga <a href="http://api.jquery.com/category/events/keyboard-events/">tangentbordstryckningar</a>. I detta kapitel ska vi dyka rakt in i och börja använda jQuery, utan att fundera särskilt mycket över varför saker fungerar som de fungerar.</p><h3>jQuery är ett bibliotek</h3><p>jQuery är ju alltså ett JavaScript-bibliotek. Ett bibliotek kan, oavsett språk, ses som någonting som utökar det språk vi skriver i för att underlätta vissa aktiviteter.</p><p>Säg att vi t.ex. ofta utför aktivitet <code>A</code>, <code>B</code> och <code>C</code> i följd. Någonting ett bibliotek ofta gör är då att t.ex. ge oss ett nytt namn &mdash; säg <code>Z</code>, vilket vi kan använda för att utföra alla tre aktiviteter samtidigt.</p><p>Ett bibliotek består då alltså av kod, i detta fall kod skriven i JavaScript. Så, för att kunna använda jQuery behöver vi "koppla in" jQuery i våra egna dokument. Låt oss uttrycka oss mer specifikt. Hela jQuery-biblioteket behöver laddas in på varje .html-sida som ska använda jQuery, innan vi försöker använda det.</p><h3>Ladda in jQuery</h3><p>Att ladda in jQuery är enkelt. Hela biblioteket får plats i fil. Vi har två alternativ. Antingen kan vi...</p><ol><li>Kopiera hela biblioteket, eller <a href="http://jquery.com/download/">ladda ned filen</a>, och spara filen i mappen som innehåller vår webbsida, eller..</li><li>Låta våra html-sidor ladda ned jQuery via internet ifrån vad som kallas för en <a href="http://en.wikipedia.org/wiki/Content_delivery_network">CDN</a>.</li></ol><p>För enkelhetens skull kommer vi att arbeta med det senare alternativet. Detta gör vi helt enkelt genom att placera följande script-element i vår .html-fil:</p><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre><code class="language-markup">&lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt;</code></pre></div></div><h3>Ladda in en fil som använder jQuery</h3><p>Så, nu har vi jQuery tillgängligt i vårt dokument. Men efter detta behöver vi ladda in en till JavaScript-fil där vi faktiskt <em>använder</em> jQuery. Låt oss alltså skapa en till .js-fil och ladda in den direkt efter som så:</p><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre><code class="language-markup">&lt;script src="main.js"&gt;&lt;/script&gt;</code></pre></div></div><h3>Använda jQuery</h3><p>Låt oss nu faktiskt använda jQuery till att göra någonting. Vi fortsätter alltså skriva kod i filen <code>main.js</code>. Följande kod kommer att vänta tills <a href="http://sv.wikipedia.org/wiki/Document_Object_Model">DOM</a>:en (alltså HTML-trädet) har laddats in av webbläsaren, och sedan "poppa" up en alert-ruta. Prova att klistra in koden i <code>main.js</code> och ladda om din html-sida.</p><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">$(function(){
  alert("Hello from jQuery");
});</code></pre></div></div><p>Tada!! Vi har nu använt oss av biblioteket jQuery. Låt oss prova någonting annat. Följande kod identifierar alla länkar (<code>&lt;a&gt;</code>-taggar) på din html-sida. Inaktiverar deras vanliga funktionalitet, och gör istället så att de klistrar in bilder på en massa fantastiska katter varje gång du klickar. Tänk på att du alltså behöver lägga in länkar i din html-sida för att nedan kod ska ha någon effekt. Annars har vi ju inga länkar att klicka på.</p><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">$(function(){
  var randomNum = function(){
    return Math.floor(Math.random()*101);
  }
 
  $('a').click(function(){
    e.preventDefault();
    var size = 75 + randomNum(),
    x = randomNum() + '%',
    y = randomNum() + '%',
 
    $img = $('&lt;img/&gt;');
    $img.attr('src', 'http://placekitten.com/'+size+'/'+size);
    $img.css({
      'position': 'fixed',
      'left'    : x,
      'top'     : y
    });
 
    $('body').append($img);
  });
});</code></pre></div></div><p>Om du inte själv har valt att implementera den fantastiska jQuery-koden ovan så kan du få en sneak-peak på vilken underbar värld som väntar genom att prova exemplet nedan!</p><div class="panel panel-default"><div class="panel-heading">Resultat (prova!)</div><div class="panel-body"><p><a class="btn btn-large btn-success jquery-intro-example-1">All your base!</a></p><p><a class="btn btn-large btn-danger jquery-intro-example-2">Reset (you will need it I promise);</a></p><script>$(function(){
 (function(){
   $('.jquery-intro-example-2').click(function(e){
     $('.jquery-intro-example-1-output').remove();
   });
   $('.jquery-intro-example-1').click(function(e){
     e.preventDefault();
     var randomNum = function(){
       return Math.floor(Math.random()*101);
     }
 
     var size = 75 + randomNum(),
     x = randomNum() + '%',
     y = randomNum() + '%',
 
     $img = $('<img/>');
     $img.attr('src', 'http://placekitten.com/'+size+'/'+size);
     $img.addClass('jquery-intro-example-1-output');
     $img.css({
       'position': 'fixed',
       'left'    : x,
       'top'     : y
     });
     
     $('body').append($img);
   });
 })();
});</script></div></div><p>Svårare än så är det inte! Så, när du använder jQuery behöver du helt enkelt komma ihåg tre saker.</p><ol><li>Se till att du laddar in jQuery-biblioteket.</li><li>Se till att din kod som använder jQuery laddas in efter själva biblioteket.</li><li>Se till att den kod som använder jQuery ligger inom <code class="language-javascript">$(document).ready(function(){ /* din kod här */ });</code>.</li></ol><p>Sedan är det bara att tuta och köra!</p><div class="panel panel-info"><div class="panel-heading">Tips!</div><div class="panel-body"><p>Ett kortare sätt att skriva..</p><pre><code class="language-javascript">$(document).ready(function(){
  /* din kod här */
});</code></pre><p>...är att skriva så här...</p><pre><code class="language-javascript">$(function(){
  // din kod här... 
});</code></pre><p>Båda sätten ger samma resultat.</p></div></div><div class="page-header"><h2 href="#06-02-jquery-documentready" name="06-02-jquery-documentready" id="06-02-jquery-documentready">$(document).ready</h2></div><p>I vår första djupdykning in i jQuery pratade vi kort om att det är viktigt att vänta tills hela DOM:en är inladdad innan vi börjar exekvera vår jQuery-beroende kod. I det här kapitlet kollar vi närmare på hur just <code>.ready()</code>-funktionen fungerar. Detta kapitel hjälper dig att skapa en djupare förståelse för både jQuery såväl som JavaScript.</p><h3>När dokumentet är redo för manipulation</h3><p>Denna mystiska ovan nämnda metod vid namn <code>.ready()</code> är en metod vi använder för att kunna vänta med att exekvera jQuery-kod tills webbläsaren har hunnit ladda in ("ned") hela sidan. Låt oss först se till ett exempel och sen diskutera det:</p><div class="panel panel-default"><div class="panel-heading">Att säga åt jQuery att vänta tills DOM:en är inläst</div><div class="panel-body"><pre><code class="language-javascript">$(document).ready(function(){
  alert("Hello world from jQuery");
});</code></pre></div></div><p>Ovan exempel använder jQuery för att avvakta tills webbläsaren har laddat in hela sidan. Sedan använder vi helt vanlig JavaScript för att poppa up en alert-ruta med meddelandet "Hello world...". Låt oss dissekera ovan kod, rad för rad och del för del, för att faktiskt förstå vad det är som händer.</p><h4>$() är syntaktiskt socker för jQuery()</h4><p>Först ut är detta mystiska dollartecken. Förklaringen till vad detta <em>är</em>, är egentligen ganska enkel. Förklaringen till varför vi <em>använder</em> tecknet inte lika. Men låt oss först diskutera vad det är. <code>$</code>-tecknet är egentligen ingenting annat än <a href="http://sv.wikipedia.org/wiki/Syntaktiskt_socker">syntaktiskt socker</a>. Alltså ett annat sätt att skriva någonting. Detta någonting är jQuery's huvudmetod med samma namn, alltså <code>jQuery</code>. Så, när vi med andra ord säger <code class="language-javascript">$(document)</code> är det <em>exakt samma sak</em> som när vi säger <code class="language-javascript">jQuery(document)</code>. Det förstnämnda är helt enkelt bara ett kortare sätt att uttrycka det på för att vi som programmerare ska slippa skriva så mycket.</p><h4>Variabeln document är dokumentets rot</h4><p><code>document</code> är helt enkelt en <em>variabel</em>. Men notera här alltså att vi säger att document är en variabel, vi säger inte att det är ett keyword. Varför är det viktigt att tänka på? Jo, <code>var</code> är ett keyword, en <a href="http://en.wikipedia.org/wiki/Language_construct">language construct</a> som alltid finns i JavaScript oavsett vart vi kör språket. Variabeln window är däremot ett koncept som är uppfunnit sonika för browsers. Om vi kör en JavaScript-interpretator i en <a href="http://en.wikipedia.org/wiki/Bash_(Unix_shell)">terminal</a> (alltså inte en browser) så existerar inte variabeln <code>document</code>. I browsern däremot, för att överhuvudtaget kunna manipulera en webbsida, behöver vi något sätt att genom javascript komma åt noderna (elementen) i vårt HTML-dokument. Således är <code>document</code>, löst uttryckt, vår "entry-point" in till noderna i html-dokumentet. I variabeln <code>document</code> hittar vi elementet <code>&lt;html&gt;</code> och som barn till det elementet hittar vi förstås resten av noderna. För att sammanfatta så är alltså <code>document</code> den variabel som innehåller hela vårt html-dokument och således den variabel vi behöver interagera med för att manipulera vårt dokument.</p><h4>$(document) eller jQuery(document)</h4><p>Nu vet vi alltså att <code>$()</code> är en korthandssyntax, och således samma sak som att anropa <code>jQuery()</code>. Men vad gör då denna metod? Jo, metoden returnerar ett jQuery-objekt som innehåller det vi har skickat in till den. Vi kan alltså se det som att jQuery <em>dekorerar</em> det vi har skickat in med alla dessa fantastiska jQuery-metoder. Låt oss exemplifiera.</p><pre><code class="language-javascript">// Dekorerar alla länkar med jquery
// Sparar referensen i variabeln link
var link = $('a');</code></pre><p>Vi använder alltså denna "jquery-dekorerade version" av ett html-element för att anropa de fantastiska metoder jquery utökar våra element med. Låt oss exemplifiera.</p><pre><code class="language-javascript">// Fade:a ut alla länkar
$('a').fadeOut();
 
// Samma sak i två steg
var link = $('a');
link.fadeOut();</code></pre><p>Det kan snabbt bli virrigt gällande vilka variabler som är jquery-dekorerade och vilka som inte är det. <a href="http://en.wikipedia.org/wiki/Coding_conventions">Konventionen</a> brukar således vara döpa sina variabler med ett initial <code>$</code>-tecken. Som så:</p><pre><code class="language-javascript">// Konventionen är att döpa jquery variabler med ett intialt $-tecken
var $link = $('a');</code></pre><p>För att återgå till det här med <code class="language-javascript">$(document)</code>. Vad betyder det då alltså att skicka in dokumentet till jquerys dekorationsmetod? Jo att vi nu kan anropa alla de fantastiska metoderna jquery erbjuder på vår rotnod. Det vill säga hela dokumentet. Att dekorera dokumentet med jquery har egentligen exakt samma effekt som att dekorera ett enskilt element (t.ex. en länk).</p><h4>För att veta när dokumentet är redo använder vi .ready()</h4><p>Precis som rubriken säger så använder vi metoden för att helt enkelt veta när dokumentet (DOM:en) är färdigladdat. Tänk efter. Eftersom vi använder jQuery-metoden för att dekorera element i vårt dokument. Så är det viktigt att alla element är "konstruerade" innan vi försöker komma åt dem. Hur ska vi kunna hitta alla länkar om vi inte är säker på att webbläsaren har hunnit läsa in alla länkar?</p><p>Vi kan använda <a href="http://learn.jquery.com/using-jquery-core/document-ready/">.ready()</a>-metoden, men vi kan också använda <a href="http://api.jquery.com/load/">.load()</a>-metoden. Den första nöjer sig med att <a href="http://sv.wikipedia.org/wiki/Document_Object_Model">DOM</a>:en (vilket kan ses som dokumentets struktur) har laddat. Den senare väntar på att alla resurser såsom bilder o.s.v. har laddat.</p><h4>Funktionen skickad till ready körs när dokumentet är redo</h4><p>Så vad ska vi skicka som argument till denna funktion? Jo, en till funktion! Va? Vääänta nu. En funktion som tar en funktion som argument? Det låter ju helknäppt. Men det är faktiskt inte så knäppt. Faktum är att mycket kod vi skriver i JavaScript går ut på att just skicka funktioner till funktioner. För att kunna skapa <a href="http://en.wikipedia.org/wiki/Callback_(computer_programming)">"callbacks"</a>. Den funktion vi skickar till <code>.ready()</code>-funktionen kan ses som ett callback som körs när dokumentet har laddat.</p><p>Tänk dig.. vi anropar jquery ready-metoden, och säger "Hej, nu vill jag att du säger till mig när sidans DOM har laddat klart". Sedan skickar vi in en funktion till ready-metoden och då är det som att vi säger "..och när sidans DOM har laddat klart, då vill jag att du utför allt som står i den här andra funktionen". Inga konstigheter!</p><h4>Allt i ett svep</h4><p>Så, låt oss repetera den kod vi pratar om i helhet.</p><pre class="line-numbers"><code class="language-javascript">$(document).ready(function(){
  alert("Hello world from jQuery");
});</code></pre><p>Låt oss beskriva koden i ord, rad för rad.</p><ol><li>Skapa ett <code>jQuery</code>-objekt av innehållet i variabeln <code>document</code>. Anropa sedan funktionen <code>ready()</code> på det jquery-dekorerade dokumentet. Skicka en <em>anonym funktion</em> som argument.</li><li>Låt den anonyma funktionen innehålla en enda rad. Denna rad anropar JavaScript-funktionen <code>alert()</code>, med strängen "Hello world.." som argument, och kommer således att visa göra så att alert-ruta "poppar upp" med texten "Hello world..".</li><li>Stäng den anonyma funktionen med <code>}</code>. Stäng sedan funktionsanropet med <code>)</code>. Terminera raden med <code>;</code>.</li></ol><div class="page-header"><h2 href="#06-03-jquery-jqueryobjects" name="06-03-jquery-jqueryobjects" id="06-03-jquery-jqueryobjects">Objektet jQuery</h2></div><p>I JavaScript-kapitlet använde vi rå JavaScript för att hämta och manipulera objekt i DOM:en. Vi har alltså direkt interagerat med DOM:ens API. Eftersom det lätt blir frustrerande att t.ex. skriva <code>document.getElementsByTagName</code> gång på gång så finns det ramverk som kan hjälpa oss. Därför ska vi nu istället göra detta med jQuery, och därför behöver vi prata om det mest grundläggande objektet i jQuery, själva jQuery-objektet. Således även reflektera över skillnaden mellan att arbeta med jQuery-objekt och <code>HTMLElement</code>-objekt.</p><h3>Varför?</h3><p>När vi hämtar element ifrån DOM:en m.h.a JavaScript får vi alltså tillbaka just DOM-element. Men när vi arbetar emot "råa" DOM-element blir många saker, som tidigare nämnt, ofta "tjatiga" och onödigt komplicerade. Beakta nedan exempel:</p><div class="panel panel-default"><div class="panel-heading">Hämta elementet <code>&lt;body&gt;</code></div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">Med JavaScript</div><div class="panel-body"><pre><code class="language-javascript">document.getElementsByTagName('body');</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('body')[0];</code></pre></div></div></div></div><p>Uppenbart kräver jQuery-exempelet ovan att vi skriver markant mindre kod. Onödigt, kanske du tänker nu. Visst, vinsten i ovan exempel är inte massiv. Men låt oss istället se till ett mer avancerat exempel. Anta att vi skulle vilja ta bort alla <code>&lt;p&gt;</code>-element ur ett dokument. Nedan ser du hur vi först skulle kunna lösa det med JavaScript och sedan med jQuery.</p><div class="panel panel-default"><div class="panel-heading">Ta bort alla <code>&lt;p&gt;</code>-element</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">Med JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var all = document.getElementsByTagName('p');
for(i=all.length-1; i>=0; i--){
  all[i].parentNode.removeChild(all[i]);
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('p').remove();</code></pre></div></div></div></div><p>Förhoppningsvis ser du nu styrkan! jQuery försökt att ta hand om den del vanligt återkommande problem och således försökt erbjuda oss utvecklare lite mindre huvudvärk. Nu kanske du redan fått huvudvärk flera gånger och känner den komma igen av att du behöver lära dig någonting nytt &mdash; men lugn! När du väl fått kläm på syntaxen kommer jQuery hjälpa dig ofantligt, och förhoppningsvis kommer du vara arg på att vi försökte lära dig JavaScript först.</p><blockquote>Förutom att jQuery gör det lättare för oss att utföra omständiga DOM-operationer gör den också att vi får mer webbläsarkompatibel kod, eftersom jQuery bygger på mycket "best practices".</blockquote><h3>Vad är det?</h3><p>jQuery-objektet fungerar helt enkelt så att vi "wrappar" (omsluter/dekorerar) ett helt vanligt <code>HTMLElement</code> med jQuery. När vi har gjort det har vi helt plötsligt ett objekt som dels innehåller en referens till detta helt vanliga <code>HTMLElement</code> men även en massa smidiga hjälpmetoder som hjälper oss att interagera med detta <code>HTMLElement</code>.</p><p>jQuery-objekt kan göra mycket fler saker än att hämta och manipulera element men nu ska vi fokusera på att det kan göra just det sistnämnda &mdash; alltså hämta element, och sedan manipulera dem. Låt oss se till det tidigare diskuterade exempelet som tog bort alla <code>&lt;p&gt;</code>-element ur ett dokument.</p><div class="panel panel-default"><div class="panel-heading">Ta bort alla &lt;p&gt;-element med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('p').remove();</code></pre></div></div><p>Det viktigaste vi måste förstå med ovan exempel, är att jQuery opererar på kollektioner av element och inte på enstaka element. Nu är det ju förstås så att det är fullt möjligt att vår kollektion endast innehåller ett element, men det är ändock en kollektion. För att dra en parallell så kan du tänka på hur JavaScript-metoden <code>document.getElementsByTagName()</code> fungerar. Namnet på metoden är pluraliserad eftersom även den returnerar en kollektion av <code>HTMLElement</code>. Detta alltså till skillnad ifrån <code>document.getElementById</code> som i alla fall returnerar max ett <code>HTMLElement</code>.</p><blockquote>jQuery opererar på kollektioner av element.</blockquote><p>Men vad betyder då detta i praktiken? Jo, det betyder alltså att jQuery inte bryr sig om huruvida vi hittade ett eller flera element, när vi i ovan exempel anropar metoden <code>.remove()</code> så tar den alltså bort alla element i hela den kollektion den hade hittat. Låt oss se till ytterligare ett exempel för att illustrera detta:</p><div class="panel panel-default"><div class="panel-heading">Tänk på att jQuery alltid arbetar på kollektioner av element</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt; hello &lt;/p&gt;
&lt;p&gt; world &lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">jQuery</div><div class="panel-body"><pre class="line-numbers"><code class="language-javascript">$('p')[0].innerHTML;    // => "hello"
$('p')[1].innerHTML;    // => "world"
$('p').text();          // => "hello world"</code></pre></div></div></div></div><p>Vi kan hantera jQuery-objektet som en array. På rad 1 och 2 i ovan exempel gör vi just det. När vi använder klammerparantesnotationen (<code>[i]</code>) och ger ett index, så hämtar vi alltså det <code>HTMLElement</code> som gömmer sig under det indexet. När vi sedan anropar <code>innerHTML</code> får vi ut den text som finns i just det <code>HTMLElementet</code>. När vi däremot på rad 3 anropar <code>text()</code>-metoden (som alltså är en jQuery-specifik metod) så opererar vi alltså på kollektionen av alla träffade element. Anledningen till att vi inte använder <code>text()</code>-metoden på rad 1 och 2 är alltså för att den metoden är specifik för jQuery. Eftersom vi på rad 1 och 2 redan plockat ut ett <code>HTMLElement</code> ur jQuery-objektet så har vi alltså inte längre tillgång till jQuery's metoder. Vice versa gäller alltså på rad 3. Eftersom vi inte plockat ut något <code>HTMLElement</code> ur jQuery-kollektionen kan vi inte använda "vanliga" <code>HTMLElement</code>-metoder (eftersom det är ett <code>jQuery object</code>) utan måste istället använda jQuery-specifika metoder. Vill vi använda de vanliga <code>HTMLElement</code>-metoderna behöver vi plocka ut ett specifikt element ur kollektionen.</p><h3>Hämta element</h3><p>Låt oss nu prata om vi hämtar element-kollektioner m.h.a. jQuery. Att hämta element med jQuery är egentligen mycket enkelt. Vi skriver helt enkelt <code>$(x)</code> där <code>x</code> ersätts med vilken css-selektor som helst. Med andra ord kan vi återanvända alla våra css-kunskaper nu när vi dyker in i jQuery.</p><p>Utan att snöa ner oss i svårare selektorer så kommer du förhoppningsvis ihåg de enklaste. De vanligaste css-selektorerna är:<dl class="dl-horizontal"><dt><code> x</code></dt><dd>Element av typ x</dd><dt><code>#x</code></dt><dd>Element med id x</dd><dt><code>.x</code></dt><dd>Element med klassen x</dd></dl></p><blockquote>Om du behöver läsa på om css-selektorer, läs mer i css-kapitlet!</blockquote><p>Ok, men nu var det ett väldigt generellt prat här. Låt oss istället se till några exempel där vi faktiskt använder dessa selektorer.</p><div class="panel panel-default"><div class="panel-heading">Hämta element av typ x</div><div class="panel-body"><pre><code class="language-markup">&lt;div&gt; Anta &lt;/div&gt;
&lt;div&gt; att vi har &lt;/div&gt;
&lt;div&gt; ett par div:ar &lt;/div&gt;</code></pre><pre><code class="language-javascript">// Då väljer vi alla så här:
var allaDivar = $('div');</code></pre></div></div><p>Ovan hämtade vi alltså element baserat på deras <code>tagName</code>. Låt oss nu istället hämta alla element, oavsett typ, som har en viss <code>class</code>.</p><div class="panel panel-default"><div class="panel-heading">Hämta element med klassnamn</div><div class="panel-body"><pre><code class="language-markup">&lt;div class="dog"&gt; Woof! &lt;/div&gt;
&lt;div class="cat"&gt; Mjau! &lt;/div&gt;
&lt;div class="dog"&gt; Bark! &lt;/div&gt;</code></pre><pre><code class="language-javascript"> // Använd klass-selektorn för att hämta alla element med en viss klass
 var dogs = $(".dog");
 
 // För att illustrara att det verkligen fungerar
 dogs.text();    // => "Woof! Bark!"</code></pre></div></div><p>Busenkelt! Du börjar se mönstret? Låt oss nu istället prova en sista gång genom att hämta alla element med ett visst <code>ID</code>.</p><div class="panel panel-default"><div class="panel-heading">Hämta element med ID</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="super-woman"&gt;Kryptonite!&lt;/p&gt;
&lt;p id="cat-woman"&gt;In your house eating your cat food!&lt;/p&gt;
&lt;p id="modesty-blaise"&gt;Secret agent&lt;/p&gt;</code></pre><pre><code class="language-javascript">// Vi använder css-selektorn för ID
var hero = $('#super-woman');
 
// Och har nu valt rätt element
hero.text();   // => "Kryptonite!"</code></pre></div></div><div class="page-header"><h2 href="#06-04-jquery-modify-elements" name="06-04-jquery-modify-elements" id="06-04-jquery-modify-elements">Modifiera element</h2></div><p>När vi väl lärt oss att välja element m.h.a. jQuery är det busenkelt att börja modifiera dessa. jQuery-objektet exponerar oss en mängd behändiga funktioner och egenskaper vi kan använda för att modifiera kollektionen av element som gömmer sig under objektet. I detta kapitel kommer vi att prata om några av de vanligaste.</p><h3>html()</h3><p>Metoden <code>html()</code> kan ses som jQuery's motsvarighet till JavaScript's <code>innerHTML</code>. Lagom straight forward så hämtar den eller sätter helt enkelt elements <code>innerHTML</code>.</p><h4>Exempel</h4><div class="panel panel-default"><div class="panel-heading">jQuery-metoden html()</div><div class="panel-body"><p>Om vi har följande html..<pre><code class="language-markup">&lt;p&gt;
  &lt;span&gt;En katt&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;satt i en hatt&lt;/p&gt;</code></pre></p><p>Kan vi läsa första paragrafen genom att säga...<pre><code class="language-javascript">$('p').html();         // => "&lt;span&gt;En katt&lt;/span&gt;"</code></pre></p><p>Men vi kan även modifiera den genom att säga...<pre><code class="language-javascript">$('p').html('En hund') // => Ändrar ALLA p-elements inre html till "En hund"</code></pre></p><p>Vilket förändrar vår html så att vi nu har...<pre><code class="language-markup">&lt;p&gt;En hund&lt;/p&gt;
&lt;p&gt;En hund&lt;/p&gt;</code></pre></p><p>Notera alltså att vi "blev av" med <code>&lt;span&gt;</code>-elementet. Samt att <b>båda</b> <code>&lt;p&gt;</code>-elementens inre html rensades.</p></div></div><p>Men vänta nu, vad hände nu? Om du var uppmärksam så märkte du att när vi använde metoden <code>html()</code> för att <b>läsa</b> ifrån en element-kollektion så fick vi endast värdet ifrån det första elementet i kollektionen. Men när vi däremot använda <code>html()</code>-funktionen för att <b>skriva</b> så opererade vi på alla element i objekt-kollektionen. Vad händer nu egentligen?</p><blockquote class="text-warning">Alla metoder på jQuery-objektet arbetar <u>inte alltid</u> på alla element i kollektionen.</blockquote><h3>Vilka metoder opererar över hela kollektionen?</h3><p>Oavsett vilket jQuery-metod vi använder är det alltså alltid viktigt att vara medveten om huruvida den arbetar på hela kollektionen eller ett specifikt element. En tumregel vi kan använda är att många av metoderna <b>läser ifrån det första</b> elementet i kollektionen och <b>skriver till alla</b> i kollektionen. Anropar vi alltså <code>html()</code> för att <b>läsa</b> kommer vi bara att få all inre html för det första elementet, medan om vi använder metoden till att skriva <code>html('something')</code> kommer vi förändra <code>innerHTML</code> för alla element i kollektionen.</p><blockquote class="info">En bra tumregel är att många jQuery-metoder läser ifrån första elementet i en objekt-kollektion, och skriver till alla.</blockquote><h3>text()</h3><p>Metoden <code>text()</code> påminner mycket om metoden <code>html()</code> förutom att den fantastiskt nog ger oss innehållet i det första elementet i en element-kollektion utan html. Vi får alltså allt som webbläsaren faktiskt uppfattat som text, utan all störande html. Detta är en mycket användbar metod! Vi kan förstås, precis som med metoden <code>html()</code> använda den för att även skriva text till alla element i en kollektion. Låt oss se till några exempel:</p><h4>Exempel</h4><div class="panel panel-default"><div class="panel-heading">jQuery-metoden html()</div><div class="panel-body"><p>Om vi har följande html..<pre><code class="language-markup">&lt;p&gt;
  En liten men 
  &lt;span&gt;mästerlig&lt;/span&gt;
  katt, satt en 
  &lt;span&gt;solig dag &lt;/span&gt;
  och beundrade en hatt.
&lt;/p&gt;</code></pre></p><p>Och sedan hämtar <code>&lt;p&gt;</code>-elementets text så här...<pre><code class="language-javascript">$('p').text();   // Hämtar all text i elementet fritt ifrån alla html-element</code></pre></p><p>Så får vi...<pre><code class="language-javascript">"En liten men mästerlig katt, satt en solig dag och beundrade en hatt."</code></pre></p><p>Vilket ju är fantastiskt, för om vi istället hade använt metoden <code>html()</code> eller JavaScript's egna <code>innerHTML</code> hade vi istället fått...<pre><code class="language-javascript">"En liten men &lt;span&gt;mästerlig&lt;/span&gt; katt, satt en &lt;span&gt;solig dag &lt;/span&gt; och beundrade en hatt."</code></pre></p><p>Vilket förstås skulle vara mycket jobbigt att arbeta med om det skulle vara så att vi faktiskt bara vill åt texten, oavsett dess inre elementstruktur.</p></div></div><h3>attr() &amp; prop()</h3><p>Låt oss nu prata om två metoder som till synes verkar likna varandra. Metoden <code>attr()</code> hämtar och sätter <code>attribut</code> (<code>attributes</code>), medan metoden <code>prop</code> hämtar och sätter <code>egenskaper</code> (<code>properties</code>). På samma sätt som <code>text()</code> och <code>html()</code> hämtar båda metoderna ifrån det första elementet, och skriver till alla i en kollektion. Men för att förstå skillnaderna mellan de två metoderna <code>attr()</code> och <code>prop()</code> behöver vi först förstå skillnaden mellan <code>attribut</code> och <code>egenskaper</code>.</p><h4>Attribut</h4><p>När vi pratar om attribut så pratar vi attribut på html-element. Exempel på attribut är alltså <code>id</code>, <code>class</code>, <code>name</code> och <code>name</code>, för att nämna några. Med andra ord, attribut är sådant som vi "tilldelar" ett element i vår html. Självklart kan vi både hämta och sätta attribut via JavaScript, men för att förstå skillnaden mellan attribut och egenskaper är det lättast att tänka på attribut som det som vi sätter i html. Nedan följer ett exempel på ett html-element med ett antal attribut.<div class="panel panel-default"><div class="panel-heading">Att läsa ett elements attribut</div><div class="panel-body"><p>Om vi har ett element med ett antal attribut...</p><pre><code class="language-markup">&lt;p class="quote" id="welcome"&gt;
  What a wonderful world
&lt;/p&gt;</code></pre><p>Så kan vi förstås läsa attributen med JavaScript som så...</p><pre><code class="language-javascript">document.getElementsByTagName('p')[0].getAttribute('class');
// => "quote"
 
document.getElementsByTagName('p')[0].getAttribute('id');
// => "welcome"</code></pre><p>Och förstås med jQuery som så...</p><pre><code class="language-javascript">$('p').attr('class');  // => "quote"
$('p').attr('id');     // => "welcome"</code></pre></div></div></p><h4>Egenskaper</h4><p>Egenskaper å andra sidan, refererar till egenskaper på ett <code>HTMLElement</code>-objekt när den hanteras i JavaScript. Med andra ord (löst uttryckt) publika instansvariabler på JavaScript-representationen av samma element. Vad skulle då egenskaper kunna vara för någonting?<div class="panel panel-default"><div class="panel-heading">Att läsa ett elements egenskaper</div><div class="panel-body"><p>Anta att vi har ett <code>&lt;p&gt;</code>-element på sidan..</p><pre><code class="language-javascript">var p = document.getElementsByTagName('p')[0];
var i = document.getElementsByTagName('input')[0];
 
p.tagName;  // => "P"
i.tagName;  // => "INPUT"</code></pre><p>Således kan vi förstås göra samma sak genom jQuery...</p><pre><code class="language-javascript">$('p').prop('tagName');       // => "P"
$('input').prop('tagName');   // => "INPUT"</code></pre></div></div></p><h4>Undantag</h4><p>Av historiska skäl och förändringar över tid så beteer sig ovan metoder, i tidigare versioner av jQuery, tyvärr inte alltid såsom man kan tänka sig. Du kan läsa mer om det i jQuery-dokumentationen för<a href="http://api.jquery.com/prop/">prop</a> eller<a href="http://api.jquery.com/attr/">attr</a> eller helt enkelt på följande tråd på <a href="http://stackoverflow.com/questions/5874652/prop-vs-attr">StackOverflow</a>.</p><div class="page-header"><h2 href="#06-05-jquery-event-listeners" name="06-05-jquery-event-listeners" id="06-05-jquery-event-listeners">Event listeners i jQuery</h2></div><p>En av styrkorna med jQuery är att vi kan binda event-lyssnare till flera element samtidigt. Jämför detta med att behöva iterera över en array med element, plocka ut ett för ett och applicera samma lyssnare. Markant enklare att göra det på alla samtidigt!</p><p>jQuery har några generella metoder för att applicera event-lyssnare (som med fördel kan jämföras med JavaScripts <code>addEventListener()</code>). Men jQuery har även några specifika för vanligt förekommande events som <code>click</code> och <code>hover</code>. Låt oss kolla på ett exempel, och kom ihåg att jQuery arbetar på kollektioner av element, alltså flera stycken samtidigt.</p><div class="panel panel-default"><div class="panel-heading">Exempel att applicera lyssnare på alla divar samtidigt</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;div&gt;Oh no no no...&lt;/div&gt;
&lt;div&gt;Please do not click me, oh no no, please...&lt;/div&gt;
&lt;div&gt;I don't want to fade, please...&lt;/div&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('div').click(function(){
  $(this).fadeOut();
});</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><style>.jquery-events-example-1{
  width:100%; min-height:50px; background:rgb(200,200,200); margin:6px;
  padding:10px; text-align:center; font-size:20px;
}</style><div class="jquery-events-example-1">Oh no no no...</div><div class="jquery-events-example-1">Please do not click me, oh no no, please...</div><div class="jquery-events-example-1">I don't want to fade, please...</div><script>$('.jquery-events-example-1').click(function(){
  $(this).fadeOut();
});</script></div></div></div></div><p>Om du försöker bygga ovan exempel med ren JavaScript kommer du snabbt märka varför det gör livet så hiskelens mycket enklare att arbeta med ett JavaScript-bibliotek såsom jQuery.</p><h3>Vem avfyrade ett event?</h3><p>Som du kanske märkte i senaste exemplet, så använde vi oss av följande syntax: <code>$(this)</code>. Mystiskt kan tyckas, men mycket smidigt faktiskt. När vi kör jQuery-funktionen (<code>$()</code>) och ger den en css-selektor så kommer jQuery att välja alla element som matchar den selektorn. Men vi kan faktiskt också ge jQuery-metoden ett annat <code>HTMLElement</code>. T.ex. så här:</p><div class="panel panel-default"><div class="panel-heading">Wrappa ett HTMLElement i jQuery</div><div class="panel-body"><pre><code class="language-javascript">// First grab the first &lt;p&gt;-element using regular JavaScript
var paragraph = document.getElementsByTagName('p')[0];
 
// Then wrap it as a jQuery object
var $paragraph = $(paragrah);
 
// And now we can do all the regular cool jQuery stuff
$paragraph.fadeOut();</code></pre></div></div><p>Men vänta nu, i det tidigare diskuterade exemplet så skickade vi ju faktiskt inte ett html-element, utan vi skickade nyckelordet <code>this</code>. Löst uttryckt så refererar nyckelordet <code>this</code> i JavaScript alltid till den nuvarande kontexten. Det intressanta är alltså att om vi skickar den nuvarande kontexten till jQuery-metoden så kommer den försöka skapa ett jQuery-objekt av det. Om vi då befinner oss i en <code>event handler</code> (t.ex. den kod som exekveras när en knapp klickas på) så kommer det element som avfyrade elementet bli det objekt som hamnar i jQuery-objektet. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Att identifiera den som avfyrade ett event med jQuery</div><div class="panel-body"><p>Om vi har följande html...<pre><code class="language-markup">&lt;p&gt;Hello world&lt;/p&gt;</code></pre></p><p>Kan vi göra följande i jQuery...<pre><code class="language-javascript">// First define a click function, that we want to
// execute whenever something is clicked.
var onClick = function(){
  var sender = $(this);  // Creates a jQuery object of the element that was clicked
  alert(sender.text());  // Sends a message with the contents of the clicked element
}
 
// Then we need to attach our click function to the &lt;p&gt;-element,
// so that it will be fired when the element is clicked.
$('p').click(onClick);</code></pre></p><p>Detta kommer nu alltså att ge oss följande...</p><div class="panel panel-default"><div class="panel-heading">Resultat (testa att klicka på paragrafen)</div><div class="panel-body"><p class="jquery-events-example-2">Hello world</p><script>$('p.jquery-events-example-2').click(function(){
  alert($(this).text());
});</script></div></div></div></div><p>Detta går självklart även att göra med helt vanlig JavaScript, såsom du förhoppningsvis kommer ihåg ifrån JavaScript-kapitlet. Att det är enklare att göra i jQuery är ju förstås ett plus! Men det viktiga att komma ihåg är här alltså att detta gör det möjligt för oss att skriva mycket mer generella <code>event handlers</code> (alltså metoden som körs när ett event avfyras). Om vi t.ex. har tre knappar som alla gör väldigt liknande saker, så finns det alltså ingen anledning att binda separata event-hanterare (<code>event handler</code>) för varje knapp. Istället generaliserar vi koden i event-hanteraren och binder alla events till samma hanterare. Sött som sylt!</p><h1 href="#07-00-versioning-intro" name="07-00-versioning-intro" id="07-00-versioning-intro">Versionshantering (kommer snart)</h1><p class="lead">Kommer snart...</p><div class="page-header"><h2 href="#07-01-versioning-whatis" name="07-01-versioning-whatis" id="07-01-versioning-whatis">Vad är versionshantering?</h2></div><p>Kommer snart...</p><div class="page-header"><h2 href="#07-02-versioning-install" name="07-02-versioning-install" id="07-02-versioning-install">Komma igång</h2></div><p>Kommer snart...</p><div class="page-header"><h2 href="#07-03-versioning-staging-and-commiting" name="07-03-versioning-staging-and-commiting" id="07-03-versioning-staging-and-commiting">Staging &amp; commiting</h2></div><p>Kommer snart...</p><div class="page-header"><h2 href="#07-04-versioning-branching" name="07-04-versioning-branching" id="07-04-versioning-branching">Branching</h2></div><p>Kommer snart...</p><div class="page-header"><h2 href="#07-04-versioning-rolling-back" name="07-04-versioning-rolling-back" id="07-04-versioning-rolling-back">Rulla tillbaka</h2></div><p>Kommer snart...</p><h1 href="#08-00-php-intro" name="08-00-php-intro" id="08-00-php-intro">PHP &amp; Server-side-språk</h1><p class="lead">De flesta webbsidor vi idag besöker bygger inte bara på teknikerna <code>html</code>, <code>javascript</code> och <code>css</code>. De flesta webbsidor vi besöker idag byggs även upp med hjälp av ett s.k. <code>server-side</code>-språk.</p><p>Vad är då ett server-side-språk? Tänk så här. När vår webbläsare ber om en sida så skickar den ett <code>request</code> till en <code>server</code> som svarar med ett <code>response</code>. Detta <code>response</code> innehåller ju alltså den <code>html</code> vår webbläsare kommer att rendera. Om vi <strong>inte</strong> har ett server-side-språk så kommer denna <code>html</code>-fil alltid att vara densamma. I detta fall skulle vi kunna säga att den <code>webbserver</code> som hanterar vår webbläsares <code>request</code> agerar som en statisk filserver. Den serverar oss helt enkelt filer. Vi ber om en fil. Och vi får den tillbaka. Denna typ av webbsida är vad som generellt kallas för <a href="http://en.wikipedia.org/wiki/Static_web_page">statiska webbsidor</a>.</p><p>Med server-side-språk så kan vi helt enkelt skapa <a href="http://en.wikipedia.org/wiki/Dynamic_web_page">dynamiska webbsidor</a>. Den huvudsakliga skillnaden ligger alltså just i termerna dynamisk vs. statisk. En statisk webbserver kan ses som en filserver, medan en dynamisk webbserver snarare kan ses som en applikationsserver. Jämför t.ex. din egen hårddisk med en webbshop på nätet. Om du öppnar en <code>.html</code>-fil ifrån din hårddisk kommer den alltid se likadan ut. Inte förrän du förrändrar filen kommer webbsidan att se annorlunda ut. Webbshopen på nätet däremot kanske har en varukorg. Varende gång du besöker varukorgen kan det hända att du (t.ex.) hamnar på <code>url</code>:en <code>www.example.com/checkout.php</code>. Trots att det alltid är samma sida vi öppnar så innehåller inte alltid den renderade sidan samma sak. Om jag öppnar sidan med min användare visas min shoppingvagn, och om du öppnar den visas din. Men filen ser fortfarande exakt likadan ut i båda fallen.</p><p>I essens så handlar server-side-språk alltså om språk som i slutändan genererar (renderar) <code>html</code>. Beroende på variabel information såsom databaser, uträkningar, sessioner, <code>http headers</code> o.s.v. Men för att dessa språk ska kunna generera sin output (alltså <code>html</code>) så krävs det att vi har en server som kan "förstå" det språket. I fallet av <code>php</code> så kan vi t.ex. använda webbservern <a href="http://en.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a>. Om vi sedan installerar <a href="http://en.wikipedia.org/wiki/PHP">php</a> så kan vi konfigurera <code>Apache</code> så att det använder sig av <code>php</code>, och voíla, så har vi en server som kan tolka och rendera <code>php</code>. Oroa dig inte om detta låter snurrigt, vi kommer titta närmare på själva installationen alldeles strax.</p><p>Noteras bör, att det självklart är så att de stora giganterna till webbsidor där ute i världen inte bygger på endast ett enda server-side-språk och en enda server. Men detta är ett perfekt tillfälle att prata om det välkända idiomet <a href="http://c2.com/cgi/wiki?PrematureOptimization">optimize later</a>. Idiomet säger &mdash; lös problemet först &mdash; och när du löst det &mdash; oroa dig då över optimering. Just nu menar vi alltså att verkligheten är mer komplex, men vi behöver inte bry oss om det förrän vi kommer till den situation då vi förstår varför vi behöver bry oss om det. Men vi vill ändå poängtera, eftersom det är viktigt att inte vara naiv :)</p><h2 href="#08-01-php-installation" name="08-01-php-installation" id="08-01-php-installation">Komma igång</h2><p class="lead">Låt oss innan vi går vidare iterera på poängen att <code>php</code> självklart inte är det enda server-side-språket. Det finns otaliga andra &mdash;<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language)">Ruby</a>, <a href="http://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>, <a href="http://en.wikipedia.org/wiki/ASP.NET">ASP.NET</a>, o.s.v. Här på htmlhunden så har vi valt att använda <code>php</code> som språk för att exemplifiera och diskutera. Men försök komma ihåg att server-side-språk i grund och botten har många likheter och gör ungefär samma sak. Så om du väl har lärt dig ett, så kommer du ha lättare att komma "up to speed" med ett annat.</p><p>Anledningen till att vi har valt just <code>php</code> är att det är ett språk som är <a href="http://en.wikipedia.org/wiki/Type_system#Dynamic_type-checking_and_runtime_type_information">dynamiskt typat</a> och inte syntantiskt fullkomligt olika ifrån språk som <a href="http://en.wikipedia.org/wiki/Java_(programming_language)">Java</a> och <a href="http://en.wikipedia.org/wiki/C_Sharp_(programming_language)">C#</a>. De två sistnämda är ju förstås statiskt typade språk och alltså inte dynamiskt typade språk som <code>php</code>. Men om du kommer ifrån ett språk såsom <code>Java</code> eller <code>C#</code> så kommer du iallafall känna igen många saker såsom måsvingar, parantesanvändning, nyckelord såsom <code>static</code>, <code>final</code>, <code>public</code>, <code>private</code> och så vidare. Detta kan tyckas som trivialiteter men faktum är att språk som t.ex. <code>Ruby</code> bl.a. känns markant annorlunda p.g.a. andra sätt att hantera dessa nämnda trivialiteter. Så därför har vi valt att lära ut och diskutera <code>php</code>. Lita på oss, du kommer inte ha några problem att lära dig ett annat språk på egen hand senare! :)</p><h3>LAMP, MAMP &amp; WAMP</h3><p>En tidigare (och faktiskt fortfarande) populär akronym var termen <a href="http://en.wikipedia.org/wiki/WAMP#Variants_and_equivalents_on_other_platforms">LAMP</a>. Eller &mdash; LAMP-stacken som den ofta refereras till som. Denna akronym står (bl.a.) för <a href="http://en.wikipedia.org/wiki/Linux">Linux</a>, <a href="http://en.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a>, <a href="http://en.wikipedia.org/wiki/MySQL">MySQL</a>, och <a href="http://en.wikipedia.org/wiki/PHP">PHP</a>. Vi säger "bl.a." eftersom det finns versioner av denna stack där <code>php</code> t.ex. byts ut emot <code>perl</code> o.s.v. Denna stack har blivit mycket populär för webbutveckling.</p><p><code>Apache</code> används som webbserver, <code>php</code> som server-side-språk, <code>MySQL</code> som databas, och slutligen <code>Linux</code> som operativsystem där alla nämnda körs.</p><p>Två andra "stackar" som är adaptioner av den tidigare nämnda <code>LAMP</code>-stacken är <a href="http://en.wikipedia.org/wiki/MAMP">MAMP</a> och <a href="http://en.wikipedia.org/wiki/WAMP#Variants_and_equivalents_on_other_platforms">WAMP</a>. I förstnämnda så står M:et för Macintosh, och i sistnämnda så står W:et för Windows. Det är alltså samma mjukvarustackar som LAMP fast med operativsystemet Linux utbytt emot någon av dessa andra två.</p><h3>Installation</h3><p>För nuvarande ger vi inga steg-för-steg-instruktioner gällande hur du installerar MAMP, WAMP eller LAMP. Men om du sitter på antingen Macintosh eller Windows så är det en otroligt enkel match. För Macintosh finns nämligen det <a href="https://www.mamp.info/en/">MAMP som app</a>, och för Windows finns <a href="http://www.wampserver.com/en/">WAMP som program</a>. Dessa är alltså hela *AMP-stacken i ett enda program. Alltså, ett mycket smidigt sätt att komma igång.</p><p>Om du ändå är fundersam över hur du ska gå tillväga så föreslår vi att du tar en titt på några tutorials på YouTube.<ul><li><a href="http://www.youtube.com/results?search_query=mamp">MAMP (Macintosh)</a></li><li><a href="http://www.youtube.com/results?search_query=wamp">WAMP (Windows)</a></li><li><a href="http://www.youtube.com/results?search_query=lamp+linux">LAMP (Linux)</a></li></ul></p><h2 href="#08-02-php-syntax" name="08-02-php-syntax" id="08-02-php-syntax">PHP Syntax</h2><p class="lead"><code>PHP</code> är ett av de där språken som de flesta kan känna igen sig lite i. Nästan oavsett vilket/vilka språk du kommer ifrån innan. Eftersom vi förväntar oss att du redan har en viss grundläggande kunskap om objektorienterad programmering så kommer vi alltså i huvudsak fokusera på syntax och <a href="http://en.wikipedia.org/wiki/Language_construct">språkkonstruktorer</a>. Vi kommer således inte gå in på djupet och diskutera varför. Poängen med detta kapitel är att ge dig tillräckligt mycket kunskap för att kunna läsa identifiera olika delar av ett program skrivet i <code>PHP</code>.</p><h3>Echo</h3><p>För att skriva ut information till användaren genom att använda någon av de två <a href="#">language constructs</a>:en <code>echo</code> eller <code>print</code>. <a href="http://stackoverflow.com/questions/1647322/whats-the-difference-between-echo-print-and-print-r-in-php">Skillnaderna mellan dessa är subtila</a>, och vet du inte varför du väljer den ena över den andra var åtminstone konsistent i ditt användande.</p><div class="panel panel-default"><div class="panel-heading">Skriva till skärmen i php</div><div class="panel-body"><pre><code class="language-php">&lt;?php
  echo "Hello worldizzle";
?&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Hello woldizzle</p></div></div></div></div><p>Självklart kan vi ju inte bara ge <code>echo</code> strängar. Vi kan ge den vilket uttryck som helst som evaluerar till en sträng, eller implicit kan omvandlas till en sträng. Det senare är sant för nedan uyttryck:</p><pre><code class="language-php">&lt;?php
  echo 100 + 20 + 33;
  // Skriver ut 153
?&gt;</code></pre><p><code>echo</code> tar alltså antingen ett literal-värde, ett uttryck eller en variabel.</p><h3>Blanda <code>html</code> och <code>php</code></h3><p>Eftersom vi använder <code>php</code> för att bygga webbsidor så är ju alltså målet att få våra <code>php</code>-filer att mata ut <code>html</code>. Detta betyder att vi behöver blanda de två språken. Detta är egentligen enkelt gjort eftersom <code>php</code> kräver att all <code>php</code>-kod måste skrivas inom taggarna <code>&lt;?php</code> och <code>?&gt;</code>. Detta betyder att allt som skrivs utanför dessa block, kommer att renderas som rå text, och kan således vara <code>html</code>. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Blanda <code>php</code> och <code>html</code></div><div class="panel-body"><pre><code class="language-php">Mixing 
&lt;b&gt;
  &lt;?php echo "languages"; ?&gt;
&lt;/b&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Mixing <b>languages</b></p></div></div><p>Vi kan förstås även vända på steken och låta <code>php</code> själv <code>echo</code>:a ut <code>html</code>. Som så:</p><pre><code class="language-php">Mixing 
&lt;?php
  echo "&lt;b&gt;languages&lt;/b&gt;";
?&gt;</code></pre></div></div><p>Det finns även en kortnotation som motsvarar notationen <code>&lt;?php .. ?&gt;</code>. Den notationen saknar ordet "php" och ser helt enkelt ut som så: <code>&lt;? .. ?&gt;</code>. Dock <a href="http://www.php.net/manual/en/language.basic-syntax.phptags.php">avråder php-manualen ifrån att använda den korta syntaxen</a> då den är beronde av en konfigurationsinställning för att fungera. Närmare bestämt så måste <a href="http://www.php.net/manual/en/ini.core.php#ini.short-open-tag">short_open_tag</a> vara påslaget i konfigurationsfilen <a href="http://www.php.net/manual/en/configuration.file.php">php.ini</a>.</p><p>Notera att vi i denna guide ibland använder kortnotationen för att spara plats. Och i många exempel skriver vi inte ens ut start och sluttaggarna för <code>php</code> &mdash; återigen, för att spara plats.</p><p>Om du har en fil som <em>uteslutande</em> innehåller <code>php</code>, så är det helt ok att öppna med <code>&lt;?php</code> i början av filen och sedan strunta att stänga den längst ned. Konstigt nog så är inte det bara någonting som är ok men <a href="http://www.php.net/manual/en/language.basic-syntax.phptags.php">även någonting som rekommenderas av manualen</a>.</p><p>Men, för att sammanfatta så behöver du alltså komma ihåg att all <code>php</code>-kod måste skrivas inom <code>php</code>-taggarna. Alltså emellan <code>&lt;?php</code> och <code>?&gt;</code>.</p><h3>Variabler</h3><p>Låt oss nu istället prata om variabler. En variabel deklareras i <code>php</code> genom att placera ett dollartecken (<code>$</code>) före ett ord. Ordet blir då vår identifierare för variabeln.</p><pre><code class="language-php">$my_variable_name;</code></pre><p>Ett par regler gäller när vi namnger våra variabler.</p><ul><li>Namnet måste börja med en bokstav eller underscore (<code>_</code>).</li><li>Namnet kan <em>inte</em> börja med en siffra.</li><li>Namnet får endast innehålla alpha-numeriska tecken och underscrores. Alltså (<code>A-z</code>, <code>0-9</code>, och <code>_</code> ).</li><li>Variabelnamn är skiftlägeskänsliga. <code>$hej</code> och <code>$Hej</code> är alltså två olika variabler.</li></ul><p>Men nu har vi ju bara deklarerat en variabel. Vi har inte diskuterat hur man tilldelar till den. Som i de flesta språk tilldelar vi med hjälp av likhetstecknet (<code>=</code>). Och som i de flesta språk kan vi tilldela en varibel ett literal-värde, en annan variabel, eller evalueringen av ett uttryck. Alla nedan är alltså rimliga tilldelningar.</p><div class="panel panel-default"><div class="panel-heading">Deklarering och tilldelning av variabler i <code>php</code></div><div class="panel-body"><pre><code class="language-php">// Assigning literals
$age    = 22;
$name   = "Snow"
 
// Assigning variables
$anos   = $age;
$nombre = $name;
 
// Assigning an evaluated expression
$born   = $current_year - $age;</code></pre></div></div><h3>Selektion</h3><p>I <code>php</code> kan vi, precis som i de flesta andra språk, förändra ett programs exekveringsbana genom att konditionella selektioner. Låt oss börja med att kika på ett exempel på hur vi skriver en enkel <code>if-else</code>-selektion i <code>php</code>.</p><div class="panel panel-default"><div class="panel-heading">If-else i <code>php</code></div><div class="panel-body"><pre><code class="language-php">if (3 > 5){
  echo "The world has gone mad!";
}else{
  echo "Puh.. sanity remains..";
}</code></pre></div></div><p>Självklart kan vi ju som vanligt "kedja" hur många <code>else if</code>'s vi vill. Såsom nedan:</p><div class="panel panel-default"><div class="panel-heading">If-else i <code>php</code></div><div class="panel-body"><pre><code class="language-php">if (timeOfDay() == "morning"){
  echo "Good morning.";
}else if(timeOfDay() == "day"){
  echo "Good day.";
}else if(timeOfDay == "evening"){
  echo "Good evening."
}else{
  echo "Good night... sleep well."
}
 
// The above assumes we have a function called timeOfDay()
// that returns the time of day as a nice string :)</code></pre></div></div><p>Men eftersom <code>php</code> även stödjer <code>switch case</code>-satser så kan vi likväl använda en sådan om vi skulle vilja lösa ovan problem.</p><div class="panel panel-default"><div class="panel-heading">Switch case i <code>php</code></div><div class="panel-body"><pre><code class="language-php">switch( timeOfDay() ){
  "morning":
    echo "Good morning.";
    break;
  "day":
    echo "Good day.";
    break;
  "evening":
    echo "Good evening."
    break;
  default:
    echo "Good night... sleep well."
}</code></pre></div></div><!-- TODO: Användandet av ordet ting nedan. Använd istället den korrekta delimitationen.--><p>När vi använder <code>if-else</code> konstruktionen så behöver vi ju förstås göra jämförelser. En <code>if</code>-sats förväntar sig ett boolskt värde. Och eftersom alla värden kan ersättas med uttryck så kan vi ju (precis som i nästan alla programmeringsspråk) ge ett uttryck istället för ett värde. Detta uttryck skulle kunna vara en jämförelse emellan två ting. Och om vi ska göra jämförelser så behöver vi förstås som vanligt jämförelseoperatorer. Även i <code>php</code> hittar vi då de vanligaste jämförelseoperatorer.</p><table class="table table-condensed table-striped"><tr><th>Operator</th><th>Namn</th><th>Förklaring</th></tr><tr><td><code>==</code></td><td>Equality</td><td>Sant om $A och $B är exakt ekvivalenta.</td></tr><tr><td><code>===</code></td><td>Identical</td><td>Sant om $A och $B är exakt ekvivalenta, och de är av samma datatyp. </td></tr><tr><td><code>!=</code> eller <code>&lt;&gt;</code></td><td>Not equal</td><td>Sant om $A och $B inte är lika.</td></tr><tr><td><code>!==</code></td><td>Not identical</td><td>Sant om $A och $B inte är lika, eller om de inte är av samma datatyp.</td></tr><tr><td><code>&lt;</code></td><td>Less than</td><td>Sant om $A är lägre än $B.</td></tr><tr><td><code>&gt;</code></td><td>Greater than</td><td>Sant om $A är högre än $B.</td></tr><tr><td><code>&lt;=</code></td><td>Less than or equal</td><td>Sant om $A är lägre än eller lika låg som $B.</td></tr><tr><td><code>&gt;=</code></td><td>Greater than or equal</td><td>Sant om $A är högre eller lika hög som än $B.</td></tr></table><h3>Iteration</h3><p>Ok, låt oss nu prata om iteration. Vi börjar med att kika på den gamla gode <code>while</code>-loopen. Ett smidigt alternativ om vi vill definera ett villkor, och sedan helt enkelt bara blint loopa tills villkoret uppfylls.</p><div class="panel panel-default"><div class="panel-heading"><code>while</code>-loop i <code>php</code></div><div class="panel-body"><pre><code class="language-php">$x = 0;
$y = 10;
 
while($x < $y){
  echo $x . ", ";
  $x++;
}</code></pre><div class="panel panel-default"><div class="panel-heading">Result</div><div class="panel-body"><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, </p></div></div></div></div><p>Men om det hade varit det ovanstående problemet vi ville lösa så hade vi förstås lika väl kunnat använda en gammal hederlig <code>for</code>-loop.</p><div class="panel panel-default"><div class="panel-heading"><code>for</code>-loop i <code>php</code></div><div class="panel-body"><pre><code class="language-php">for($i=0; $i<10; $i++){="" echo="" $i="" .="" ",="" ";="" }<="" code=""></10;></code></pre><div class="panel panel-default"><div class="panel-heading">Result</div><div class="panel-body"><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, </p></div></div></div></div><p>Och när vi ändå talar om <code>for</code>-loopen, så har ju även <code>php</code> en implementation av den välanvända <code>foreach</code>-loopen. Anta att vi har en kollektion av något slag, och att vi sedan vill iterera över hela kollektionen. Låt oss kika på ett exempel där kollektionen består av en array.</p><div class="panel panel-default"><div class="panel-heading"><code>foreach</code>-loop i <code>php</code></div><div class="panel-body"><pre><code class="language-php">$apples = ["red", "green", "blue"];
 
foreach($apples as $a){
  echo $a . "&lt;br&gt;";
}</code></pre><div class="panel panel-default"><div class="panel-heading">Result</div><div class="panel-body"><p>red<br>green<br>blue</p></div></div></div></div><p>Om du har använt en <code>foreach</code>-loop i något annat språk så märker du säkert att implementationen i <code>php</code> känns lite "baklänges". I de flesta språk är loopen konstruerad så att syntaxen säger: <code>foreach(item in collection)</code>. Men i <code>php</code> så säger syntaxen: <code>foreach(collection as item)</code>. Men håll tungan rätt i mun, och tänk baklänges så ska nog allt gå sin väg! :)</p><h3>Funktioner</h3><p>Funktioner i <code>php</code> beter sig väldigt mycket som funktioner i de flesta andra stora språk. Du kan skriva funktioner som inte returnerar någonting eller funktioner som returnerar någonting. Om du kommer ifrån ett språk som <code>C#</code> eller <code>Java</code> så gäller det ju dock förstås att komma ihåg att <code>php</code> är ett dynamiskt språk. I <code>php</code> behöver vi alltså inte deklarera huruvida en funktion returnerar någonting eller ej. Inte heller behöver vi berätta vad den returnerar om den gör det. Låt oss se till några exempel.</p><div class="panel panel-default"><div class="panel-heading">Funktioner i <code>php</code></div><div class="panel-body"><pre><code class="language-php">function add($x, $y){
  return $x + y;
}
 
function show_points($person, $points){
  echo $person . " has " . $points . " points&lt;br&gt;";
}
 
$john = add(2, 5);
$jane = add(10, 3);
 
show_points("John", $john);
show_points("Jane", $jane);</code></pre><div class="panel panel-default"><div class="panel-heading">Result</div><div class="panel-body"><p>John has 2 points<br>Jane has 10 points</p></div></div></div></div><p>Om du studerar ovan exempel lite närmare så märker du att vad vi nämnde innan om dynamiska språk onekligen är sant. Den första metoden tar berättar inte att den ska returnera någonting, på något annat sätt än att den helt enkelt returnerar det den vill returnera. Inte heller berättar den att den vill returnera en siffra.</p><p>En viktig sak att förstå, är att inte heller argumenten är statiskt typade. Funktionen (vi pratar nu om <code>add($x,$y)</code> i ovan exempel) antar helt sonika att den kommer att få två siffror. Eller om vi ska vara riktigt strikta i våra uttalanden så antar metoden att den kommer att anropas med två ting som argument, där båda dessa ting går att addera genom <code>+</code>-operatorn. Det antagande om att någonting har ett visst beteende (plusoperatorn i detta fall) är det som brukar benämnas <a href="http://en.wikipedia.org/wiki/Duck_typing">Duck typing</a>. Men vi kommer prata om det mer när vi återkommer till att tala om styrkor och risker med dynamiskt typade språk.</p><h4>Valfria funktionsargument</h4><p>En intressant idé som finns implementerad i många språk är idéen om default-värden för funktionsargument. Valbara funktionsargument. Detta betyder alltså att vi kan anropa en metod utan att ange alla argument. Och att vi i funktionsdeklarationen definerar vad standardvärdet för ett visst argument är. Det värdet används då istället om den som anropar funktionen skulle ignorera att ange ett värde för det argumentet. Låt oss se till ett par exempel för att göra det lite tydligare.</p><div class="panel panel-default"><div class="panel-heading">Valfria funktionsargument i <code>php</code></div><div class="panel-body"><p>Om vi deklarerar en funktion med valfria argument...</p><pre><code class="language-php">function get_ticket($name, $pickup=false, $discount=0){
  $price = 100 - $discount;
    
  if($pickup){
    $price += 25;
    $pickup_message = "Pickup included.";
  }else{
    $pickup_message = "No pickup.";
  }
    
  return $name . ": " . $price. " kr. " . $pickup_message;
}</code></pre><p>...Så kan vi sedan anropa den utan att ange värden för de valfria argumenten. Och de fördefinerade värdena för de avsaknade argumenten kommer istället att användas.</p><pre><code class="language-php">get_ticket("John", true);
//=> "John: 125kr. Pickup included."
 
get_ticket("Jane", false, 100);
//=> "Jane: 0kr. No pickup."
 
get_ticket("Carl");
//=> "Carl: 125kr. No pickup."</code></pre></div></div><p>Något att tänka på är att vi i ovan exempel inte kan ange ett värde för det sista argumentet utan att ange ett värde för det andra. Med andra ord: om vi vill ange ett värde för ett valfri argument, så måste vi ange värden för alla argument före. Med andra ord gäller det att välja sin argumentordning noga.</p><h2 href="#08-03-php-debugging" name="08-03-php-debugging" id="08-03-php-debugging">Felsökningstekniker</h2><p>Kommer snart...</p><h2 href="#08-04-php-data-forms" name="08-04-php-data-forms" id="08-04-php-data-forms">Läsa formulärdata med PHP</h2><p class="lead">När vi pratade om formulär i <code>html</code> så fokuserade vi endast på hur vi får webbläsaren att visa upp de formulärkomponenter vi vill. Textfält, radioknappar, checkboxar, knappar och så vidare. Dock pratade vi aldrig om hur vi som utvecklare kan använda oss av och komma åt den datan som användaren skriver i formulären. Vi nämnde att vi behöver ett server-side-språk för att kunna göra någonting permanent med datat &mdash; såsom att spara det i en databas. Så, eftersom vi nu befinner oss i kapitlet om server-side-språk så är det just det vi ska prata om. Alltså, hur vi på olika sätt kan läsa "input" ifrån användaren.</p><p>Faktum är att detta kapitels rubrik egentligen är ganska missvisande. Vi pratar inte bara om hur du kan läsa data ifrån ett formulär ifyllt av en användare. De tekniker vi kommer att prata om här har mycket bredare användning. Och borde kanske snarare kalla detta kapitel för &mdash; "Att genom php och html läsa och skicka ifrån och till ett http request". Men den titeln var inte lika "catchy" :)</p><p>Låt oss börja med att repetera hur ett vanligt <code>html</code>-formulär ser ut. Beakta nedan exempel, och fundera över faktumet att attributet <code>method</code> är tillskrivet värdet <code>GET</code>. Fundera även över faktumet att attributet <code>action</code> är tillskrivet värdet <code>process.php</code>.</p><pre><code class="language-markup">&lt;form action="process.php" method="GET"&gt;
  &lt;label for="field-name"&gt;Ditt namn&lt;/label&gt;
  &lt;input type="text" id="field-name" name="name" placeholder="Ditt namn" required&gt;
 
  &lt;label&gt;Vad vill du äta till frukost?&lt;/label&gt;
 
  &lt;label for="field-pancakes"&gt;Pannkakor&lt;/label&gt;
  &lt;input type="radio" id="field-pancakes" name="breakfast" value="pancakes"&gt;
 
  &lt;label for="field-scrambled"&gt;Äggröra&lt;/label&gt;
  &lt;input type="radio" id="field-scrambled" name="breakfast" value="scrambled"&gt;
 
  &lt;label for="field-toast"&gt;Övrigt&lt;/label&gt;
  &lt;input type="radio" id="field-toast" name="breakfast" value="toast"&gt;
 
  &lt;input type="submit" value="Skicka!"&gt;
&lt;/form&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form action="#" method="GET"><div class="form-group"><label for="99986458-field-name">Ditt namn</label><input type="text" id="99986458-field-name" name="name" placeholder="Ditt namn" required="required" class="form-control"></div><label>Vad vill du äta till frukost?</label><div class="form-group"><div class="radio"><input id="99986458-field-pancakes" type="radio" name="breakfast" value="pancakes" required="required"><label for="99986458-field-pancakes">Pannkakor</label></div><div class="radio"><input id="99986458-field-scrambled" type="radio" name="breakfast" value="scrambled" required="required"><label for="99986458-field-scrambled">Äggröra</label></div><div class="radio"><input id="99986458-field-toast" type="radio" name="breakfast" value="toast" required="required"><label for="99986458-field-toast">Toast</label></div></div><input type="submit" value="Skicka!" class="btn btn-default"></form></div></div><p>Vi bad dig att framförallt notera användandet av nyckel-värde-paren <code>action="process.php"</code> och <code>method="GET"</code>. Kanske har du redan ett hum. Men låt oss prata om det. Vad betyder dessa två egentligen? Varför behöver vi ange dessa attribut? Och vad kan vi ge de för värden? Låt oss ta de en efter en.</p><h3>Form action</h3><p>När användaren klickar på <code>submit</code>-knappen i ovan formulär så kommer formulärdatat att skickas till sidan <code>process.php</code>. Eller mer specifikt uttryckt så kommer klickandet på knappen att orska användarens webbläsare att utfärda ett nytt <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP Request</a>. Alltså i stort sätt samma sak som händer när man trycker på en länk. Webbläsaren utfärdar ett nytt request till den <a href="http://en.wikipedia.org/wiki/Uniform_resource_locator">url</a> som gömmer sig under länken. Vi väntar. Och så fort webbläsaren får ett <code>response</code> så är vi på den nya sidan.</p><p>När användaren trycker på "submit"-knappen så "skickas" denne helt enkelt till en annan sida. Vilken sida användaren skickas till bestäms utav den <code>url</code> vi anger som nyckel i attributet <code>action="[url]"</code>.</p><p>I fallet ovan så hade vi angett filnamnet <code>process.php</code>. Eftersom vår url varken börjar med ett protokoll eller ett slashtecken (<code>/</code>) så är det en <a href="http://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2">relativ url</a> och vi kommer helt enkelt att skicka användarens webbläsare till sidan <code>process.php</code> om det finns en sådan sida på den "plats" användaren befinner sig just nu. Med andra ord. Om användaren (och således även formuläret) befann sig på adressen <code>http://example.com/breakfast.php</code> så skulle användaren, när den klickar på "submit" i formuläret att skickas till adressen <code>http://example.com/process.php</code>.</p><p>Det kanske <strong>viktigaste</strong> med allt detta &mdash; är ju förstås inte att vi skickar användaren till en ny <code>url</code>. Det viktigaste är att den data som användaren fyllt i i formuläret <strong>skickas med i detta http request</strong>.</p><h3>Form method</h3><p>Så vad gör då attributet <code>method="[HTTP METHOD]"</code>? Egentligen är det inte särskilt konstigt. Vi har redan klargjort att när användaren klickar på formulärets "submit"-knapp så kommer användarens webbläsare att utföra ett nytt <code>http request</code>. Alltså omdirigeras till en ny <code>url</code>. Samt att den data som användaren matat in i formuläret faktiskt <strong>skickas med i samma request</strong>. Notera ordvalet "i samma request". Den uppenbara frågan är ju förstås &mdash; hur? Hur kan en massa data som användaren har fyllt i skickas med ett <code>http request</code>. Det kan ju vara precis viiiilken data som helst. Det är alltså just här attributet <code>method="[HTTP METHOD]"</code> kommer in i bilden.</p><p>Det går alltså att bädda in en massa data i ett <code>http request</code>. Gärna på <a href="http://en.wikipedia.org/wiki/Attribute%E2%80%93value_pair">nyckel-värde-par</a>-form. Men eftersom det finns <a href="http://www.w3schools.com/tags/ref_httpmethods.asp">olika typer av http requests</a> så kan data alltså skickas på olika sätt. Eller snarare olika "form" (no pun intended). Detta är vad attributet <code>method</code> styr över. Attributet avgör alltså vilken typ av <code>http request</code> vi ber användarens webbläsare att göra. </p><p>De två vanligaste typerna av <code>http request</code> är <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">GET</a> och <a href="http://en.wikipedia.org/wiki/POST_(HTTP)">POST</a>. Det finns ett par andra typer, men eftersom <a href="http://stackoverflow.com/questions/8054165/using-put-method-in-html-form">formulär i <code>html</code> endast tillåter dessa två</a> så är det endast dessa vi kommer att fokusera på här. Du kan <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">läsa om fler metoder hos standardsorganet W3C</a>.</p><p>När användaren klickar på <code>submit</code>-knappen i detta formulär så kommer formulärdatat att skickas genom metoden <code>HTTP GET</code>. Eller mer specifikt &mdash; när användaren klickar på knappen kommer användarens webbläsare utföra ett nytt <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP Request</a>. Detta request kommer att göras till den <code>url</code> som är specificerad av attribtuet <code>action</code>. Men eftersom det finns olika typer av <code>HTTP requests</code> (t.ex. <code>POST</code> och <code>GET</code>) så anger vi vilken typ av request vi vill göra under <code>action</code>.</p><h3>Skillnader emellan POST och GET</h3><p>Låt oss nu diskutera lite skillnader emellan POST och GET. Det enda rätta är väl egentligen att gräva ned oss och snabbt kika på hur dessa olika requests ser ut. Så att vi är överens om att det inte är någon slags svart magi. Men låt oss först kika på deras utvärtes skillnader.</p><p>När du knappar in en <code>url</code> i din webbläsare och trycker enter så är det alltid ett <code>GET</code> request du kommer att skicka. Så länge du inte använder en webbläsare som är designad för att skicka andra typer av requests. Rent "design"-mässigt så används <code>GET</code> för att <em>hämta</em> resurser. Alltså <em>inte</em> för att förändra. Med andra termer skulle vi kunna säga att idealfallet är att ett <code>GET request</code> är <a href="http://en.wikipedia.org/wiki/Side_effect_(computer_science)">fritt ifrån sidoeffekter</a> på servern. Vi använder ordet "design" eftersom detta ju är en rekommendation. Således en rekommendation som inte alltid följs. Om vi låter användare göra <code>GET requests</code> till en given sida, och sedan ökar en räknare i en databas för att föra användarstatistik så är det ju en s.k. "sidoeffekt". Denna diskussion är helt enkelt inte svartvit.</p><p>Det är även rimligt att anta att vi i exempelrutan ovan med frukosten har brutit emot regeln om att använda <code>GET</code> för sidoeffektsfria anrop. Men eftersom vi ännu inte berättat vad vi ska göra med datat som användaren skickar så är det förstås svårt att säga :)</p><p>Ett lättare sätt att belysa distinktionen lär vara detta. Vi skulle hävda att ett sökformulär bör skicka sin data via <code>GET</code>. Medan ett registreringsformulär rimligen bör skickas över <code>POST</code>. Även ett inloggningsformulär skulle vi nog skicka över <code>POST</code>. De två senare förändrar ju faktiskt "state" på servern. I första fallet genom att lagra en till användare i databasen. I andra fallet genom att skapa en session för användaren (alltså markera den som inloggad). Medan i det allra första fallet &mdash; sökfallet &mdash; så vill vi ju faktiskt bara filtrera information. Ingenting förändras på servern. Vi vill, till användaren, returnera information som rimligen är ett subset av någonting annat. </p><p>Det är fullt förståeligt om du tycker att det här är förvirrande. Det blir mycket på en gång. Men låt oss se det ifrån en annan vinkel. Låt oss fundera på hur data (exempelvis alltså formulärdata) skickas med de olika anropstyperna. Nedan följer två exempel på hur ett request till en sida skulle kunna se ut. Den ena varianten användet <code>GET</code> och den andra använder <code>POST</code>. Det viktiga är att du fokuserar på hur datat skickas.</p><div class="panel panel-default"><div class="panel-heading">Exempel på HTTP requests genom GET och POST</div><div class="panel-body"><p>Låt oss kika på hur dessa requests faktiskt ser ut. Vi gör anrop till adressen <code>example.com</code>. Och vi vill skicka med följande data: <code>color = red</code> och <code>shape = circle</code>. Fokusera framförallt på hur denna data i de två exemplena skickas olika.</p><p>Ett request genom <code>HTTP GET</code> skulle då kunna se ut som så...<pre><code class="language-http">GET https://example.com/?shape=circle&color=red
Accept: */*
User-Agent: runscope/0.1</code></pre></p><p>Och ett request genom <code>HTTP POST</code> skulle istället kunna se ut som så...<pre><code class="language-http">POST https://example.com/
Accept: */*
Content-Length: 22
Content-Type: application/x-www-form-urlencoded
User-Agent: runscope/0.1
shape=circle&color=red</code></pre></p><p>Båda dessa requests skickades tjänsten <a href="http://www.hurl.it/">hurl.it</a>. Prova gärna och utförska själv!</p></div></div><p>Märkte du vad som var lustigt i ovan exempel? Det är förstås mycket som känns (o)lustigt med <code>http requests</code> första gången man ser dem. Rena mumbo jumbon. Men det viktiga vi behöver förstå är att den data som vi skickar med i ett <code>GET</code>-anrop blir en del av själva <code>url</code>:en vi anropar. Studera de två exemplena ovan. I det första fallet så anropar vi en url med ett frågetecken och en massa text på slutet. Detta är vår data "inkodad" i url:en enligt en standard som kallas <a href="http://www.w3schools.com/tags/ref_urlencode.asp">url encoding</a>. Själva strängen med det kodade datat kallas för en <a href="http://en.wikipedia.org/wiki/Query_string">query string</a>. I det andra fallet däremot. Där anropade vi helt enkelt bara den <code>url</code> vi ville till. Utan en massa urlkodad information i slutet av adressen. Istället skickade vi informationen längst ned i vårt <code>request</code>.</p><p>Som du kanske har misstänkt betyder detta alltså att när vi gör anrop via <code>GET</code> så syns all data vi skickar med i anropet i <code>url</code>:en själv. När vi däremot gör ett <code>POST</code>-anrop så syns inte all data i adressen. Bara denna information gör att vi kan göra smartare val kring när vi ska använda den ena och när den andra. En fördel med att t.ex. skicka data i <code>url</code>:en själv är ju att en användare kan kopiera den adressen och skicka till en kompis. Om vi istället skulle skicka datat "gömt" genom <code>POST</code> så skulle datat inte "följa" med när användaren kopierade url:en. Användaren skulle då istället behöva kopiera hela <code>HTTP requestet</code>. Vilket inte riktigt är något den vardaglige användaren ens skulle orka bry sig om att tänka på.</p><h3>Läsa POST och GET i PHP</h3><p>Låt oss nu istället prata om hur vi i <code>php</code> kan läsa den data som kan skickas genom ett request. När en <code>php</code>-fil körs (i kontexten av en webbapplikation) så körs den rimligen av en webbserver (t.ex. <a href="http://en.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a>). En webbserver kan ju, som vi långt tidigare klargjort, ta emot <code>request</code>:s. Och som vi nu klargjort kan ju <code>request</code>:s (bl.a.) vara av typen <code>POST</code> eller <code>GET</code>. Och i båda fallen kan de innehålla data ifrån den som skickat <code>request</code>:et. Och eftersom det är en just en webbserver som delegerar neråt till <code>php</code> så är det så fantastiskt att de flesta webbservrar låter anropet till server-side-språket få veta vad den har fått för request. Det betyder alltså att om vi använder <em>Apache</em> och <code>php</code> så kommer vi i vår kod åt en hel del information om det anrop som faktiskt orsakat att vi kör den kod vi just nu kör. Låt oss se till några exempel.</p><table class="table table-condensed table-striped"><tr><td><a href="http://www.php.net/manual/en/reserved.variables.request.php">$_REQUEST</a></td><td>En <em>superglobal</em> <em>associativ array</em> som innehåller alla requestvariabler oavsett om de kommer ifrån <em>GET</em>, <em>POST</em> eller <em>Cookies</em>.</td></tr><tr><td><a href="http://www.php.net/manual/en/reserved.variables.get.php">$_GET</a></td><td>En <em>superglobal</em> <em>associativ array</em> som innehåller alla requestvariabler som återfinns i den nuvarande <em>url</em>:en.</td></tr><tr><td><a href="http://www.php.net/manual/en/reserved.variables.server.php">$_SERVER</a></td><td>En <em>superglobal</em> <em>associativ array</em> som innehåller en mängd matnyttig information. Bland annat vilken requesttyp nuvarande <em>request</em> är av, nuvarande <em>querystring</em> eller vilken <em>port</em> skriptet körs på, o.s.v.</td></tr><tr><td><a href="http://www.php.net/manual/en/function.getallheaders.php">getallheaders()</a></td><td>En metod som returnerar en <em>array</em> innehållandes alla <em>http headers</em> för det nuvarande <em>http request</em>:et.</td></tr></table><p>Notera att det är fullt möjligt att skicka <code>GET</code>- och <code>POST</code>-data samtidigt eftersom vi kan göra ett <code>POST</code>-request till en url i vilken vi manuellt adderar urlkodade nyckel-värde-par. Anta alltså t.ex. att vi skulle efterfråga url:en <code>http://example.com/?shape=triangle</code>. Om vi t.ex. skulle ange den <em>url</em>:en som värde till <code>action</code>-attributet i ett formulär, och sedan ange att formulärets <code>method</code> skulle vara <code>POST</code>. Då kommer formulärets data ju alltså skickas i ett <code>POST</code>-request, men eftersom <em>url</em>:en vi angav redan innehöll data formaterad som i ett <code>GET</code>-request så kommer vi även ha skickat med den datan.</p><p>Så med andra ord är det i ärlighetens namn inte möjligt att göra ett <code>POST</code>- och <code>GET</code>-request samtidigt. Men det är däremot absolut möjligt att skicka urlparametrar trots att vi gör ett <code>POST</code>-request. Således kan det, i relation till <code>php</code>, hända att vi har värden i <code>$_GET</code> trots att vi har värden i <code>$_POST</code>. Och trots att ett request var av typen <code>POST</code>. Mycket behändigt kommer du märka!</p><h3>Exempel på användning i PHP</h3><p>Låt oss nu då faktiskt se till ett konkret exempel på hur vi kommer åt informationen genom <code>php</code>. Anta att vi anropat följande <em>url</em>: <code>http://example.com/?name=Johnny&breakfast=pancakes</code>. Om du kikar på formuläret vi hade som exempel högre upp i detta kapitel, så ser du nog hur den här <em>url</em>:en faktiskt skulle kunna vara ett resultat av en användare som fyllt i formuläret. I vår <code>php</code> skulle vi då alltså kunna hantera formulärdatat som så:</p><div class="panel panel-default"><div class="panel-heading">Att läsa värden ifrån $_GET</div><div class="panel-body"><pre><code class="language-php">// Assuming an incoming GET request for the following url:
// http://example.com/?name=Johnny&breakfast=pancakes
 
$name   = $_GET["name"]
$choice = $_GET["breakfast"]
 
echo "Dear $name, I'll certainly make you some $choice!";</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Dear Johnny, I'll certainly make you some pancakes.</p></div></div></div></div><h3>Att själv konstruera ett GET request</h3><p>Som tidigare nämnt så kan <em>querystring</em>-variabler förekomma även utan att vi använder ett formulär. Som tidigare nämnt så är ju de flesta requests faktiskt <code>GET</code> requests, och således uppenbara kandidater för att innehålla <em>querystring</em>-variabler.</p><p>Vi skulle t.ex. kunna skicka data med en helt vanlig länk.<pre><code class="language-markup">&lt;a href="http://example.com/?name=Johnny&breakfast=pancakes"&gt;
  Johnny likes pancakes
&lt;/a&gt;</code></pre></p><p>Vilket skulle ge:</p><div class="panel panel-default"><div class="panel-body"><a href="http://example.com/?name=Johnny&amp;breakfast=pancakes">Johnny likes pancakes</a></div></div><p>Vi skulle förstås även kunna använda <code>php</code> för att göra precis samma sak men istället byta ut de konkreta värdena emot variabler.<pre><code class="language-php">&lt;a href="http://example.com/?name=&lt;?= $name; ?&gt; &breakfast=&lt;?= $choice; ?&gt;"&gt;
  Johnny likes pancakes
&lt;/a&gt;</code></pre></p><p>Men eftersom det ändå är så pass vanligt att konstruera en <em>querystring</em> så erbjuder <code>php</code> oss en fantastisk metod som hjälper oss genom att automatiskt transformera en <em>associativ array</em> till en <em>querystring</em>. Med andra ord så här:<pre><code class="language-php">&lt;?php
  $data = array(
    'name'      => $name,
    'breakfast' => $choice
  );
  $querystring = http_build_query($data);
?&gt;
 
&lt;a href="http://example.com/?&lt;?= $querystring; ?&gt;"&gt;
  Johnny likes pancakes
&lt;/a&gt;</code></pre></p><p>Om vi ifrån en <code>php</code>-sida skulle vilja automatiskt omdirigera (<em>redirect</em>) användaren till en annan sida så kan vi använda <code>php</code>-metoden <code>header('Location: [url]')</code>. Och om vi vill även vill passa på att skicka med parametrar, så kan vi förstås göra det genom att som vanligt lägga till en <em>querystring</em> i slutet av <code>url</code>:en. Alltså som så:<pre><code class="language-php">&lt;?php
  $data = array(
    'name'      => $name,
    'breakfast' => $choice
  );
  $querystring = http_build_query($data);
?&gt;
 
// And then redirect
header("Location: http://example.com/?$querystring");</code></pre></p><p>Om du inte redan märkt det, så är alltså syntaxen för att bygga upp en querystring följande:
<code>nyckel=värde</code> där varje nyckel-värde-par separeras genom ett och-tecken (<code>&amp;</code>). Sedan är det förstås viktigt att komma ihåg att om vi ska lägga till en <em>querystring</em> till en <code>url</code> så måste vi avgränsa slutet på <code>url</code>:en och början på <em>querystring</em>:en med ett frågetecken (<code>?</code>). Så sammantaget blir det alltså:<pre><code>http://example.com/?key1=value1&key2=value2&keyN=valueN</code></pre></p><h2 href="#08-05-php-oop" name="08-05-php-oop" id="08-05-php-oop">Objektorienterad PHP</h2><p class="lead">Dags för objektorienterad <code>php</code>! Äntligen! Språket <a href="http://michaelkimsal.com/blog/php-is-not-object-oriented/">anses inte av alla vara objektorienterat</a>. Ifrån början gick det inte ens att skriva objektorienterad kod överhuvudtaget. Men, sedan en tid tillbaka har <code>php</code> börjat stödja klassisk <code>oop</code> i den bemärkelsen att vi själva kan skriva objektorienterade program (med klasser, arv, instansmetoder etc.). Men det finns som sagt en <a href="http://stackoverflow.com/questions/4699519/is-php-object-oriented">debatt kring huruvida språket verkligen kan anses objektorienterat ändå</a>. En anledning till denna skepticism grundar sig i faktumet att, eftersom <code>php</code> inte alltid varit objektorienterat, så finns det många gamla kvarlevor i form av "fria" metoder. Allt är inte objekt i <code>php</code>.</p><p>Låt oss exemplifiera vad vi menar med att det finns en massa icke-objektorienterade kvarlevor kvar i språket. För att hämta en substräng av en sträng i <code>php</code> skulle vi kunna skriva följande:<pre><code class="language-php">substr($mystring, $n);</code></pre></p><p>Om språket hade varit mer uppenbart objektorienterat hade vi rimligen skrivit följande:<pre><code class="language-php">$mystring->substring($n);</code></pre></p><p>Men, allt detta hindrar oss inte ifrån erövra världen med allsmäktig och objektorienterad <code>php</code>. Bara för att många befintliga metoder inte är objektorienterade, så betyder det inte att den kod vi själva skriver inte kan vara objektorienterad.</p><p>Som nämnt i syntax-kapitlet så räknar vi med att du har en viss erfarenhet av objektorienterad programmering sedan tidigare. Så vi kommer i detta kapitel i huvdsak fokusera på att redogöra för syntax.</p><h3>Klasser och instantiering</h3><p>En klass deklareras i <code>php</code> rätt och slätt genom keyword:et <code>class</code>. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Deklarera en klass i <code>php</code></div><div class="panel-body"><pre><code class="language-php">class Animal{ ... }</code></pre></div></div><p>Om vi har en klass, så kan vi förstås instantiera den. Och när vi instantierar ett objekt så anropas förstås dess <a href="http://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)">konstruktor</a>. En klass som inte har en konstruktur kan förstås konstrueras i vilket fall, och klassen har då en implicit konstruktor som inte tar några argument. Om vi däremot vill deklarera en konstruktor själva så använder vi det "magiska" namnet <code>__construct</code>.</p><div class="panel panel-default"><div class="panel-heading">Konstruktor i <code>php</code></div><div class="panel-body"><pre><code class="language-php">class Animal{
  function __construct($name){
    echo "Hello, my name is $name.";
  }
}</code></pre></div></div><p>Vi använde termen "magisk" tidigare eftersom dokumentationen för <code>php</code> själv kallar de metoder som börjar med två underscore-tecken (i.e. <code>__someMethodName</code>) för "magiska" metoder. Det är inte förbjudet i språket att deklarera egna metoder som börjar med två understreck, men det är rekommenderat att undvika det. Av den enkla anledning att språket har en del <a href="http://www.php.net/manual/en/language.oop5.magic.php">inbyggda metoder som är namngivna på just detta sätt</a>.</p><p>Låt oss nu se på hur vi <a href="http://en.wikipedia.org/wiki/Instance_(computer_science)">instantierar en en klass</a>, alltså skapar ett objekt, i <code>php</code>.</p><div class="panel panel-default"><div class="panel-heading">Instantiering av en klass i <code>php</code></div><div class="panel-body"><pre><code class="language-php">$dog = new Animal('Whiskey');</code></pre></div></div><p>När vi instantierar en klass så körs ju, som nämnt och bekant, konstruktorn. Låt oss då kombinera dessa två (ovan) exempel för att se vad som händer när vi kör programmet.</p><div class="panel panel-default"><div class="panel-heading">Att deklarera en klass med konstruktor, och sedan instantiera klassen.</div><div class="panel-body"><pre><code class="language-php">// Assume we have a class with a constructor...
class Animal{
  function __construct($name){
    echo "Hello, my name is $name.";
  }
}
 
// And then instantiate it...
$dog = new Animal('Whiskey');
$cat = new Animal('Socks');</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Hello, my name is Whiskey.</p><p>Hello, my name is Socks.</p></div></div></div></div><h3>Klass- och instansmedlemmar</h3><p>Precis som i vilket annat språk med klasser som helst så kan vi definera både klass- och instansmedlemmar för en given klass. När vi pratar om "medlemmar" så pratar vi alltså både om metoder och variabler. Så när vi pratar om klass- och instalsmedlemmar så pratar vi alltså både om (1) klass- och instansvariabler, samt (2) klass- och instansmetoder.</p><p>Låt oss börja med att repetera vad skillnaden mellan en klass- och instansmedlem är. En klassmedlem är vad som brukar kallas för en statisk medlem. En klassmedlem tillhör klassen medan en instansmedlem tillhör instansen. Låt oss omformulera. En klassmedlem tillhör alla instansmedlemmar samtidigt, medan en instansmedlem är unik per instans. Detta betyder alltså att om vi deklarerar en klassvariabel &mdash; så existerar det endast en enda av den variabeln (tänk: minnesplats). Men om vi deklarerar en instansvariabel så kommer det existera exakt lika många  variabler (tänk återigen: minnesplatser) som vi skapar instanser av den klassen.</p><h4>Klass- och instansvariabler</h4><p>Låt oss tänka i termer av ett exempel. Anta att vi har en klass som heter <code>Animal</code>. Anta att varje instans av ett djur har ett namn. Vi lagrar namnet i en instansvariabel. Varför? Jo, eftersom varje djur har ett unikt namn. Och om det är unikt per djur så måste vi skapa lika många variabler som instanser. Varje variabel måste tillhöra varje unik instans.</p><p>Anta nu istället att vi vill ha en variabel i vilken vi kan hålla koll på det totala antal djur som existerar i vår applikation. Visst skulle vi skulle kunna skapa en variabel vartsomhelst och sedan öka den varje gång vi skapar ett nytt djur. Men det är riskabelt. Om vi glömmer att öka variabeln en enda gång så har vi helt plötsligt en applikation som talar osanning. Som du kanske redan har gissat så kommer vi istället föreslå att vi skapar en statisk (alltså en klass-) variabel. Om vi sedan i klassens konstruktor ser till att öka denna statiska variabel med ett så kommer det betyda att vi omöjligen kunna hamna i ett läge där vi har instantierat fler djur än gånger vi ökat variabeln. En klassvariabel är alltså en bra idé för detta scenario eftersom vi vill lagra information som är relaterad till alla instanser av klassen <code>animal</code> och inte till varje specifik instans.</p><p>Låt oss snabbt kika på hur syntaxen ser ut för att deklarera klass- och instansvariabler.</p><div class="panel panel-default"><div class="panel-heading">Deklarera klass- och instansvariabler</div><div class="panel-body"><pre><code class="language-php">class Animal{
  // class variables are declared
  // by using the keyword 'static'
  private static $foo;
 
  // instance variables are declared
  // by not using the keyword 'static'
  private $bar;
}</code></pre></div></div><p>Notera alltså att skillnaden emellan att deklarera en statisk (klass-) variabel och en instansvariabel helt enkelt är existensen eller avsaknaden av nyckelordet <code>static</code>. Skriver vi <code>static</code> blir variabeln statisk (alltså en klassvariabel). Om vi inte skriver någonting så implicerar det att det är en instansvariabel.</p><h4>Access modifiers</h4><p>Vi kommer att implementera det exempel som diskuterats ovan i helhet, i detta kapitel. Men vi måste ta det steg för steg för att verkligen förstå alla delar. Låt oss först diskutera det som kallas <code>access modifiers</code>. Detta handlar alltså om huruvida en medlem är <code>public</code>, <code>private</code> eller <code>protected</code>. Som du kanske märkte så markerade vi i ovan exempel att de två variablerna var <code>private</code>. På samma sätt som en medlem måste markeras som statisk eller inte, måste en medlem också ha en <code>access modifier</code>. Denna avgör "vilka" som kommer att få komma åt medlemen. Den "modify":ar alltså "access" &mdash; för att prata svengelska :)</p><table class="table table-condensed table-striped"><tr><th>Keyword</th><th>Förklaring</th></tr><tr><td><code>public</code></td><td>Alla som har tillgång till klassen/instansen har tillgång till medlemmen.</td></tr><tr><td><code>private</code></td><td>Endast klassen/instansen själv har tillgång till medlemmen.</td></tr><tr><td><code>protected</code></td><td>Endast klassen/instansen själv, samt klasser/instanser i samma arvskedja, har tillgång till medlemmen.</td></tr></table><h4>Klass- och instansmetoder</h4><p>Att deklarera klass- och instansmetoder påminner väldigt mycket om att deklarera klass- eller instansvariabler. Vi börjar med att ange en access modifier. Sedan anger vi huruvida den är statisk inte. Och slutligen en metod som vanligt. Det vill säga med namn och parametrar. Låt oss se till några exempel.</p><div class="panel panel-default"><div class="panel-heading">Deklarera klass- och instansmetoder</div><div class="panel-body"><pre><code class="language-php">class Animal{
  private static function foo(){
    // Not accessible from the outside since it's private.
    // Lives on the class because it's static.
  }
 
  private function bar(){
    // Accessible from the outside since it's private.
    // Lives on the instance beacuse it's not static.
  }
}</code></pre></div></div><h4>Att anropa medlemmar</h4><p>Nu har vi bara pratat om hur vi deklarerar medlemmar. Vi har inte pratat om hur vi "kommer åt" dem. Egentligen är det väldigt enkelt. Instansmedlemmar når vi med hjälp av pil-notation (<code>-&gt;</code>). Klassmedlemmar å andra sidan, når vi med hjälp av kolon-kolon-notation (<code>::</code>). Det blir antagligen klarare om vi ser till ett par exempel.</p><div class="panel panel-default"><div class="panel-heading">Anropa medlemmar av en instans eller klass utifrån</div><div class="panel-body"><pre><code class="language-php">// Assuming we have a class called Dog...
$dog = new Dog("Brian");
 
// accessing a public instance variable
$dog->someVariable;
 
// accessing a public static/class variable
Dog::$someVariable;
 
// accessing a public instance method
$dog->someMethod();
 
// accessing a public static/class method
Dog::someMethod();</code></pre></div></div><p>Ovan exempel visar endast hur vi anropar publika medlemmar utifrån. Det vill säga inte ifrån instansen eller klassen själv. Om vi istället vill anropa medlemmar tillhörande klassen eller instansen själv ifrån klassen eller instansen själv så kan vi använda nästan samma syntax. Högersidan om kolon-kolon- eller pil-syntaxen förblir densamma, eftersom metoden/variabeln vi vill anropa är densamma. Däremot förändras vänstersidan. Eftersom kontexten vi försöker anropa medlemmen ifrån har förändrats. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Anropa medlemmar av en instans eller klass utifrån</div><div class="panel-body"><pre><code class="language-php">class Dog{
  function __construct(){
    /* We're making our calls from the constructor
       for the sole reason of illustrating that we're
       calling the members from inside an instance. */
    
    // accessing a private instance variable
    $this->someVariable;
    
    // accessing a private static/class variable
    self::$someVariable;
    
    // accessing a private instance method
    $this->someMethod();
    
    // accessing a private static/class method
    self::someMethod();
  }
 ...
}</code></pre></div></div><p>Det viktigaste att notera med ovan exempel är användandet av <code>$this</code> och <code>self</code>. Förstnämnda refererar alltså till den instans som anropet görs i. Om vi befinner oss i en instansmetod i en instans av en animal och använder nyckelordet <code>$this</code> så refererar det ordet alltså till den egna instansen. Om vi å andra sidan använder uttrycket <code>self</code> så refererar vi till klassen. Inte instansen utan klassen. Om vi befinner oss i en instans av (eller en klassmetod för) klassen <code>Animal</code>, så refererar <code>self</code> alltså till själva klassen <code>Animal</code>. Inte till någon unik instans utan den generella klassen. Där vi förstås även kan ha statiska medlemmar definerade.</p><h4>Exempel</h4><p>Ok, låt oss nu se till en full implementation av klassen <code>Animal</code> som den tidigare diskuterades.</p><div class="panel panel-default"><div class="panel-heading">Exempel på användande av klass- och instansmedlemmar</div><div class="panel-body"><pre><code class="language-php">class Animal{
  private static $count = 0;
  private $name = "Unnamed";
 
  function __construct($name){
    $this->name = $name;
    self::$count++;
  }
 
  public function speak(){
    echo "Hi, I am $this->name.&lt;br&gt;";
  }
 
  public static function count(){
    $num = self::$count;
    echo "There's $num animal(s) in the world.&lt;br&gt;";
  }
}
 
 
$cat = new Animal("Whiskers");
$cat->speak(); 
Animal::count();
 
$dog = new Animal("Frolic");
$dog->speak(); 
Animal::count();</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Hi, I am Whiskers.</p><p>There's 1 animal(s) in the world.</p><p>Hi, I am Frolic.</p><p>There's 2 animal(s) in the world.</p></div></div></div></div><h3>Överkurs</h3><p>Kommer snart...</p><h4>Interfaces och Abstrakta klasser</h4><p>Kommer snart...</p><h4>Automatisk inladdning av klassfiler</h4><a href="http://www.php.net/manual/en/function.spl-autoload-register.php">Kommer snart...</a><h2 href="#08-06-php-organizing-code" name="08-06-php-organizing-code" id="08-06-php-organizing-code">Kodorganisation</h2><p class="lead">Uttrycket <a href="http://agilemanifesto.org/">responding to change</a>, har blivit mycket viktigt inom mjuvaruutveckling. I essens belyser det idéen om att världen runtomkring oss (kunder, teknik, krav, etc.) förändras så snabbt att vi alltid måste vara beredda att förändra våra applikationer. Därför är det alltså viktigt att vi skriver kod som är hanterbar. Vi måste kontrollera vår kod och inte låta vår kod kontrollera oss. I detta kapitel ska vi alltså prata om lite olika strategier för att öka nivån av struktur i våra <code>php</code>-applikationer. Med andra ord ska vi prata om <a href="http://en.wikipedia.org/wiki/Code_refactoring">refaktorering</a>. Alltså hur vi kan uttrycka samma sak på "bättre" sätt.</p><h3>Inkludera filer</h3><p>De flesta <em>server-side</em>-språk har ett sätt att inkludera innehållet av en fil i en annan. Detta är ett ypperligt sätt att undvika duplicering av kod. Föreställ dig att vi bygger en blogg. Vi har (t.ex.) en sida som listar alla inlägg, och vi har en sida per specifikt inlägg. Båda dessa sidor behöver göra <em>queries</em> till databasen och således behöver alltså båda sidorna sätta upp en databaskoppling. De två frågorna vi vill ställa databasen är olika, men just själva uppsättandet av databaskopplingen kommer vara exakt likadan.</p><!-- TODO: Länka kommentaren om databaskoppling till php-delen som förklarar hur man gör en databaskoppling.--><p>Duplicerad kod kan alltid tolkas som en varningssignal för att vi antagligen behöver refaktorera och generalisera. Låt oss kort reflektera över varför duplicerad kod är så farligt. Föreställ dig igen ovan nämnt bloggexempel. Anta att vi sätter upp databaskopplingen först i varenda fil som behöver komma åt databasen. Säg omkring 25 filer. Om vi nu av någon anledning t.ex. behöver byta namn på databasen. Då behöver vi ändra databaskopplingen i alla dessa 25 filer. Trivialt kan tyckas. Men anta att det är 125 filer. Eller 1025 filer. Anta att vi bara ändrar i 24 filer och glömmer en. Anta att vi glömmer att kolla att just den sidan fungerar. Då har vi helt plötsligt "haft sönder" vår applikation utan att ens veta om det. Duplicerad kod är farlig kod. <a href="http://en.wikipedia.org/wiki/Code_smell">Duplicerad kod luktar illa</a>.</p><p>Låt oss återgå till idéen om att inkludera innehållet av en fil i en annan fil. Konceptet kan egentligen liknas vid att bryta ut ett gäng rader kod till en metod. När vi märker att vi har duplicerat kod så bryter vi ut den duplicerade koden till en metod och anropar istället metoden på de båda ställena. Om vi i <code>php</code> märker att vi har duplicerat kod emellan två filer, så bryter vi ut den duplicerade koden till en separat fil och inkluderar istället den filen i de andra två. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi skulle kunna använda <code>include</code> i <code>php</code>.</div><div class="panel-body"><p>Anta att vi har byggt en blogg. Anta att vi har två sidor. Där den ena listar alla inlägg och den visar ett specifikt inlägg. Så i filen som listar alla inlägg har vi någonting i stil med nedan:</p><pre><code class="language-php">/* list_all_posts.php */
 
$link   = mysqli_connect("host","user","pwd","db") or die("Error " . mysqli_error($link));
$query  = "SELECT * FROM posts";
$result = $link->query($query) or die("Query error: " . mysqli_error($link));
...</code></pre><p>Och i filen som visar ett specifikt inlägg har vi någonting typ nedan:</p><pre><code class="language-php">/* show_single_post.php */
 
$link   = mysqli_connect("host","user","pwd","db") or die("Error " . mysqli_error($link));
$query  = "SELECT * FROM posts WHERE id='.$post_id.'";
$result = $link->query($query) or die("Query error: " . mysqli_error($link));
...</code></pre><p>Jämför de två kodexemplena med varandra en stund. Uppenbart har vi en hel del duplikation. Låt oss naivt flytta över själva databaskopplingen.</p><pre><code class="language-php">/* db_connect.php */
$link   = mysqli_connect("host","user","pwd","db") or die("Error " . mysqli_error($link));</code></pre><pre><code class="language-php">/* list_all_posts.php */
 
include 'db_connect.php';
$query  = "SELECT * FROM posts";
$result = $link->query($query) or die("Query error: " . mysqli_error($link));</code></pre><pre><code class="language-php">/* show_single_post.php */
 
include 'db_connect.php';
$query  = "SELECT * FROM posts WHERE id='.$post_id.'";
$result = $link->query($query) or die("Query error: " . mysqli_error($link));</code></pre><p>Lite bättre. Men om vi kombinerar inkluderingsstrategin tillsammans med att bryta ut metoder kan vi förstås göra det ännu bättre.</p><pre><code class="language-php">/* db_functions.php */
 
function db_connect(){
  $link = mysqli_connect("host","user","pwd","db") or die("Error " . mysqli_error($link));
  return $link;
}
 
function db_query($query){
  $link = db_connect();
  return $link->query($query) or die("Query error: " . mysqli_error($link));
}</code></pre><pre><code class="language-php">/* list_all_posts.php */
 
include 'db_connect.php';
$result = db_query("SELECT * FROM posts");</code></pre><pre><code class="language-php">/* show_single_post.php */
 
include 'db_connect.php';
$result = db_query("SELECT * FROM posts WHERE id='.$post_id.'");</code></pre><p>Mycket bättre :) Poängen här är alltså att vi har generaliserat och brytit ut vanligt förekommande kod till metoder.</p><!-- TODO: The db connection is never closed, and new ones always created so the example might need some tweaking to not be misleading.--><p>Om vi även skulle introducera objektorienterad programmering så skulle vi kunna snygga upp kod ännu ytterligare. Då skulle vi kunna låta <code>db_connect</code>-filen innehålla en klass istället för ett gäng globalt exponerade funktioner. Låt oss kika på ett exempel på hur vi skulle kunna gå tillväga:</p><pre><code class="language-php">/* db.php */
 
class Database{
  function __construct(){
    $this->db = mysqli_connect("host","user","pwd","db");
    if ($this->db->connect_error) {
      $code  = $mysqli->connect_errno;
      die("Error: ($code) $this->conncetion->connect_error");
    }
  }
  
  public function query($sql){
    return $this->db->query($sql)
      or die("Query error: " . $this->db->error;
  }
}</code></pre><pre><code class="language-php">/* list_all_posts.php */
 
include 'db.php';
$db = new Database();
$result = $db->query("SELECT * FROM posts");</code></pre><pre><code class="language-php">/* show_single_post.php */
 
include 'db.php';
$db = new Database();
$result = $db->query("SELECT * FROM posts WHERE id='.$post_id.'");</code></pre><p>I detta sista exempel får vi även en "win" genom att det nu blir omöjligt att exekvera den metod vi skrivit som kör queries emot databasen, utan att vi först upprättat en koppling till databasen. Hur? Jo eftersom vår <code>query</code>-metod nu är en instansmetod på <code>Database</code>-objektet. Och eftersom klassens konstruktor upprättar en koppling till databasen, och eftersom det är omöjligt att instantiera objektet utan att konstruktorn körs så kan vi helt enkelt vara säkra på att det redan finns en databaskoppling när vi anropar <code>query</code>-metoden.</p><p>Så här kan vi fortsätta och fortsätta. Vi kan nästan alltid refaktorera vidare kod. Det är t.ex. lite lustigt att vi har hårdkodat databasens "användaruppgifter" direkt i databasklassens konstruktur. Försök alltid att hitta nackdelar med din egen kod, och sök efter refaktoreringar så kommer du med tiden skriva bättre och bättre kod. Och om du är mer intresserad så kan du läsa böcker om refaktorering såsom t.ex. <a href="http://martinfowler.com/books/refactoring.html">Refactoring &mdash; av Martin Fowler</a>.</p></div></div><p>Det kan tyckas konstigt att ovan exempel skulle vara någonting smart. Vi gick ifrån mindre kod och färre filer till mer kod och fler filer. Men faktum är att <em>rader kod</em> är ett mycket dåligt mått på en kodbas komplexitet. Eller som Bill Gates uttryckte det &mdash; <span class="quote"><a href="http://c2.com/cgi/wiki?LinesOfCode">"Measuring software productivity by lines of code is like measuring progress on an airplane by how much it weighs"</a></span>.</p><p>Låt oss istället, i relation till ovan exempel, kontemplera hur redo vi är på att reagera på inkommande förändringskrav. Om vi nu t.ex. skulle vilja döpa om databasen behöver vi bara göra det på en plats, oavsett hur många filer vi har som kopplar till databasen. Om vi skulle vilja förändra felhanteringen om en query misslyckas behöver vi bara göra det på ett ställe. Eller felhanteringen för om själva databaskopplingen misslyckas.</p><p>Om vi skulle hamna i en situation då vi skulle vilja byta databas, till någonting annat än <code>mysql</code> så är vi <em>mer</em> beredda än tidigare &mdash; men vi har fortfarande en lång väg att gå. För att hantera den typen av scenarion måste vi gå längre. Ett mycket vanligt tillvägagångssätt är att skriva egna eller använda sig av befintliga ORM:er (<a href="http://en.wikipedia.org/wiki/Object-relational_mapping">Object Relational Mapping</a>). En ORM är helt enkelt kod som skapar ett abstraktionslager emellan databasen och vår kod. Så när vi vill ställa frågor (queries) till databasen gör vi det helt i vårt programspråk och aldrig i vårt databasspråk. Det betyder att om vi i framtiden vill byta databas, behöver vi bara förändra vår ORM och inte all vår applikationskod. </p><h4>Inkludera filer med <code>include</code></h4><p>Det finns olika sätt att inkludera filer med <code>php</code>. I ovan exempel använde vi oss utav <code>include</code>. Låt oss repetera syntaxen.</p><div class="panel panel-default"><div class="panel-heading">Att inkludera en annan fil med <code>include</code></div><div class="panel-body"><pre><code class="language-php">include 'some_file.php';
 
// Or using a variable..
 
$filename = 'another_file.php';
include $filename;</code></pre></div></div><p>Om den fil vi försöker inkludera av någon anledning inte går att hitta, kommer <code>php</code> att spotta ur sig en <code>warning</code> såsom nedan.</p><pre><code class="language-php">Warning: include(non_existent_file.php): failed to open stream: No such file or directory in /www/syntax.php on line 5
Warning: include(): Failed opening 'non_existent_file.php' for inclusion (include_path='.:') in /www/syntax.php on line 5</code></pre><p>Det viktiga att förstå är att en varning <strong>inte</strong> avbryter exekveringen. Med andra ord &mdash; om en fil inte hittas kommer först en varning att spottas ut på sidan med sedan kommer resten av filen ändå exekveras precis som vanligt. Detta betyder att just konstruktionen <code>include</code> faktiskt <a href="http://stackoverflow.com/questions/3633900/difference-between-include-and-require-in-php">inte lämpar sig för applikationskritiska inkluderingar</a>. Såsom databaskopplingen ovan, eller autentisering av användare. Låt oss nu diskutera några andra alternativ...</p><h4>Inkludera filer med <code>require</code></h4><p>Ett annat alternativ vi kan använda för att inkludera filer är konsturktionen <code>require</code>. Till skillnad ifrån <code>include</code> så orsakar inte denna metod en <code>warning</code> om det skulle vara så att den inte lyckas ladda en fil. Istället orsakar den ett <code>fatal error</code>. Detta avbryter exekveringen. Alltså kommer ingen kod efter den misslyckade <code>require</code>:en att köras.</p><p>Således är <code>require</code> ett bättre sätt att inkludera applikationskritiska filer, än <code>include</code>. Föreställ dig t.ex. att alla sidor som kräver inloggning inkluderar en fil som heter <code>authorize.php</code>. I det fallet förlitar vi oss på att autentiseringsfilen omdirigerar användaren bort ifrån sidan den försöker komma åt. Anta att vi skulle använda <code>include</code> för att inkludera filen <code>authorize.php</code>. Om det av någon anledning skulle vara så att <code>php</code> inte lyckas få tag på filen så skulle vår sida som kräver inloggning inte längre vara skyddad. Eftersom exekveringen fortsätter trots att vi inte lyckats hämta filen som ska autentisera användaren.</p><p>Syntaxmässigt så används <code>require</code> på samma sätt som <code>include</code>. Alltså:</p><div class="panel panel-default"><div class="panel-heading">Att inkludera en annan fil med <code>require</code></div><div class="panel-body"><pre><code class="language-php">require 'some_file.php';
 
// Or using a variable..
 
$filename = 'another_file.php';
require $filename;</code></pre></div></div><pre><code class="language-php">Warning: require(non_existent_file.php): failed to open stream: No such file or directory in /www/syntax.php on line 5
Fatal error: require(): Failed opening required 'non_existent_file.php' (include_path='.:') in /www/syntax.php on line 5</code></pre><h4>Inkludera filer med <code>require_once</code></h4><p>Det sista alternativet för att inkludera filer i filer som vi ska kika på är <code>require_once</code>. Denna konstruktion beteer sig egentligen precis som sin syster <code>require</code>. Den viktiga skillnaden är dock att <code>require_once</code> håller koll på om en fil tidigare har laddats in. Med andra ord laddas en fil endast in en gång när vi använder <code>require_once</code>. Ett exempel gör det rimligen tydligare.</p><div class="panel panel-default"><div class="panel-heading">Exempel på skillnaden emellan <code>require</code> och <code>require_once</code>.</div><div class="panel-body"><p>Anta att vi har följande fil.</p><pre><code class="language-php">/* hello.php */
echo 'hello ';</code></pre><p>Låt oss använda en <code>for</code>-loop för att inkludera samma fil tre gånger. Om vi använder oss av <code>require</code> eller <code>include</code> får vi följande resultat:</p><pre><code class="language-php">for($i=0; $i<3; $i++){="" require="" 'hello.php'="" ;="" }<="" code=""></3;></code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>hello hello hello</p></div></div><p>Men om vi kör samma <code>for</code>-loop men istället använder oss av <code>require_once</code> så får vi följande resultat:</p><pre><code class="language-php">for($i=0; $i<3; $i++){="" require_once="" 'hello.php'="" ;="" }<="" code=""></3;></code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>hello </p></div></div></div></div><h3>Strategier för att bädda in <code>html</code></h3><p>Eftersom vi pratar om att använda <code>php</code> till att skapa webbsidor så behöver vi förstås blanda <code>html</code> och <code>php</code>. Något vi tidigare diskuterat är idéen om <a href="http://en.wikipedia.org/wiki/Separation_of_presentation_and_content">separera presentation och content</a>. Då i relation till ansvarsskillnader mellan <code>html</code> och <code>css</code>. Ett annat vanligt idiom inom programmering är <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>. Det är en mer generell idé än den om just behovet av att separera presentation ifrån content. När vi nu använder ett kraftfullare skriptspråk, såsom <code>php</code>, kommer vi plötsligt ha en mängd nya "concerns". T.ex. <a href="http://en.wikipedia.org/wiki/Business_logic">Business logic</a> (affärslogik) och databaslogik. Om vi ska respektera idéen om att separera concerns så behöver vi alltså hitta strategier för att separera t.ex. affärslogik ifrån presentation.</p><p>Låt oss först prata om varför det är viktigt att separera olika "concerns". Kom ihåg tidigare diskussion om att vi behöver sikta på en hög nivå av beredskap inför förändring. Vår applikation behöver vara lätt att förändra. Så när (ps: vi väljer medvetet ordet <em>när</em> och inte <em>om</em>) vi väl behöver utföra en förändring löper vi inte risken att behöva koda om hela systemet ifrån grunden. Föreställ dig t.ex. att vi utvecklar en webbshop. Anta att vi har listat shoppens produkterna på listform. Anta nu att vi får in ett nytt krav på att även kunna presentera produkterna som ett rutnät. Jahapp tänker vi, och börjar kika på koden. Om vår databaskod då är beblandad med vår presentationskod så kommer förändringen bli mycket dyrare än om de är ordentligt separerade.</p><p>Utan att gräva ned oss i det här för mycket så kan vi säga att det finns en uppsjö av <a href="http://en.wikipedia.org/wiki/Software_design_pattern">design patterns</a> &mdash; alltså dokumenterade kodstruktureringsstrategier &mdash; som syftar just till att angripa denna typ av problem. Men det får vi diskutera på djupet en annan gång. Vad vi vill belysa i detta kapitel är hur det går att identifiera två vanliga strategier utvecklare använder för att "blanda" <code>html</code> och <code>php</code>. Antingen så...<ul><li>skriver vi <code>php</code> och <code>echo</code>:ar <code>html</code>,</li><li>eller så skriver vi <code>html</code> och lägger in små block av <code>php</code></li></ul></p><div class="panel panel-default"><div class="panel-heading">Exempel på de två huvudsakliga strategierna för att blanda <code>php</code> och <code>html</code>.</div><div class="panel-body"><p>Om vi hela tiden <code>echo</code>/<code>print</code>:ar ut <code>html</code> blir det lätt att få sig en uppfattning om det "logiska" flödet i programmet, men mycket svårt med det visuella. Vid första anblick skulle vi argumentera att det inte är solklart vad nedan program gör.</p><pre><code class="language-php">&lt;?php
  $name   = "John";
  $number = "070 123 45 67";
  echo "&lt;h1&gt;Hello, $name ($number).&lt;/h1&gt;";
  echo "&lt;ul&gt;";
  for($i=0; $i<3; $i++){="" echo="" "&lt;li&gt;missed="" call="" ($i).&lt;="" li&gt;"="" }="" "&lt;="" ul&gt;"="" ?&gt;<="" code=""></3;></code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Hello, John (070 123 45 67)</p><p>Missed call (1).</p><p>Missed call (2).</p><p>Missed call (3).</p></div></div><p>Således är det ofta bättre att försöka hålla de filer som arbetar med <code>html</code> fokuserade på just det &mdash; <code>html</code>. Och istället se det som att <code>php</code> kommer in i små korta svängar &mdash; antingen för att kontrollera programflödet eller hålla variabel data. Låt oss se hur det skulle kunna se ut.</p><pre><code class="language-php">&lt;?
  $name   = "John";
  $number = "070 123 45 67";
?&gt;
 
&lt;p&gt;Hello, &lt;?=$name?&gt; (&lt;?=$number?&gt;)&lt;/p&gt;
 
&lt;? for($i=0; $i<3; $++):="" ?&gt;="" &lt;p&gt;missed="" call="" (&lt;?="$i?&gt;)&lt;/p&gt;" &lt;?="" endfor;?&gt;<="" code=""></3;></code></pre><p>Denna andra strategi har den mycket positiva effekten att vi även kan indentera vår <code>html</code>. Och vi skulle argumentera för att just denna indentering verkligen hjälper till att öka kodens läsbarhet.</p></div></div><h4>Kolon-varianter</h4><p>Som du kanske märkte använde vi i ovan en alternativ syntax för konstruktionen <code>for</code>. Låt oss kalla dessa för "kolon-varianter". Det finns några grundläggande konstruktioner i <code>php</code> som har just sådana här kolon-motsvarigheter. Varför de som skapade språket valt att implementera dessa kan vi inte svara på &mdash; men det kan vara rimligt att anta att även de insåg att det snabbt blir problematiskt när vi försöker blanda <code>php</code> och något annat språk.</p><p>Med hjälp av dessa kolon-varianter kan vi istället skriva våra dokument som om de var skrivna i just det språket vi vill nå som output. I vårat fall alltså <code>html</code>. Sedan kan vi strategiskt placera ett antal <code>php</code>-kommandon som kontrollerar applikationsflödet. Låt oss se till några exempel på konstruktioner som har kolon-motsvarigheter.</p><table class="table table-condensed table striped"><tr><th>Konstruktion</th><th>Kolon-motsvarighet</th></tr><tr><td><pre><code class="language-php">for(..){
  ..
}</code></pre></td><td><pre><code class="language-php">for(..):
  ..
endif;</code></pre></td></tr><tr><td><pre><code class="language-php">foreach(..){
  ..
}</code></pre></td><td><pre><code class="language-php">foreach(..):
  ..
endforeach;</code></pre></td></tr><tr><td><pre><code class="language-php">while(..){
  ..
}</code></pre></td><td><pre><code class="language-php">while(..):
  ..
endwhile;</code></pre></td></tr><tr><td><pre><code class="language-php">if(..){
  ..
}else if(..){
  ..
}else{
  ..
}</code></pre></td><td><pre><code class="language-php">if(..):
  ..
elseif(..):
  ..
else:
  ..
endif;</code></pre></td></tr></table><p>Dessa "kolon-motsvarigheter" är alltså mycket användbara när vi vill blanda <code>html</code> och <code>php</code> eftersom vi kan "bryta upp" våra <code>php</code>-block. Beakta följande exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på varför vi behöver kolon-motsvarigheterna i <code>php</code></div><div class="panel-body"><p>Detta fungerar ej...</p><pre><code class="language-php">&lt;? if(someCondition){ ?&gt;
  &lt;p&gt;Then display this text&lt;/p&gt;
&lt;? } ?&gt;</code></pre><p>Men detta fungerar...</p><pre><code class="language-php">&lt;? if(someCondition): ?&gt;
  &lt;p&gt;Then display this text&lt;/p&gt;
&lt;? endif; ?&gt;</code></pre></div></div><p>Nu säger vi förstås inte att alla måste prioritera att använda "kolon-versionerna". Inte heller säger vi att det i alla fallet är det bästa sättet att designa sina <code>php</code>-filer. Men om du inte har en annan medveten strategi du tror på, så skulle vi rösta för att du följer ovan.</p><h3>Design patterns</h3><p>Det finns som sagt en uppsjö av design patterns som hjälper oss att strukturera kod på sätt som gör att vi kan öka nivån av kontroll över vår kod. Ett mycket vanligt design pattern för webben idag är <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC (Model View Controller)</a>. Det finns även en uppsjö av variationer av det pattern:et som generellt brukar refereras till som MV* (e.g. Model View Viewmodel, etc.).</p><p>Det är för tidigt att gräva in oss i design patterns nu. Men för att du ska ha något att luta dig på när du designar dina applikationer skulle vi vilja föreslå följande strategi:</p><div class="well"><p>Se till att de sidor som agerar "entry-points" (i.e. den fil som du pekar webbläsaren till) är så absolut enkla som möjligt. Låt de filerna istället inkludera andra filer. Och delegera komplext arbete till de inkluderade filerna. Säg att du t.ex. har fått en mängd data, som motsvarar en blogpost, och ska spara den i en databas. Istället för att processa och spara datat direkt i "entry-point"-filen &mdash; inkludera en annan fil som du t.ex. kallar <code>process_post.php</code>. Låt den filen deklarera en metod som t.ex. heter <code>process_post($post_data)</code>. Om den metoden istället utför allt det komplexa processnings, och sparningsarbetet så kommer "entry-point"-filen helt enkelt bara behöva anropa den metoden med relevant data som argument. Detta är alltså samma strategi som vi använde för att illustrera <code>include</code> i första exemplet i detta kapitel.</p></div><p>Om du vill ha ännu mer struktur men ändå inte är redo för komplexare patterns, skulle vi rekommendera att du kikar lite på <a href="http://www.phptherightway.com/pages/Design-Patterns.html">Front Controller Pattern</a>.</p><h2 href="#08-07-php-ajax" name="08-07-php-ajax" id="08-07-php-ajax">AJAX och PHP</h2><p>AJAX (Asynkron JavaScript och XML) är ett samlingsnamn som innefattar flera olika tekniker för att kunna uppdatera en sida utan att ladda om hela sidan. Detta kan vara praktiskt då vi kan behöva göra något på servern utan att störa användaren genom att behöva vänta på att sidan laddas om. De tekniker som används i samband med AJAX är:</p><p><code>XMLHttpRequest </code> är ett API för att kunna överföra och ta emot XML mellan server och klienten. </p><p><code>DOM </code> (Document Object Model) gör att vi tillåts med javascript ändra i dokumentet.</p><p><code>HTML</code> och <code>CSS</code> hur sidan representeras och vad som finns på sidan.</p><p><code> XML </code> som ibland används för att transportera och strukturera data. </p><p><code> Javascript </code> programmeringspråk.</p><p>Det går att använda AJAX med annat än php (exemepelvis ASP) men vi har gjort ett val att använda php. Egentligen skulle vi också kunna använda oss av javascript för att göra asynkrona anrop men eftersom det redan finns någon som abstraherat bort komplexitet så är det lika bra att utnyttja det, jQuery! Detta innebär att vi gör ett aktivt val att inte gå djupare i de nämnda teknikerna utan att vi "slutar jiddrar och börjar trolla".</p><h3>jQuery´s get()</h3><div class="panel panel-default"><div class="panel-heading">Ändra innehåll med utan att ladda om sidan med jQuery.</div><div class="panel-body"><pre><code class="language-php">$("button").click(function(){
 $.get("test.php",function(data,status){
 $( ".result" ).html( data );
 });
});</code></pre><div class="panel panel-default"></div></div></div><p>Som ni ser har vi på en knapp som vid ett knapptryck gör ett HTTP GET request till servern. Innan vi börjar gå igenom i detaljom vad som händer kan det vara en god idé att se den sidan som vi efterfrågar, alltså test.php.</p><div class="panel panel-default"><div class="panel-heading">Sidan som efterfrågas </div><div class="panel-body"><pre><code class="language-php">&lt;?php
  echo "Hello med AJAX";
?&gt;</code></pre><div class="panel panel-default"></div></div></div><p>jQuery´s get tar emot två argument (1) URL:en till vilken sida som efterfrågas (2) en callback, alltså vad som skall göras 
när requesten är klar. Det kan ibland finnas tillfällen då vi vill skicka med information till servern för att göra något med 
datat, exempelvis lägga in eller hämta något från en databas. Att skicka med argument görs med <code> { name:"Me", lname:"Myself" } </code>. 
Det skickas med som ett andra argument i functionen get().</p><h3>jQuery get() med parametrar </h3><div class="panel panel-default"><div class="panel-heading">Sidan som efterfrågas </div><div class="panel-body"><pre><code class="language-php">$("button").click(function(){
  $.get("test.php",
  {
    name:"Me",
    lname:"Myself"
  },
  function(data,status){
   alert("Lyssna på vad sidan säger dig!"");
  });
});</code></pre><div class="panel panel-default"></div></div></div><p>php test ser nu ut som denna: </p><div class="panel panel-default"><div class="panel-heading">Sidan som efterfrågas </div><div class="panel-body"><pre><code class="language-php">&lt;?php
  $fname ,city
  $fname= $_GET["name"]
  $lname= $_GET["lname"]
  echo "kära" . $fname . $lname . "du duger!";
?&gt;</code></pre><div class="panel panel-default"></div></div></div><h3>jQuery´s load()</h3><p>jQurey´s load method är ganska lika get men den har en implicit callbackfunktion som gör det möjligt att kunna skriva:</p><code>$("#result").load("test.php"); </code> och det som händer är att den själv fyller på elementet med innehållet. Man kan även skicka med 
en ytterligare callbackfunktion och då kommer det köras EFTER det matchande elementet har fyllts på med innehållet från test.php.<div class="panel panel-default"><div class="panel-heading">Load() med callback.</div><div class="panel-body"><pre><code class="language-php">$( "#result" ).load( "test.php", function() {
alert( "Success!" );
});</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"></div></div></div></div><p>Att jobba med asynkrona anrop är kraftfullt och bör vara en viktig kunskap i verktygslådan som webbutvecklare. </p><h1 href="#09-00-mysql-intro" name="09-00-mysql-intro" id="09-00-mysql-intro">MySQL</h1><p class="lead">Dags att snacka databaser! Vad vore väl en interaktiv applikation om vi inte kunde spara någon information? Vad vore en webbshop om vi inte kunde ta emot ordrar, eller lagra produkter. Vad vore webben utan data?</p><p>Som du kanske märkt så är det en del grundidéer och -idiom som konstant återkommer. En av dessa mycket, mycket viktiga idiom är den tidigare diskuterade &mdash; <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>. Även gällande databaser kan vi börja diskutera "separation of concerns". Idéen om databaser bygger ju nämligen på att en applikation och den data en applikation använder, inte är samma sak. Sjävklart egentligen. Men bara för att något är självklart betyder det inte att det alltid har varit enkelt.</p><p>Låt oss tänka på det. Data och applikationer är inte samma sak. Eller kanske kan vi uttrycka oss i termer av att data och processer inte är samma sak. Om vi ser applikationer som formaliserade processer. Steg för steg. Så är alltså inte data och processer inte samma sak. Jag tror inte vi behöver understryka detta mera utan förhoppningsvis finner du det förhållandevis naturligt.</p><p>För att en data ska vara agnostisk ifrån sin applikation så krävs det dels att vi (1) har någon form av formaliserad standard för hur data ska lagras. Eftersom datat någonstans måste skrivas till disk eller minne så behöver vi ett strukturerat format att spara det i. Sedan behöver vi förstås även (2) ett sätt att interagera med denna data, eller snarare denna databas. Detta är vad vi vanligtvis benämner som en <a href="http://en.wikipedia.org/wiki/Database">DBMS (Database Management System)</a>.</p><p>I fallet som vi kommer arbeta med, så är vår DBMS <a href="http://en.wikipedia.org/wiki/MySQL">MySQL</a> och vår databas är en <a href="http://en.wikipedia.org/wiki/Relational_database_management_system">relationsdatabas</a>. Språket vi använder för att kommunicera med DBMS:en är <a href="http://en.wikipedia.org/wiki/SQL">SQL (Structured Query Language)</a>.</p><p>Det finns egentligen ingenting som säger att språket vi använder för att kommunicera med en viss DBMS måste vara ett annat än det vi skriver vår applikation i. Visst, med språket <code>sql</code> så kan vi ju omöjligen skriva ett helt program. Eftersom språket just är ett språk designat för att ställa frågor till en relationsdatabas. Men däremot finns det många DBMS:ar som går att interagera med i samma språk som de är tänkta att användas i.</p><!-- TODO: EXEMPEL!!!--><h2 href="#09-01-mysql-installation" name="09-01-mysql-installation" id="09-01-mysql-installation">Kom igång med MySQL</h2><p>Kommer snart...</p><h2 href="#09-02-mysql-syntax" name="09-02-mysql-syntax" id="09-02-mysql-syntax">MySQL syntax</h2><p class="lead">Även om vi förväntar oss att du har en viss erfarenhet av <code>sql</code> sedan tidigare, så tänkte vi att vi tar en snabb återblick här.</p><h3>Tabeller</h3><p>Kommer snart...</p><h3>Data</h3><p>Kommer snart...</p><h2 href="#09-03-mysql-api" name="09-03-mysql-api" id="09-03-mysql-api">MySQL PHP API</h2><p class="lead">Nu är det dags att knyta ihop säcken lite och diskutera hur vi kan använda <code>php</code> för att arbeta emot en <code>mysql</code>-databas. Vi ska alltså prata om det <a href="http://en.wikipedia.org/wiki/Application_programming_interface">API</a> som <code>php</code> erbjuder för att intergagera med <code>MySQL</code>.</p><p>Om det inte redan är självklart varför vi skulle vilja göra detta &mdash; låt oss iterera. Om vi ifrån vår <code>php</code>-applikation kan koppla till en <code>mysql</code>-databas så innebär detta att vi kan spara och förändra data i databasen. Självklart är detta essentiellt! Helt plötsligt har vi möjlighet att t.ex. skapa användarkonton. Genom att lagra e-post-adresser tillsammans med lösenord. Och när användare sedan ska logga in så jämför vi bara de uppgifter vi får ifrån användaren med de som finns i databasen. Om uppgifterna stämmer med någon användare så kan vi logga in personen. Men du har som sagt säkert redan förstått varför detta är viktigt, så låt oss övergå till hur vi ifrån <code>php</code> kan använda oss utav <code>mysql</code>.</p><h3>Välja API</h3><p>Efter några sökningar på nätet kommer du att märka att när vi letar resurser relaterade till det <code>API</code> som <code>php</code> erbjuder oss för att interagera med <code>mysql</code> &mdash; så hittar vi inte bara en syntax. Istället hittar vi minst tre. Är vi riktigt noga så hittar vi fyra. För att undvika förvirring när du sedan letar information på egen hand så ska vi först bara bena ut vad alla dessa olika syntaxer är och handlar om.</p><p>Först fanns ett API som hette <a href="http://www.php.net/manual/en/book.mysql.php">mysql</a>. Detta finns och fungerar fortfarande. Men <a href="http://www.w3schools.com/php/php_ref_mysqli.asp">med php 5.0.0</a> så kom ett nytt <code>api</code> vid namn <a href="http://www.php.net/manual/en/book.mysqli.php">mysqli</a>. I essens så är detta helt enkelt en uppdaterad version av <code>mysql</code> och det extra "i":et på slutet står för "improved". Således finns det idag egentligen ingen anledning att använda det gamla <code>mysql</code>-api:et när det finns ett nyare. När du surfar omkring i nätdjungeln så kan du lätt avgöra om en metod tillhör det gamla eller det nya api:et genom att helt enkelt läsa namnet på metoden. Alla de gamla metoderna innehåller termen <code>mysql</code>, medan alla de nya innehåller <code>mysqli</code>. Lätt som en plätt! Vi kommer således endast att fokusera på det nyare <code>mysqli</code>.</p><p>Men vi nämnde ju att det fanns tre, och t.o.m. fyra olika API:er. Låt oss förklara. Kanske kommer du ihåg ifrån <code>php</code>-kapitlet att vi diskuterade hur <code>php</code> inte var objektorienterat ifrån början? Men hur det successivt håller på att utvecklas till att stödja mer och mer objektorienterad syntax. Så är det iallafall. Och det speglar även av sig här.</p><p>Det äldre api:et, alltså <code>mysql</code>, är helt procedurellt, och stödjer ingen objektorienterad syntax. Det nyare <code>mysqli</code> stödjer däremot två olika syntaxer. Först en procedurell syntax (som påminner otroligt mycket om det gamla api:et). Men sedan stödjer det även en objektorienterad syntax.</p><p>Eftersom vi på htmlhunden subjektivt tror på objektorientering skulle vi vilja slå ett starkt slag för att du redan ifrån början vänjer dig vid att använda den objektorienterade syntaxen. Men vi kommer att redogöra för båda två i detta kapitel.</p><p>Men vad hände med den fjärde syntaxen då? Jo, det finns ett sätt till. Med <code>php 5</code> så introducerades även någonging som heter <a href="http://en.wikipedia.org/wiki/PHP_Data_Objects">PDO (PHP Data Objects)</a> som i essens är ett abstraktionslager emellan databasen och applikationskoden. För att hålla det så enkelt som möjligt så kommer vi inte att kika någonting på <code>PDO</code> i detta kapitel, men däremot kommer vi att titta lite på att bygga vårt eget abstraktionslager för en databas, i ett kommande kapitel :)</p><h3>Ansluta till databasen</h3><p>Innan vi kan börja ställa frågor till databasen behöver vi ansluta till den. Detta skulle kunna jämföras med att logga in till en host genom <a href="http://en.wikipedia.org/wiki/PhpMyAdmin">phpMyAdmin</a>, <a href="http://en.wikipedia.org/wiki/MySQL_Workbench">MySQL Workbench</a>, genom en terminal (eller någon annan mysql klient). Men när vi kopplar upp till <code>mysql</code> via <code>php</code> så väljer vi även databasschema. Vilket kan jämföras med att köra <code>sql</code>-kommandot <code>USE name_of_db;</code>, eller att helt enkelt välja en databas/ett schema i något av de tidigare nämnda grafiska klienterna.</p><p>Så, låt oss se till ett faktiskt exempel. Viktigt att notera är alltså att vi i båda lagrar resultatet av evalueringen i en variabel. Vi får alltså tillbaka en instans av <code>mysqli</code>. Som alltså motsvarar en uppkoppling till vår databas. Läs mer om att sätta upp en koppling <a href="http://www.php.net/manual/en/mysqli.construct.php">i manualen</a>.</p><div class="panel panel-default"><div class="panel-heading">Öppna koppling till mysql-databas.</div><div class="panel-body"><p>OOP syntax.<pre><code class="language-php">$mysqli = new mysqli('host', 'user', 'password', 'database');</code></pre></p><p>Procedurell syntax.<pre><code class="language-php">$mysqli = mysqli_connect('host', 'user', 'password', 'database');</code></pre></p></div></div><p>Låt oss även snabbt se till hur vi skulle kunna hantera eventuella fel som kan uppstå när vi försöker koppla upp oss till databasen. Om vi t.ex. råkat ange fel lösenord, eller inte har läsrättigheter till den databas vi försöker koppla till med den användaren vi angett, eller om datbasen helt enkelt inte existerar (o.s.v.).</p><div class="panel panel-default"><div class="panel-heading">Felhantering vid öppning av koppling till mysql-databas.</div><div class="panel-body"><p>OOP syntax.<pre><code class="language-php">$error = $mysqli->connect_error;
if ($error) {
  $code  = $mysqli->connect_errno;
  die("Error: ($code) $error");
}</code></pre></p><p>Procedurell syntax.<pre><code class="language-php">$error = mysqli_connect_error();
if ($error) {
  $code  = mysqli_connect_errno();
  die("Error: ($code) $error");
}</code></pre></p></div></div><p>Notera i ovan exempel att vi alltid har tillgång till både själva felmeddelandet som sträng (<a href="http://www.php.net/manual/en/mysqli.connect-error.php">conect_error</a>), men även dess felkod (<a href="http://www.php.net/manual/en/mysqli.connect-errno.php">connect_errno</a>).</p><p>Notera också att den jämförelse vi gör för att upptäcka om ett fel har inträffat eller inte sker genom att vi helt enkelt slänger in den sträng som potentiellt innehåller ett felmeddelande. Om vi läser <a href="http://www.php.net/manual/en/mysqli.connect-error.php">dokumentationen för metoden</a> så ser vi att den returnerar <code>null</code> om inget fel har inträffat och en sträng innehållandes ett felmeddelande om ett fel har inträffat. Detta är en av styrkorna med dynamiska språk. Vi kan returnera helt olika saker utan att i förväg bestämma oss. Men det finns en anledning till att detta fungerar &mdash; nämligen att jämförelsen <code>(null == true)</code> evaluerar till <code>false</code> i <code>php</code>. En sträng däremot, evaluerar till <code>true</code> så länge den inte är tom eller endast innehåller en nolla (<code>0</code>). Vi behöver alltså inte ens uttrycka vårt boolska uttryck som <code>($error != null)</code>. Återigen, eftersom <code>null</code> i sig evaluerar till <code>false</code>. Och eftersom om vi har fått ett fel så kommer vi ha fått en sträng, och alla strängar utom tom sträng och noll evaluerar till <code>true</code>. Du kan <a href="http://us3.php.net/manual/en/types.comparisons.php">läsa mer om vilka värden som ger <code>true</code> och vilka som ger <code>false</code> här</a>.</p><h3>Exekvera en query</h3><p>När vi väl har en koppling uppe kan vi använda vår variabel som innehåller kopplingen (i.e. <code>mysqli</code>-objektet) för att köra queries emot databasen. Oavsett vi vill skriva en query som ska skapa en tabell, lägga in en ny rad, uppdatera en existerande, förändra en kolumn eller någonting helt annat &mdash; så kan vi använda samma metod. Nämligen <code>mysqli->query($sql)</code>. Låt oss se till ett par exempel.</p><div class="panel panel-default"><div class="panel-heading">Köra queries emot en existerande databaskoppling.</div><div class="panel-body"><p>OOP syntax.<pre><code class="language-php">$result = $mysqli->query("SELECT *  FROM posts");
 
if ($result) {
  echo "Number of rows: " . $result->num_rows;
}</code></pre></p><p>Procedurell syntax.<pre><code class="language-php">$result = $mysqli->query("SELECT * FROM posts")
 
if ($result) {
  echo "Number of rows: " . mysqli_num_rows($result);
}</code></pre></p></div></div><p>Det mest intressanta med denna <code>php</code>-metod är att den returnerar olika typer av saker beroende på vad vi kör för query. <a href="http://se1.php.net/mysqli_query">Detta denoteras genom returtypen <code>mixed</code> i dokumentationen</a>. Om vi t.ex. skulle köra en <code>INSERT INTO</code> får vi en bool tillbaka som innehåller <code>true</code> om query:n lyckades och <code>false</code> om den ej gjorde det. Faktum är att vi i alla fall får tillbaka en bool som säger <code>false</code> om en query misslyckas p.g.a. t.ex. fel syntax eller en icke-existerande kolumn.</p><p>Om vi däremot t.ex. skulle köra query:n <code>SELECT * FROM users</code>. Så får vi tillbaka ett objekt av typen <code>mysqli_result</code>. Så länge vår query är en valid query får vi den typen av resultat tillbaka. Även om det skulle vara så att den inte hittade några rader alls. I ovan kodexempel är det just den typen av ett objekt vi får tillbaka, och det är således därför vi kan fråga objektet om dess antal rader.</p><h3>Läsa resultatet</h3><p>Om du skrivit och exekverat en query som returnerar ett <code>mysqli_result</code> så kan du inte direkt enumerera över datan. Det finns två enkla sätt. Antingen så använder du en <code>while</code>-loop och snurrar över varje rad i resultatset:et en för en. Detta gör du med hjälp av metoden <a href="http://www.php.net/manual/en/mysqli-result.fetch-row.php">$result->fetch_row()</a> eller <a href="http://www.php.net/manual/en/mysqli-result.fetch-assoc.php">$result->fetch_assoc()</a>. Eller så hämtar du helt enkelt alla rader på en gång så att du kan lagra resultatet i en array. Detta gör du genom <a href="http://www.php.net/manual/en/mysqli-result.fetch-all.php">$result->fetch_all()</a>. Det senare kan ju förstås vara smidigt om du inte vill använda resultatet på en gång utan snarare skicka det vidare. Låt oss se till ett par användningsexempel. Vi börjar med att iterera och hämta rad för rad.</p><div class="panel panel-default"><div class="panel-heading">Iterera över data ifrån ett resultat-set och hämta varje rad som en numrerad array.</div><div class="panel-body"><p>OOP syntax.<pre><code class="language-php">// Iterates over each row (into $row) as a numeric array
while($row = $result->fetch_row()){
  var_dump($row);
}
 
// But we could also iterate over each row as an associative array
while($row = $result->fetch_assoc()){
  var_dump($row);
}</code></pre></p><p>Procedurell syntax.<pre><code class="language-php">// Iterates over each row (into $row) as a numeric array
while($row = mysqli_fetch_row($result)){
  var_dump($row);
}
 
// But we could also iterate over each row as an associative array
while($row = mysqli_fetch_assoc($result)){
  var_dump($row);
}</code></pre></p></div></div><p>I de fall där vi hämtar varje rad som en associativ array så innebär det att varje rads nycklar motsvarar namnet på databasens kolumner. I de numeriska fallen så når vi helt enkelt argumenten i samma ordning som de är definierade i datbasen.</p><p>Men som sagt, vi kan ju, som tidigare nämnt, även hämta alla rader på en gång och slänga in de i en array. Vilket ju kan vara smidigt om vi inte vill iterera över resultatet än. Detta kan vi göra genom att använda oss av <a href="http://www.php.net/manual/en/mysqli-result.fetch-all.php">$result-fetch_all()</a>. Denna metod tar även ytterligare en valfri parameter. Denna parameter ska vara en konstant som berättar om vi vill ha resultatet som en numrerad array (<code>MYSQLI_NUM</code>), eller en associativ array (<code>MYSQLI_ASSOC</code>). Om inget värde anges så är "default" numerisk. Låt oss kika på några exempel.</p><div class="panel panel-default"><div class="panel-heading">Hämta data ifrån ett resultat-set som array direkt.</div><div class="panel-body"><p>OOP syntax.<pre><code class="language-php">// As numbered array
$arr = $result->fetch_all();
 
// Or as an associative array
$arr = $result->fetch_all(MYSQLI_ASSOC);</code></pre></p><p>Procedurell syntax.<pre><code class="language-php">// As numbered array
$arr = mysqli_fetch_all($result);
 
// Or as an associative array
$arr = mysqli_fetch_all($result, MYSQLI_ASSOC);</code></pre></p></div></div><h2 href="#09-04-mysql-abstraction" name="09-04-mysql-abstraction" id="09-04-mysql-abstraction">Databasabstraktion &amp; ORM</h2><p>Kommer snart...</p><h1 href="#30-00-efterord-intro" name="30-00-efterord-intro" id="30-00-efterord-intro">Epilog</h1><div class="page-header"><h2 href="#30-01-efterord-intro" name="30-01-efterord-intro" id="30-01-efterord-intro">Efterord</h2></div><p>HTML-hunden är skriven av <span class="authors"><em class="author">Christopher Okhravi</em> (<a href="http://twitter.com/chrokh" target="_blank">@chrokh</a>) och <em>Madelen Hermelin</em>. Guiden är skriven för att användas under kurser vid <a href="http://www.im.uu.se/" target="_blank">Institutionen för informatik och media</a> under <a href="http://www.uu.se" target="_blank">Uppsala universitet</a> men du är förstås välkommen att använda den vemän du är :) </span></p><p>Projektet har <a href="http://sv.wikipedia.org/wiki/%C3%96ppen_k%C3%A4llkod" target="_blank">öppen källkod</a>, och om du således är intresserad av att bidra på något sätt så välkomnar vi alla tankar, idéer och korrigeringar. Projektet tillsammans med dokumentation finns på <a href="https://github.com/chrokh/htmlhunden" target="_blank">GitHub</a>.</p></div><script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.0.3/js/bootstrap.min.js"></script><script src="/dist/assets/javascripts/jquery.fittext.js"></script><script src="/dist/assets/javascripts/prism.js"></script><script src="/dist/assets/javascripts/main.js"></script></body></html>