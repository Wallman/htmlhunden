<!DOCTYPE html><html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width initial-scale=1.0">
<title>HTMLHunden | En pragmatisk höghastighetsguide till webbutveckling, använd vid Uppsala Universitet</title>
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css">
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css">
<link rel="stylesheet" href="/dist/assets/stylesheets/main.css">
<link rel="stylesheet" href="/dist/assets/stylesheets/prism.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><!-- Feedback tab--><link rel="stylesheet" href="http://getbarometer.s3.amazonaws.com/assets/barometer/css/barometer.css">
<script src="http://getbarometer.s3.amazonaws.com/assets/barometer/javascripts/barometer.js"></script>
<script>BAROMETER.load('zFXKA2467y8YdpZaQK3gq');</script>
<script>
if(document.location.hostname.search("localhost") === -1 && document.location.origin !== "file://"){
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-45465391-1', 'htmlhunden.se');
ga('send', 'pageview');
}
</script>
</head><body id="single"><div id="toc-single" class="toc"><div class="hidden-sm hidden-xs"><img src="/dist/assets/images/logo.png" class="logo-sm"></div><a id="toggle-toc" class="btn btn-lg btn-inverse"><span class="glyphicon glyphicon-align-justify"></span></a><div class="btn-group-vertical toc-list"><a href="#01-00-intro-intro" class="toc-h1 btn btn-menu"><b>1 Introduktion</b></a><a href="#01-01-intro-forord" class="toc-h2 btn btn-menu">1.1 Om denna guide</a><a href="#01-02-intro-quickstart" class="toc-h2 btn btn-menu">1.2 Filer, filformat och webbläsare</a><a href="#01-03-intro-arkitektur" class="toc-h2 btn btn-menu">1.3 Internet, klienter och servrar</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#02-00-html-intro" class="toc-h1 btn btn-menu"><b>2 HTML</b></a><a href="#02-01-html-document-structure" class="toc-h2 btn btn-menu">2.1 Syntax, struktur och första dokumentet</a><a href="#02-02-html-common-elements" class="toc-h2 btn btn-menu">2.2 Vanligt förekommande element</a><a href="#02-03-html-semantic-elements" class="toc-h2 btn btn-menu">2.3 Semantiska element</a><a href="#02-04-html-links" class="toc-h2 btn btn-menu">2.4 Sökvägar och Hyperlänkar</a><a href="#02-09-html-formular" class="toc-h2 btn btn-menu">2.5 Formulär</a><a href="#02-10-html-doctypes" class="toc-h2 btn btn-menu">2.6 Doctypes</a><a href="#02-11-html-encodings" class="toc-h2 btn btn-menu">2.7 Character encoding</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#03-00-css-intro" class="toc-h1 btn btn-menu"><b>3 CSS</b></a><a href="#03-01-css-intro" class="toc-h2 btn btn-menu">3.1 Introduktion till CSS</a><a href="#03-02-css-syntax-och-struktur" class="toc-h2 btn btn-menu">3.2 CSS syntax och struktur</a><a href="#03-03-css-selectorer" class="toc-h2 btn btn-menu">3.3 CSS-selectorer</a><a href="#03-04-css-placering" class="toc-h2 btn btn-menu">3.4 Vart skall jag lägga CSS:en?</a><a href="#03-05-css-cascade" class="toc-h2 btn btn-menu">3.5 Cascading</a><a href="#03-06-css-boxmodell" class="toc-h2 btn btn-menu">3.6 Boxmodellen</a><a href="#03-07-css-positionering" class="toc-h2 btn btn-menu">3.7 CSS Positionering</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#04-00-js-intro" class="toc-h1 btn btn-menu"><b>4 JavaScript</b></a><a href="#04-01-js-intro" class="toc-h2 btn btn-menu">4.1 Introduktion till JavaScript</a><a href="#04-02-js-placering" class="toc-h2 btn btn-menu">4.2 Vart ska jag skriva JavaScript?</a><a href="#04-03-js-variabler" class="toc-h2 btn btn-menu">4.3 Variabler</a><a href="#04-04-js-funktioner" class="toc-h2 btn btn-menu">4.4 Funktioner</a><a href="#04-05-js-dom" class="toc-h2 btn btn-menu">4.5 Document Object Model</a><a href="#04-05-js-events" class="toc-h2 btn btn-menu">4.6 Event listeners</a><a href="#04-05-js-objekt" class="toc-h2 btn btn-menu">4.7 Objekt</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#05-00-oss-intro" class="toc-h1 btn btn-menu"><b>5 Open source</b></a><a href="#05-01-oss-intro" class="toc-h2 btn btn-menu">5.1 Open Source</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#06-00-jquery-intro" class="toc-h1 btn btn-menu"><b>6 jQuery</b></a><a href="#06-01-jquery-intro" class="toc-h2 btn btn-menu">6.1 jQuery snabbstart</a><a href="#06-02-jquery-documentready" class="toc-h2 btn btn-menu">6.2 $(document).ready</a><a href="#06-03-jquery-jqueryobjects" class="toc-h2 btn btn-menu">6.3 Objektet jQuery</a><a href="#06-04-jquery-modify-elements" class="toc-h2 btn btn-menu">6.4 Modifiera element</a><a href="#06-05-jquery-event-listeners" class="toc-h2 btn btn-menu">6.5 Event listeners i jQuery</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#07-00-versioning-intro" class="toc-h1 btn btn-menu"><b>7 Versionshantering (kommer snart)</b></a><a href="#07-01-versioning-whatis" class="toc-h2 btn btn-menu">7.1 Vad är versionshantering?</a><a href="#07-02-versioning-install" class="toc-h2 btn btn-menu">7.2 Komma igång</a><a href="#07-03-versioning-staging-and-commiting" class="toc-h2 btn btn-menu">7.3 Staging &amp; commiting</a><a href="#07-04-versioning-branching" class="toc-h2 btn btn-menu">7.4 Branching</a><a href="#07-04-versioning-rolling-back" class="toc-h2 btn btn-menu">7.5 Rulla tillbaka</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#08-00-php-intro" class="toc-h1 btn btn-menu"><b>8 PHP och andra server-side-språk (kommer snart)</b></a><a href="#08-01-php-server-side-languages" class="toc-h2 btn btn-menu">8.1 Vad är server-side-språk?</a><a href="#08-02-php-installation" class="toc-h2 btn btn-menu">8.2 Komma igång</a><a href="#08-03-php-syntax" class="toc-h2 btn btn-menu">8.3 PHP Syntax</a><a href="#08-04-php-organizing-code" class="toc-h2 btn btn-menu">8.4 Kodorganisation</a><a href="#08-05-php-data-forms" class="toc-h2 btn btn-menu">8.5 Skicka data till servern</a><a href="#08-06-php-oop" class="toc-h2 btn btn-menu">8.6 Objektorienterad PHP</a><a href="#08-07-php-debugging" class="toc-h2 btn btn-menu">8.7 Felsökningstekniker</a></div><br><br><div class="btn-group-vertical toc-list"><a href="#30-00-efterord-intro" class="toc-h1 btn btn-menu"><b>9 Epilog</b></a><a href="#30-01-efterord-intro" class="toc-h2 btn btn-menu">9.1 Efterord</a></div><br><br></div><div id="chapters" class="container"><h1 href="#01-00-intro-intro" name="01-00-intro-intro" id="01-00-intro-intro">Introduktion</h1><p class="lead">Välkommen till HTMLHunden! En pragmatisk höghastighetsguide till webbutveckling. En guide som ger dig tillräckligt mycket för att ta dig ifrån den absoluta grunden till att bygga moderna/dynamiska/responsiva/snabba/pragmatiska webbsidor. Vi berättar inte bara hur du gör. Vi ger dig inte bara en massa kodexempel. Vi förklarar varför <b>och</b> ger dig kodexempel. Vår filosofi är inte att lära dig allt &mdash; utan att lära dig tillräckligt mycket för att du ska kunna lära dig själv! Det tror vi är det snabbaste sättet. Så på med rakethatten så kör vi!</p><div class="page-header"><h2 href="#01-01-intro-forord" name="01-01-intro-forord" id="01-01-intro-forord">Om denna guide</h2></div><p>Den här guiden är till för dig. Just ja. Precis just dig. Inte någon hypotetisk student någonstans. Den är inte heller mer till för dina kompisar än för dig. Eller mer till för de som du tycker kan så himla mycket mer än vad du kan. Den här guiden är till för vemsomhelst som vill lära sig att skapa webbsidor. Så oavsett om du vill lära dig ifrån grunden, eller vill förbättra dina redan existerande kunskaper, så är den här guiden till för just dig.</p><h3>Förväntade förkunskaper</h3><p>Vi förväntar oss egentligen inte att du har några förkunskaper som helst förutom en viss datorvana, och att du någon gång har sett ett programmeringsspråk. Vi försöker verkligen att täcka allt men någonstans måste det ta stopp. Men vi har satt gränsen för vad som krävs av dig på en plats som vi känner oss mycket bekväma med. Det viktiga är att du själv använder ditt intellekt och dina nätsökskunskaper för att hela tiden aktivt försöka förstå vad som sägs.</p><h3>Ett levande dokument</h3><p>HTMLHunden är ett levande dokument. Vi skriver om, skriver nytt, och skriver om konstant. Såldes kan många delar fotfarande kännas inkompletta. Men vi lovar, vi skriver för fulla muggar och det är på väg.</p><h3>Feedback</h3><p>Om du har något du vill berätta, så tryck gärna på feedback-knappen (till höger). Customer is king! Du är vår kund, och din åsikt är viktigast! Om du tycker att någonting är konstigt, bra, dåligt, kunde bli bättre, fel, eller rent utsagt helt uppåt väggarna så vill vi gärna ha in din åsikt.</p><p>Vi är medvetna om att denna guide är högst opinionerad, och således partisk. Om du står för andra åsikter än dem som presenteras här så skulle vi fantastiskt gärna vilja höra dina åsikter. Vi välkomnar olikheter. Allt för att bli bättre.</p><h3>Videomaterial</h3><p>Vi jobbar även på att skapa videos för stora delar av det här materialet. Det finns en del video nu, vilket du hittar inbäddat i löptexten. Om du är intresserad av att se alla videoklippen i ordning utan att leta omkring här så hänvisar vi dig vänligast till vår <a href="http://www.youtube.com/watch?v=wrdR5Su_Stg&amp;list=PLrhzvIcii6GOVLttYLcxO-92GxuPPwbul">playlist på YouTube</a>.</p><h3>Författare</h3><p>Den här guiden är framtagen av <a href="http://katalog.uu.se/empInfo/?id=N12-1461">Christopher Okhravi</a> (<a href="http://twitter.com/chrokh">@chrokh</a>) (Universitetsadjunkt, Uppsala Universitet) och <a href="http://katalog.uu.se/empInfo/?id=N10-407">Madelen Hermelin</a> (Universitetsadjunkt, f.d. Forskningsassistent, Uppsala Universitet). Detta är ett dokument som delvis används vid undervisning under <a href="http://www.im.uu.se/">Institutionen för Informatik och Media</a> vid <a href="http://www.uu.se/en">Uppsala Universitet</a>, men bör ses som ett uttryck för författarnas personliga åsikter och inte universitetets.</p><div class="page-header"><h2 href="#01-02-intro-quickstart" name="01-02-intro-quickstart" id="01-02-intro-quickstart">Filer, filformat och webbläsare</h2></div><p>Alldeles snart ska vi djupdyka in och skapa vår första webbsida. Men först behöver vi snabbt orientera oss. Vad är egentligen en webbsida? Vad är egentligen en webbläsare? Och vad är det som gör att en webbläsare kan läsa en webbsida? Låt oss bena ut några begrepp.</p><h3>Vad är en webbsida?</h3><p>Vi kommer sannolikt möta fler definitioner under denna resas gång. Men låt oss, för enkelhetens skull, definiera en webbsida som följande: Ett interaktivt dokument med hyperlänkar till andra interaktiva dokument.</p><p>Men vad skiljer då dessa "interaktiva" dokument ifrån helt vanliga textdokument. Låt oss se till några exempel. Webbsidor kan...<ul><li>innehålla hyperlänkar (som leder oss till andra webbsidor),</li><li>vara förändringsbara (genom t.ex. animation)</li><li>vara interaktiva (d.v.s. förändras beroende på hur vi interagerar med dem)</li><li>läsas av maskiner (t.ex. <a href="http://en.wikipedia.org/wiki/Web_crawler">sökspindlar</a> konstruerade av (t.ex.) Google, kan analysera din webbsida och skapa sig en uppfattning om dess innehåll och struktur)</li><li>konsumeras på en multitud av olika enheter. Såsom mobiler, tablets eller Smart TV-apparater.</li></ul></p><p>Alla ovan punkter har förstås inte alltid varit sanna. I webbens tidiga dagar hade vi tur om vi träffade på en animerad gif av en <a href="http://en.wikipedia.org/wiki/Hampster_Dance">hamster som dansade</a>. Idag har vi världsförändrande webbsidor såsom <a href="http://maps.google.com">Google Maps</a>. Gränsen för vad som kan täckas in av ordet webbsida börjar tänjas längre och längre, och gränsen mellan en traditionell applikation och en webbsida är nästan redan utsuddad. Men låt oss återkomma till den här diskussionen i ett senare kapitel.</p><h3>Vad är en webbläsare?</h3><p>Du har sannolikt redan en god uppfattning om vad en webbläsare är. Men det är viktigt att vi funderar över det lite närmare. Låt oss försöka bryta ned det.</p><p>Låt oss fundera lite på vad en webbläsare är genom att fundera på vad ett datorprogram är. Ett datorprogram är (oftast) en uppsättning funktioner som transformerar input till output.</p><p>I vissa fall innebär denna transformation att vi går ifrån ett filformat till ett annat. Säg t.ex. när vi konverterar en videofil ifrån ett format till ett annat. Kanske för att det ska gå att spela upp på en mobil enhet.</p><p>I andra fall innebär denna transformation att vi går ifrån ett format som endast en dator kan förstå till ett format som en människa kan tolka genom något av sina sinnen. En rå videofil är t.ex. allt för komplex för att vi som människor ska kunna läsa dess "binära" data och förstå vad filmen handlar om. Istället måste datorn successivt "koda om" detta format till en ström av bilder som visas upp på vår skärm.</p><p>Ett videouppspelningsprogram såsom VLC, Media Player Classic, Quick Time, eller Windows Media Player fungerar alltså detta fall som en slags "tolk" av information. Återigen, är programvarans uppgift alltså att transformera någonting ifrån ett format till annat.</p><p>Men vad har detta med webbläsare att göra? Fundera på vad vi nyss ha sagt, och fundera sedan på att alla webbläsare också är program. Webbläsare transformerar input till output. Nothing more, nothing less.</p><p>Webbläsarens input är (t.ex.) ett HTML-dokument, och webbläsarens output är (bl.a.) en, på skärmen, visuell representation av strukturen och innehållet av det dokumentet. HTML är med andra ord maskinens sätt att läsa ett dokument, och webbläsarens visuella representation av samma dokument är den mänskligt läsbara motsvarigheten.</p><h3>Vad är ett filformat?</h3><p>Innan vi går vidare behöver vi fundera lite på vad en fil är för någonting. Alltså helt vanliga filer som du hittar på din egen dator. Bildfilder, dokument, musik etc. Det två viktiga realisationer vi behöver göra.<ol><li>Filtyper är bara hittepå. Alla filer är rådata. Alla filer går att läsa som text. Strukturen på texten är baserad på konvention.</li><li>Filändelser på bara hittepå. De en konventionsbaserad indikator för filtyp.</li></ol></p><p>Egentligen kan vi se allting som text. (Sanningen är djupare än så. Egentligen är även mänsklig text för en dator bara hittepå och konvention. Men det är att gräva onödigt djupt för nu). Om vi accepterar att alla filer, oavsett om de är bilder, filmer, textdokument eller webbsidor egentligen bara består av text så börjar vi nå intressanta frågor. Hur i hela friden kan en biofilm representeras i text? Låt oss formalisera frågorna.<ol><li>Hur kan komplexa filer representeras med rå data?</li><li>Hur vet operativsystemet vilken typ av fil en viss fil är av, och således vilket program det ska använda för att öppna filen?</li></ol></p><p>Svaret på den första frågan är egentligen tätt bundet till svaret på den andra. Ponera t.ex. talserien <code>(0,255,255)</code>. Ponera att vi "mappar" dessa siffror emot konventionen RGB (Red, Green, Blue) (som används för att representera färg). Ponera att varje värde ska separeras med ett komma-tecken. Ponera även att <code>0</code> betyder "färgkanal på" och <code>255</code> betyder "färgkanal av". Denna tankelek göra att vi genom konvention och helt vanlig plain-text specificerat färgen röd. Poängen är alltså att om vi bara ser till texten i sig är den helt meningslös. Men när vi applicerar idéen om konventionen på texten fyller den plötsligt ett syfte.</p><p>En fil är bara en mängd arbiträr men strukturerad data. Program följer olika konventioner, och när man läser en fil med hjälp av en viss konvention kan man extrahera den information som faktiskt finns inbäddad i filen. D.v.s visa bilden, spela upp ljudet, representera dokumentet.</p><p>Så hur vet operativsystemet vilken konvention den ska applicera? Tänk tillbaka på tidigare diskussion om att ett programs enda uppgift är att transformera input till output. Om ett program är specialiserat på att transformera en viss typ av input till en viss typ av output &mdash; då är det en utmärkt kandidat för att vara en explicit konvention. Innehållet i en fil är alltså input (texten) och ett given program är alltså transformationsprocessen (konventionen).</p><p>Låt oss formulera det i andra ord. En fil innehåller egentligen bara strukturerad råtext (egentligen: data). När denna fil med strukturerad råtext sedan öppnas med det program den var ämnad att öppnas i, kommer denna till synes mumbo jumbo av text helt plötsligt spela sin roll.</p><blockquote class="text-info">Prova själv genom att öppna t.ex. en .jpeg-fil i en vanlig texteditor (såsom Notepad eller TextEdit).</blockquote><p>Egentligen kan vi slänga på vilken filändelse (alltså t.ex. .tex, .doc, .pdf, .jpg, etc.) på vilken fil som helst. Den spelar ingen roll för själva innehållet i filen. Så länge vi öppnar filen med det avsedda programmet (och så länge det avsedda programmet tillåter oss att forcera det att öppna filer med "fel" filändelse) så kommer allt fungera precis som vanligt.</p><p>Faktum är att UNIX-baserade operativsystem i grund och botten <a href="http://cs.canisius.edu/ONLINESTUFF/UNIX/files1.html">inte bryr sig om filändelser</a>. Istället för att filändelsen specificerar vilket program som bör användas för att öppna filen, så specificerar filen själv vilket program som bör användas.</p><p>Medan det konkreta beteendet skiljer sig ifrån operativssytem till operativssystem, så är dagens läxa alltså att alla program i teorin egentligen kan läsa alla filer. Det går bara mer eller mindre bra. Det gäller alltså bara att det att programmet applicerar rätt <em>konvention</em> för hur filen ska läsas. Texteditorer (t.ex.) kan öppna ljudfiler, de kan visa upp det råa innehållet i textuell representation. Men de har ingen aning om hur man faktiskt får ljudet att spelas upp.</p><p>Låt oss analysera ett scenario du själv eller någon du känner kanske redan stött på. Anta att vi har en fil: <code>bild.jpg</code>. Anta sedan att vi döper om den till <code>bild.png</code>. Har filen nu konverterats ifrån formatet JPEG till PNG? Fundera... Självklart inte! Filändelsen är ju bara en del av filnamnet. Inte en del av innehållet. Innehållet är fortfarande detsamma. JPEG är en konvention, PNG en annan. Om filens innehåll följde konventionen JPEG tidigare, och vi endast förändrade filändelsen (alltså filens namn) så innehåller den ju fortfarande data som följer JPEG-konventionen. Alltså har filen inte konverterats. Däremot kommer vi sannolikt ha det svårare att öppna filen i vissa program och/eller operativsystem. Programmet kan komma att anta att filen följer konventionen PNG (i.o.m. att filen har en filändelse som är .png) men när filen sedan faktiskt följer konventionen JPEG (eftersom innehållet i filen följer JPEG-konventionen) så blir programmet superförvirrat och ger upp. En fil med innehåll som följer JPEG-konventionen är inte en fil som följer PNG-konventionen &mdash; oavsett vilken filändelse vi slänger på. En JPEG-fil är inte en PNG-fil &mdash; oavsett vilken filändelse vi slänger på.</p><h3>Vad är HTML?</h3><p>Låt oss nu prata om HTML. Webben drivs i stor del av ett märkesspråk (<a href="http://en.wikipedia.org/wiki/Markup_language">markup language</a>) vid namn HTML. Innan vi kan börja förstå vad HTML är behöver vi förstå vad ett märkesspråk är.</p><p>Ett märkesspråk (oavsett vilket) kan ses som ett textfilsformat vi använder för att "markera upp" olika delar av en text. T.ex. kan det användas för att tilldela ett dokuments olika delar olika semantisk betydelse. Men vad menar vi då med att "markera upp"? </p><p>Reflektera över denna sida. Över denna text. Du ser att vissa delar är paragrafer och att vissa delar är rubriker. Du ser att denna paragraf inte är samma som den föregående. Hur? T.ex. är du ju en människa som vet att du ska tolka upprepade radbrytningar som paragrafskiften. Men hur visste datorn det? Eller mer specifikt. Hur vet din webbläsare (eller det program du använder för att läsa texten) vad som är vad? Hur vet webbläsaren vad som är en rubrik, vad som är en paragraf, vad som är en länk och vart länkarna pekar? Som du antagligen gissat är svaret märkesspråk &mdash; markup languages.</p><p>Vi använder alltså märkesspråk för att delimitera olika sektioner i en flödestext. Om du tänker tillbaka på vad vi tidigare diskuterat om att allting är rå text, så kan denna text i teorin representera vad som helst.Text, video, bild etc. I vilket fall så använder vi märkesspråk för att delimitera olika delar av dokumentet i olika sektioner. Låt oss se till ett snabbt exempel på hur detta fungerar i märkesspråket HTML.</p><pre><code class="language-markup">Endast ett ord i denna text, nämnligen &lt;b&gt;detta&lt;/b&gt; kommer att visas i fetstil.</code></pre><p>Om vi kör ovan genom en webbläsare så kommer webbläsaren att rendera följande resultat:</p><div class="panel panel-default"><div class="panel-body">Endast ett ord i denna text, nämnligen <b>detta</b> kommer att visas i fetstil.</div></div><p>Notera alltså hur användandet av notationen <code>&lt;b&gt;...&lt;/b&gt;</code> används för att delimitera en del av texten som är av extra semantisk vikt och bör visas upp i fetstil. Detta är vad som i HTML kallas för ett <code>element</code>. Ett element som byggs upp genom kombinationen av en start-tag (<code>&lt;b&gt;</code>) och en slut-tag (<code>&lt;/b&gt;</code>).</p><p>Användandet av bokstaven <code>b</code> i ovan exempel är något sånär arbiträrt. Bokstaven delimiterar vilket elment det är vi vill skapa. I HTML finns ett antal fördefinerade element, varvid <code>b</code> är just ett sådant. Användandet av tecknena mindre än (<code>&lt;</code>), större än (<code>&gt;</code>), och slash (<code>/</code>) är dock inte arbiträra. De tillhör märkesspråket HTML's <a href="http://sv.wikipedia.org/wiki/Syntax">syntax</a>.</p><p>Syntax är ett ord som används för att beskriva hur vi uttrycker någonting i ett visst språk. Varje programmeringsspråk och märkesspråk har en egen syntax. Olika märkesspråk har olika syntax, men idéen är densamma. Ett märkesspråk använder någon form av syntax för att "markera ut" vilka delar av en text som är av vilken typ. T.ex. rubriker, paragrafer, länkar, emfas, citat o.s.v.</p><p>Vi kommer att gräva mycket mer i hur HTML fungerar senare. Men för nu behöver du förstå att HTML är ett märkesspråk, och att märkesspråk används för att "markera upp" olika delar av en text så att en maskin kan "förstå" dokumentet.</p><div class="page-header"><h2 href="#01-03-intro-arkitektur" name="01-03-intro-arkitektur" id="01-03-intro-arkitektur">Internet, klienter och servrar</h2></div><p>Den huvudsakliga frågan vi ska försöka besvara i detta kapitel är &mdash; hur fungerar en webbsida? Alltså, hur kan det komma sig att när vi knattrar in www.google.com i en webbläsare och trycker enter, så kommer en interaktiv webbsida tillbaka.</p><p>För att kunna svara på den frågan behöver vi bena ut ett par olika begrepp och lära oss lite mer om den arkitktur som vårt kära internet bygger på. Vi behöver bl.a. prata om klienter, servrar, nätverk, requests och responses. </p><h3>Webbläsaren som program</h3><p>Förnim dig att vi redan har diskuterat att alla filformat bygger på konventioner. Och att alla program "läser" filer genom att de känner till rätt konventioner. Webbläsaren är egentligen ett helt vanligt program som bl.a. bygger på konventioner kring formatet HTML.</p><p>Webbläsaren är alltså ett program som "förstår HTML". Om du öppnar en webbläsare och säger <code>"File &gt; Open"</code> så förväntar den sig att du ska ge den en fil i (t.ex.) HTML-format.</p><p>När vi ger webbläsaren en fil i HTML-format så tolkar webbläsaren filen enligt de konventioner som specificeras av HTML-standarden. Tyvärr har olika webbläsare valt att implementera olika delar av standarden. Samt tolkat olika delar av standarden olika. Vi kommer prata mer om denna situation senare. Hur det kan komma sig att samma kod kan betee sig olika i olika webbläsare. Vad det har för konsekvenser, och hur vi kan hantera det.</p><p>Men det vi behöver fokusera på nu, är alltså att vi <b>inte</b> behöver se webbläsaren som ett program som "browsar" internet. Vi kan likväl se webbläsaren som ett program som kan rendera HTML-filer.</p><p>Så, vad menar vi då med att webbläsaren "renderar" en HTML-fil? De webbläsare vi oftast kommer i kontakt med (Google Chrome, Firefox, Internet Explorer etc.) är webbläsare vars uppgift (bl.a.) är att "läsa" HTML-filer och rendera deras visuella representation på skärmen. Vi, i egenskap av människor, vill inte se själva markup-koden utan en rimlig visuell representation av den markup-koden. Om ett antal ord t.ex. är omslutna av bold-taggen (ex: <code>&lt;b&gt;Hej&lt;/b&gt;</code>) så vill vi inte (när webbläsaren har renderat dokumentet) se själva taggen. Istället vill vi se texten som omslöts av elementet i visuell fetstil (alltså: <b>Hej</b>). En webbläsares uppgift är alltså (bl.a.) att konvertera ett HTML dokument ifrån ett machine-readable format format till ett human-readable format, som visuellt representeras på skärmen.</p><h3>Statiska webbsidor</h3><p>När vi talar om språk för webbutveckling talar vi oftast antingen om server-side- eller client-side-språk. Vi pratar också om statiska och dynamiska webbsidor. Förenklat uttryckt så kan vi med hjälp av server-side-språk uppnå dynamiska språk. Utan server-side språk kan vi endast skapa statiska webbsidor. Detta är en halvsanning (p.g.a. JavaScript), men det kommer vi tala om mer senare. För att skapa dynamiska webbsidor behöver vi introducera någon form av programmerings/scripting-språk. Med märkesspråk endast, kan vi alltså endast skapa statiska webbsidor.</p><p>Notera att ovan paragraf inte använder facktermer utan bör istället betraktas som en tolkning.</p><p>Innan vi kan gå över till att diskutera statiska, dynamiska och skillnaden emellan de &mdash; låt oss återigen påminna oss själva om hur språket HTML ser ut.<pre><code class="language-markup">Ett ord i &lt;b&gt;fetstil&lt;/b&gt; och ett &lt;i&gt;understruket&lt;/i&gt;.</code></pre><div class="panel panel-default"><div class="panel-body">Ett ord i <b>fetstil</b> och ett <i>kursivt</i>.</div></div></p><p>HTML är alltså det märkesspråk vi använder för att "märka upp" ett stycke media. Vi använder termen media eftersom HTML-dokument inte endast behöver bestå av text. De kan även innehålla bilder, ljud och video.</p><p>Med ordet statiskt menar vi (krasst) att om vi skulle öppna samma HTML-dokument två gånger i samma webbläsare så kommer vi att se ett precis likadant dokument andra gången som första. Låt oss omformulera detta. Ett icke-dynamiskt dokument är alltså ett icke-förändrande dokument. Ett statiskt dokument är ett dokument som inte förändras oavsett när vi visar upp det.</p><p>Låt oss uttrycka oss tydligare. När vi har en statisk webbsida så är det alltid samma markup (HTML) och resurser (bilder, css, javascript etc.) som levereras till webbläsaren. När vi bygger statiska sidor så har våran webbapplikation inte heller någon möjlighet att kommunicera med servern. Om sidan inte kan kommunicera med en server så kan den inte heller hålla någon form av "state". Med state menar vi minne. Om vi t.ex. vill bygga en highscore-lista för ett spel så behöver vi ett persistant state för att alla ska</p><ul><li>Samma markup serveras alltid till webbläsaren när webbläsaren begär samma URL</li><li>Samma resurser serveras alltid till webbläsaren när webbläsaren begär samma URL</li><li>Servern som serverar filerna gör det utan att något program modifierar filerna innan de serveras.</li></ul><p>Ett exempel på en statisk webbsida är denna. Alltså htmlhunden.se. De dynamiska delarna (såsom t.ex. innehållsförteckningen) av denna bok har redan genererats i förväg. När din webbläsare ber om att få den sida du är på just nu &mdash; så kommer servern alltid att servera samma HTML. Nämligen den du just nu ser på.</p><h3>Dynamiska webbsidor</h3><p>Om statiska webbsidor innebär webbsidor där den server som serverar webbsidan alltid serverar samma filer vid sina URL:er &mdash; vad är då en dynamisk webbsida? Som du kanske redan gissat, kan servrar som serverar dynamiska webbsidor servera olika HTML olika gånger trots att vi begär samma URL. Det finns alltså inga garantier för att vår webbläsare kommer att motta samma resurser när vi laddar om sidan.</p><p>Vi behöver skapa dynamiska webbapplikationer när vi behöver...</p><ul><li>... spara/hämta data till/ifrån en databas (ex. användare)</li><li>... utföra beräkningar som inte får riskera exponeras för användaren (ex. login)</li><li>... utföra "tunga" beräkningar som klientens dator kanske inte orkar med (ex. videokonvertering)</li><li>... utföra aktiviteter med beroenden av 3e-parts-applikationer (ex. zip) </li><li>... utföra aktiviteter som klienten inte har möjlighet/rättighet att utföra per automatik (ex. skicka mail)</li></ul><p>Det finns (som alltid) ett par undantag i relation till ovan lista. Men de undantagen är av för hög överkurs för att vi ska gå in på dem. I stora drag är ovan lista sann.</p><h3>State</h3><p>Kommer snart...</p><!-- Skillnaden mellan client-side-state och server-side-state--><!-- HTML5 local storage är persistant men delas inte mellan klienter--><!-- AJAX--><h3>Klient-server-arkitektur</h3><p>Innan vi kan gå djupare in på varför vi <b>inte</b> kan utföra komplex logik i html så behöver vi lära oss lite om ansvarsområden för <a href="http://sv.wikipedia.org/wiki/Klient%E2%80%93server" target="_blank">klienter och servrar</a>. Vi har tidigare i detta kapitel uttryckt oss i bemärkelsen att en "server serverar en fil". Om vi är ännu mer explicita skulle vi kunna säga att en server severar en fil som en klient konsumerar.</p><blockquote>En server <em>servererar</em> resurser som <em>konsumeras</em> av klienter. </blockquote><p>Vad i hela friden menar vi med det? Vem är servern? Vem är klienten? Vad är en resurs? Detta är förstås generella termer som kan anta många skepnader. Men i de flesta av fall är din webbläsare klienten. Klienten är den som konsumerar. Klienten är den som blir serverad en HTML-sida. Klienten ansvarar själv för att rendera sidan. Såsom vi tidigare diskuterat. Webbläsaren (klienten) är ett program som är expert HTML-konventionen. Så när webbläsaren tar emot ett dokument som följer konventionen HTML så kan den utan problem rendera den visuella representationen av det dokumentet. Oavsett om du använder din webbläsare för att öppna www.google.com eller en HTML-fil på din egen dator så är webbläsaren en klient.</p><p>Servern däremot kan variera. När du öppnar www.google.com i en webbläsare så finns servern någon helt annanstans. Din klient (webbläsaren) skickar ett request till någon av (i detta fall) Google's servrar som svarar med ett response innehållandes HTML. Eftersom din klient (webbläsaren) är expert på att läsa HTML så läser den svaret och renderar den visuella representationen i din webbläsare.</p><p>När du öppnar en HTML-fil på din egen dator så är det din egen dator som är servern. När du väljer <code>File &gt; Open</code>, väljer en fil och sedan klickar OK så pratar din webbläsare med filsystemet på din dator. Löst uttryckt, ber din webbläsare helt enkelt ditt filsystem om den fil som finns på den plats där den fil du valde finns. Du kommer senare upptäcka att vad en traditionell webbserver gör, faktiskt inte ens är särskilt annorlunda än detta triviala scenario.</p><p>För att slutligen svara på vad vi menar med ordet "resurs" i ovan citat så kan det egentligen vara nästan vad som helst. Vi ska strax prata om request-response-modellen. Allt som går att skicka som ett response är en resurs som skulle kunna serveras av en server och konsumeras av en klient. HTML-dokument, bilder, javascript-filer, musik, Word-dokument etc.</p><p>När vi som webbutvecklare utvecklar sidor är det vanligt att vi kör en lokal webbserver på vår egen dator. Detta bl.a. för att närmare efterlikna (mimik:a) den miljö som vår webbsida faktiskt kommer att leva i när den ligger "live" på Internet.</p><p>Många tänker på mörka dundrande hallar fyllda med korridorer av monstermaskiner när de tänker på servrar. Nu vet du att verkligheten absolut ibland ser ut just så. Men du vet också att det inte alls behöver vara fallet. En server är egentligen också bara ett program som kan köras på en dator. Denna dator kan lika gärna vara din egen laptop. Och programmet kan lika gärna vara väldigt litet.</p><h3>Request-response</h3><p>Internet bygger på en modell som vi kan kalla för request-response-modellen. Ett "request" är en förfrågan, och ett "response" är ett svar. Vi vet ju nu att en servers uppgift är att servera klient med resurser. Men mer specifikt så serverar en server ett (passande) response till en klient, när denne klient skickar ett request. Vi säger passande eftersom reponse:et förstås beror på vilket request vi har skickat.</p><blockquote>En server serverar ett response till den klient som skickar ett request.</blockquote><p>Det här låter kanske komplext men är egentligen väldigt enkelt. Låt oss se till det lite närmare. Aktörerna i denna klient-server-historia är alltså följande:</p><ol><li>En klient (t.ex. vår webbläsare)</li><li>En server (t.ex. någon annans dator)</li></ol><p>En konversation mellan de två parterna skulle alltså kunna låta så här:</p><pre>client request
"Hörru servern, jag skulle vilja titta på filen index.html."
 
server response
"Okidokes, här kommer den!"
 
Klienten läser filen och upptäcker att filen refererade till en bild som den också behöver
 
client request
"Du din gamle server, du berättade inte att jag behövde logo.png också, langar du över den är du snäll!"
 
server response
"Sorry, eftersom jag bygger på den gamla request-response-modellen kunde jag inte berätta det för dig på en gång, här har du!"</pre><p>Ovan figur är alltså en visualisering av hur ett request-response-scenario skulle kunna spela ut sig, när en klient ber om en webbsida. Och i essens är det ungefär det här som händer <em>varje gång</em> vi öppnar vår webbläsare och skriver in en adress såsom exempelvis www.google.com.</p><h3>Server-side-språk</h3><p>Låt oss nu istället prata om server-side språk. Ett server-side-språk är ett lös term som refererar till ett programmeringsspråk som kan användas för att leverera ett response när ett request kommer in. Tänk så här. Vi skulle kunna ha en klient-server-arkitektur helt utan ett server-side-språk. Hur? Jo, klienten ber om en sida genom ett request som vandrar över internet och når rätt server som rakt av svarar med ett response som är en html-sida.</p><p>Men nu är det ju så att det moderna internet består av mycket mer komplexitet än statiska sidor. Den enda skillnaden vi introducerar i ovanstående process handlar då om att vi introducerar ett språk som ansvarar för att konstruera html-sidor beroende på response.</p><p>Vi omformulerar ovan paragraf. Ett server-side-språks huvudsakliga uppgift är alltså att "hitta på" ett html-dokument. Ett statiskt response skulle vara att bara svara med en existerande html-fil. Men ett dynamiskt response skulle innebära att server-side-språket först utför en del logik, och sen "on the fly" skapar den html-fil som servern svarar med.</p><p>Exempel på server-side-språk är t.ex. PHP, Ruby, Python, ASP.NET etc.</p><p>Så om server-side-språket "genererar" HTML-filer &mdash; varför måste vi då lära oss att skriva det själva? Enkelt svarat &mdash; eftersom det är vi som skriver server-side-koden, och därmed även vi som definierar hur HTML-sidorna ska genereras. Det finns alltså inte någon magisk HTML-generator utan någonstans måste vi definera exakt hur HTML-sidorna ska genereras beroende på de request vi får in. Vi återkommer alltså till den gamla tanken mdash; eftersom datorer är korkade, så måste vi berätta för dem exakt vad vi vill ha.</p><h1 href="#02-00-html-intro" name="02-00-html-intro" id="02-00-html-intro">HTML</h1><p class="lead">Navet i det stora webbhjulet måste vi förstås hävda är just HTML. Detta markup-language har hängt med länge och är just det språk vi använder för att strukturera upp information på ett sätt som en webbläsare förstår. Detta kapitel kommer lära dig hur HTML fungerar och hur vi skriver det.</p><p>Innan vi verkligen ger oss på hur man använder HTML, CSS och JavaScript så kan det vara skönt att få en snabb introduktion till hur allt hänger samman. Kika igenom filmen på 25 minuter nedan.</p><div class="panel panel-default"><div class="panel-heading">Introduktionsvideo om html, css och javascript</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/wrdR5Su_Stg?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><div class="page-header"><h2 href="#02-01-html-document-structure" name="02-01-html-document-structure" id="02-01-html-document-structure">Syntax, struktur och första dokumentet</h2></div><p><a href="http://sv.wikipedia.org/wiki/HTML">HyperText Markup Language</a> (HTML) är det språk vi använder för att märka upp content vi vill kunna visa i en webbläsare. I detta kapitel diskuterar vi vad HTML är och hur vi skriver det.</p><p>Innan vi ser till ett exempel behöver vi kort diskutera vad HTML är för någonting. Låt oss utföra en tankelek. Ponera att du, på datorn, skrivit ett dokument i <i>Microsoft Word</i>, <i>Pages</i>, <i>Open Office</i> eller dylik ordbehandlare. Fundera kort över vad detta dokument består av. Vad innehåller det? Text? Jo, onekligen. Men mer exakt än så då? De flesta dokument innehåller någon kombination av rubriker, underrubriker och paragrafer. Men gräver vi djupare än så så hittar vi saker som citat, listor, understrykningar, fetstilsmarkeringar, kursivitet o.s.v.</p><p>För att förstå hur HTML fungerar behöver vi egentligen bara förstå att vår ordbehandlare omöjligen kan komma ihåg vilka delar vi anser vara rubriker eller fetstilsmarkeringar om den inte någonstans sparar den informationen när vi först berättar det. Låt oss uttrycka oss på generellare form. Nästan alla dokument &mdash; ovavsett typ &mdash; består inte bara av text. De består av text som är tätt bunden till semantik. Varje del av texten spelar någon roll i helheten som inte nödvändigtvis behöver vara samma roll som någon annan del av samma text. En term som ofta används för att referera till detta förhållande mellan text och meta-information är <a href="http://sv.wikipedia.org/wiki/Semantik">semantik</a>. Vi kommer framöver på många sätt prata om begreppet semantisk signifikans för att diskutera vad saker har för signifikans i en kontext.</p><blockquote>Dokument består inte bara av rå text, utan rå text tätt med olika semantik.</blockquote><p>En paragraf är inte en paragraf om inte den som läser paragrafen kan urskilja och förstå att det är en paragraf den läser. Det är detta vi talar om när vi talar om semantisk signifikans. Utöver att vi som människor läser texten som paragrafen består av så "läser vi in" faktumet att det är ett avgränsatt område text &mdash; i.e. en paragraf.</p><p>Om information saknade semantisk signifikans hade vi likväl kunnat representera dokument i ett enda långt flöde. All text på en enda lång rad. Men vi människor verkar gilla semantisk indelning för att t.ex. underlätta inlärning. Således har vi lärt oss att (t.ex.) extra vertikalt mellanrum (whitespace) emellan rader denoterar en paragrafindelning och således ett avslut och en påbörjan på en ny tanke/poäng. En paragrafindelning denoterar alltså slutet på en idé och antagligen början på nästa.</p><p>Men maskiner (e.g. webbläsare) har idag inte den förståelse som ovan beskrivs. En webbläsare kan inte förstå vad den ska representera som en egen paragraf genom att processa texten. Maskinen läser inte texten och börjar tänka att "hmm.. här ska vi nog ha en radbrytning". Därför behöver vi berätta för maskinen vad som är vad.</p><p>Maskiner behöver inte bara veta vad som är vad för att vi ska kunna närma oss <a href="http://sv.wikipedia.org/wiki/Artificiell_intelligens">artificiell intelligens</a>. Utan i fallet av webben behöver webbläsaren helt enkelt veta vad som är vad för att kunna presentera informationen för oss på ett rimligt sätt. Kom ihåg. Annars är vi tillbaka i den svårhantereliga värld där paragrafindelningar inte existerar och all text kommer i ett enda långt stycke ifrån början till slut rakt av. Vilken pers det hade varit.</p><p>Självklart handlar alltså inte detta om endast paragrafer. Den abstraktare poängen är alltså att vi måste denotera olika delar för att en maskin ska kunna resonera kring dem. Om vi inte berättar för maskinen vad som är rubriker, vad som är paragrafer, vad som är listor o.s.v. o.s.v.</p><h3>Dokument som hierarkier</h3><p>HTML-dokument bygger på en metafor om att alla dokument går att beskriva som hierarkiska trädstrukturer. Fundera på det. I stort sett alla dokument går att beskriva som en hierarkisk trädstruktur. Ta en bok till exempel. Högst upp i abstraktionskedjan hittar vi av ett antal delar. Boken börjar med ett förord, sen kommer första delen, sedan andra delen, och avslutningsvis efterordet. Böcker ser ju förstås olika ut men detta är ett exempel på hur en bok skulle kunna se ut. Men indelningen tar ju inte slut när vi har delat upp boken i olika delar. Under varje del hittar vi kapitel. Nu kan vi se boken som att den består av ett antal delar under vilka det finns ett antal kapitel. Letar vi vidare så upptäcker vi att varje kapitel innehåller paragrafer. Och letar vi ännu vidare så upptäcker vi att vissa paragrafer innehåller bilder. Om vi skulle försöka representera ovan bok som en linjär trädstruktur skulle den rimligen se ut så här: <code>Del &gt; Kapitel &gt; Paragraf &gt; Bilder</code>.</p><p>Vad vi nu har beskrivit är (i en trädstruktur) relationen mellan föräldrar och barn. Ett förälder kan innehålla barn, och barn kan höra till föräldrar. Ett kapitel kan innehålla paragrafer och en paragraf kan tillhöra ett kapitel. Därav användandet av notationen med större-än-tecknet (<code>&gt;</code>). Det till vänster om större-än-tecknet är alltså föräldern. Men om trädstruktur bara kunde ha barn och föräldrar så skulle de vara helt linjära. Istället behöver vi inse att barn kan ha syskon. En förälder kan alltså ha flera barn. Eller uttryckt i termer av ett träd. En gren kan ha flera förgreningar. Vi kommer att prata mer om detta när vi ser till ett par dokumenstruktursexempel.</p><h4>XML</h4><p>HTML har många likheter med ett annat märkesspråk vid namn <a href="http://sv.wikipedia.org/wiki/XML">XML</a>. XML är också ett märkesspråk som bygger på idéen om att information kan strutkrureras hierarkiskt. Den huvudsakliga skillnaden mellan HTML och XML är att HTML specifikt är skapat för att beskriva webbsidor. XML däremot är ett "general purpose" märkesspråk som kan användas för att beskriva vilken semi-strukturerad information som helst.</p><p>Men när vi nu börjar diskutera element så är det alltså viktigt att du kommer ihåg vårt mål när vi skapar HTML-dokument. Målet är att modellera den information vi önskar att beskriva i ett hierarkiskt format.</p><h3>Element</h3><p>Vi har nu alltså klargjort att HTML bygger på en metfor om att alla dokument går att modellera som hierarkiska trädstrukturer. Men hur gör vi då detta rent konkret? Svaret i HTML är något som benämns <i>element</i>. Element skapar vi genom att använda oss av <code>&lt;</code>, och <code>&gt;</code>-tecken. Följande är ett exempel på ett element som denoterar en paragraf.</p><pre><code class="language-markup">&lt;p&gt;Paragraftexten här...&lt;/p&gt;</code></pre><p>Ovan illustrerar alltså användandet av <code>p</code>-elementet, eller paragraf-elementet. Låt oss bena ut vad syntaxen är. Kom ihåg att ordet syntax handlar om <i>hur</i> vi uttrycker någonting i ett visst språk. I fallet av HTML så är de tre första tecknena i ovan exempel, samt de fyra sista del av syntaxen i HTML. Övrigt är rå text.</p><blockquote>HTML-element byggs upp av taggar.</blockquote><p>HTML-element består helt enkelt av någonting som vi referar till som taggar (tags). Element är alltså en komposition av taggar. Ett element kan komma i två former. Element kan alltså bestå av antingen...</p><ul><li>två taggar (en start- och en slut-tagg), eller</li><li>en tagg (en start-tagg utan slut-tagg)</li></ul><p>Paragraf-elementet vi såg tidigare är ett ypperligt exempel på den första formen där vi har ett tag-par som tillsammans bildar ett element. Vi öppnar en paragraf, skriver en text, och stänger sedan paragrafen. Notera alltså att vi använde slash-tecknet (<code>/</code>) och det återupprepade tagg-namnet (<code>p</code>) för att denotera stängningstaggen (<code>&lt;/p&gt;</code>). Men låt oss se till ett exempel på ett element som inte kräver en stängningstagg.</p><pre><code class="language-markup">Plötsligt...
&lt;hr&gt;
...dök en horisontell linje upp</code></pre><p>Elementet <code>&lt;hr&gt;</code> denoterar en horisontell linje (avdelare) som ritas ut rakt över sidan. En s.k. "horizontal ruler". Om vi funderar lite på det en stund så inser vi snabbt varför ensamma element existerar. En avdelare är en avdelare och det finns ingenting intelligent vi kan denotera innuti en avdelare. Andra element av denna typ är t.ex. bilder. Här ser vi också en tydlig anledning. En bild är ju alltid en bild. Det är ologiskt att anta att vi skulle vilja denotera existensen av någonting i bilden. Bilden själv beskriver vad som finns i bilden.</p><p>Om detta låter lite "lurvigt", oroa dig inte. Vi kommer att diskutera detta närmare och förhoppningsvis blir det klarare när du får se några exempel. Men för nu &mdash; kom ihåg att det finns två typer av element. De som inte behöver stängas (eftersom vi kan placera element eller content i dem), och de som behöver stängas.</p><h3>Element i element</h3><p>För att kunna bygga hierarkiska trädstrukturer så behöver vi förstå att HTML kan innehålla element i element. Ett element kan alltså vara barn till ett annat element. Med andra ord kan vi sluta oss till att ett element som öppnas och stängs kan (i sin kropp) innehålla antingen...</p><ul><li>Text, eller</li><li>Ett annat element</li></ul><p>När vi säger text så menar vi förstås även avsaknaden av text. Den tomma strängen. Så är det även tillåtet att ett element, som förväntar sig ett barn eller text, inte innehåller någonting. Med andra ord skulle elementet öppnas (starttagg) och sedan stängas på en gång (sluttagg).</p><blockquote><p>Ett element kan antingen innehålla ett annat element eller text.</p></blockquote><p>Det är när vi börjar förstå att element kan innehålla andra element som vi verkligen börjar närma oss idéen om hierarkisk informationsrepresentation. Vi kan nu alltså börja uttrycka saker såsom:</p><pre><code class="language-markup">&lt;section&gt;
  &lt;p&gt;En första paragraf.&lt;/p&gt;
  &lt;p&gt;Följd av en annan.&lt;/p&gt;
&lt;/section&gt;</code></pre><h3>Plain-text om inte annat anges</h3><p>En viktig poäng om relationen mellan text och element är att webbläsaren tolkar allt som inte denoterats som någonting annat som text. Oavsett hur många radbrytningar eller mellanslag vi slänger in i ett stycke text så kommer webbläsaren ändå att trunkera all text. Med andra ord hamnar all text på samma rad. Och upprepade mellanslag ersättsm ed ett enda.</p><p>Man skulle alltså kunna säga att HTML i någon bemärkelse är <i>addativt</i>. Vi har en mängd text, och omsluter sedan olika delar av texten med element för att skapa en semantisk indelning. Utan element, har vi ingenting annat än en enda lång sträng av text.</p><p>Anta t.ex. att vi vill lägga in ett antal radbrytningar i en paragraf. Anta att vi försöker göra det genom att helt enkelt skapa radbrytningar med hjälp av ENTER-tangenten vid de platser vi vill. Beakta nedan kod:</p><pre><code class="language-markup">&lt;p&gt;
  Oavsett<br>
  hur många       mellanslag, eller<br>
  radbrytningar   vi lägger in,<br>
  så har det ingen effekt.
&lt;/p&gt;<br></code></pre><p>Trots alla radbrytningar och mellanslag blir ändå resultatet följande...</p><div class="panel panel-default"><div class="panel-body">Oavsett
hur många     mellanslag, eller
radbrytningar vi lägger in,
så har det ingen effekt.</div></div><p>Såsom exemplets text förtäljer har traditionella radbrytningar ingen effekt i ett HTML-dokument. Detta är ett gott exempel för att illustrera att webbläsaren läser dokumentet som en enda lång sträng av text. Så länge vi inte använder HTML-element för att denotera åtskilda delar av dokumentet, så kommer webbläsaren att hantera dokumentet som en enda lång massa av text.</p><h3>Attribut</h3><p>Ett elements öppnande tag kan även innehålla attribut med värden. Attribut är i simpla termer egenskaper för ett givet element. Om vi t.ex. har en hyperlänk (<code>&lt;a&gt;</code>) kan vi använda oss av attributet <code>href</code> (hyper reference) för att denotera vart hyperlänken ska peka någonstans.</p><blockquote>Attribut är egenskaper för en instans av ett element.</blockquote><p>För att t.ex. skapa länkar använder vi elementet <code>&lt;a&gt;</code>. För att sedan denotera vart länken ska peka ger vi attributet <code>href</code> ett värde. Detta värde tar formen av en URL. Beakta nedan exempel och fundera över användandet av attributet <code>href</code>.</p><pre><code class="language-markup">&lt;a href="http://uu.se"&gt;Klicka på mig&lt;/a&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><a href="http://www.uu.se">Klicka på mig</a></div></div><p>Attribut kommer i två former där den vanligaste är nyckel-värde-par (key-value-pairs). Vi specificerar en nyckel och tilldelar den ett värde. Enligt syntaxen <code>nyckel="värde"</code>. Där ordet "nyckel" alltså ersätts med en nyckel som är tillåten för ett givet element. Och ordet "värde" ersätts med ett värde som är tillåtet för den givna nyckeln.</p><p>Alla attribut (nycklar) är inte tillåtna på alla element. Alla värden är inte heller tillåtna på alla nycklar. Anledningen till detta är helt enkelt att attribut denoterar saker som ofta är specifika för just en given typ av element. I exemplet ovan använder vi t.ex. attributet <code>href</code> &mdash; "hyper reference". En hyperreferens är logisk vid användandet av en länk eftersom en länk måste ha en målplats. En länk är inte en länk om den inte har någonstans att länka. Om vi däremot diskuterar en paragraf (<code>&lt;p&gt;</code>) så blir användandet av en hyperreferens helt meningslös. En paragraf är en paragraf av text, inte en länk. En paragraf ska inte hyperreferera någonstans. Det är inte logiskt.</p><blockquote>Olika element tillåter olika attribut.</blockquote><p>Nu kanske du tänker att en paragraf ju måste gå att göra klickbar. Och det är helt sant. Men inte genom att klistra på ett hyperreferens-attribut på paragraf-taggen. Istället kan vi omsluta en del av paragrafens text i ett <code>&lt;a&gt;</code>-element. Kom ihåg &mdash; vi kan nästla element i element!</p><p>Det finns dock några attribut som vi kan slänga på på precis vilket element som helst. Dessa är <code>id</code> och <code>class</code>. Detta är attribut som kommer att visa sig mycket användbara. Vi kommer att prata mer om dessa när vi börjar diskutera CSS och JavaScript.</p><p>Vi har nu pratat om både element och attribut. Låt oss sammanfatta. Element är alltså de "grenar" vi använder för att bygga upp vårt "dokumentträd". Attribut är egenskaper vi kan applicera på våra grenar. </p><h3>Kommentarer</h3><p>I de flesta märkes- och programmeringsspråk så finns faciliteter för vad som kallas för <i>kommentarer</i>. Text vi kan skriva i våra källkodsdokument som inte har någon effekt på det renderade resultatet.</p><p>I HTML ser en kommentar ut som följande.</p><pre><code class="language-markup">&lt;!-- Åh, en sån kommentar! --&gt;</code></pre><p>Kommentarer kan vi skriva i HTML-dokument av olika anledningar men t.ex. skulle vi kunna använda de till att skriva förklarande kommentarer, för att logiskt gruppera olika delar av HTML-dokumentet (för utvecklaren), eller kanske för att skriva en TODO-notis om någonting som måste bättras på senare.</p><p>Kommentarer är alltså en facilitet som existerar för att underlätta vårt arbete som programmerare. Kommentarer i HTML har ingen effekt på sidan mer än att de syns i källkoden. Kom ihåg att vem som helst kan visa källkoden för en HTML-sida genom att öppna den i en textredigerare istället för en webbläsare. Alltså behöver vi inse att vem som helst kommer kunna se våra HTML-kommentarer om de vill. Alltså är det inte en smart idé att skriva känslig information (som vi inte vill läcker ut) i våra kommentarer.</p><p>Beakta nedan exempel som understryker faktumet att kommentarer inte syns när en webbsida renderas.</p><p>Följande HTML...</p><pre><code class="language-markup">&lt;p&gt;Detta syns&lt;/p&gt;
&lt;!-- Detta syns inte --&gt;</code></pre><p>...renderar följande resultat...</p><div class="panel panel-default"><div class="panel-body">Detta syns<!-- Detta syns inte--></div></div><p>Men kommentaren i ovan exempel kommer alltså fortfarande att synas i källkoden. Så om användaren skulle högerklicka och välja "View Source" ("Visa källkod", eller dyl.), alternativt inspektera texten med webbläsarens <a href="http://en.wikipedia.org/wiki/Web_development_tools">Webbutvecklarverktyg</a> så kommer denne att kunna se kommentaren. Prova själv!</p><h3>Dokumenstruktur</h3><p>Vi har nu lärt oss att HTML-dokument modellerar trädstrukturer. Men hur ska då en trädstruktur för ett HTML-dokument se ut? Ett HTML-dokument behöver vara valit ("valid"), enligt standarden, för att kunna renderas korrekt av en webbläsare. Eftersom webbläsare har lite varierande implementationer av HTML-standarden så betyder det att dokumen egentligen inte måste följa standarden till hundra procent. Men det är bra att sträva efter det.</p><p>Men för att återgå till ämnet. Det finns några saker ett HTML-dokument alltid måste innehålla. En dokumenttypsdeklaration (doctype), ett html-rot-element, ett huvud med en titel, och en kropp. Det minsta html-dokumentet vi kan konstruera som fortfarande uppfyller standarden (html5) är följande:</p><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Stora hundhemsidan &lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Låt oss försöka visualisera samma dokument som ovan i en hierarkisk struktur av "lådor i lådor". En låda "i" en låda representerar alltså en barn-förälderrelation, medan en låda "bredvid" en annan låde representerar en syskonrelation.</p><div class="panel panel-default html-box"><div class="panel-heading">&lt;html&gt;</div><div class="panel-body"><div class="panel panel-default html-box"><div class="panel-heading">&lt;head&gt;</div><div class="panel-body"><div class="panel panel-default html-box"><div class="panel-heading">&lt;title&gt;</div><div class="panel-body">Stora hundhemsidan<k></k></div></div><k></k></div></div><div class="panel panel-default html-box"><div class="panel-heading">&lt;body&gt;</div><div class="panel-body">[empty]<k></k></div></div><k></k></div></div><p>Jämför ovan bilder av "boxar i boxar" med den faktiska HTML-koden i bilden högre upp. Försök förstå varför vi har ritat bilden på det sätt vi har ritat den. Notera att <code>DOCTYPE</code>-deklarationen inte är med i ovan exempel.</p><p>När vi ändå är i farten med att försöka visualisera dokumenthierarkier. Låt oss även visualisera ovan som en indenterad lista.</p><pre>DOCTYPE
html
  head
    title
      [text]
  body
    [empty]</pre><p>Detta med indentering leder oss även in på en meningsfull vana html-utvecklare respekterar.</p><blockquote><p>Om en tag är ett barn till tag:en ovan, indentera ett steg.</p></blockquote><p>Notera alltså hur <code>title</code> är indenterad i relation till <code>head</code>, men hur <code>body</code><i>inte </i>är indenterad i relation till <code>head.</code></p><p>Återigen. Vi har inte bara slängt ihop ovan text lite hursomhelst. Utan det indenterade dokumentet är en representativ omskrivning av det tidigare diskuterade HTML-dokumentet. Återigen. Jämför denna indenterade version med den faktiska HTML-koden. Föräldra-barnrelationer defineras alltså nu genom indentering in. Syskonrelationer kan vi identifiera genom att hitta element som befinner sig på samma horisontella nivå under en och samma förälder.</p><p>Detta leder oss in på en viktig poäng som du kanske redan förstått. När vi öppnar ett element måste vi stänga det innan vi stänger dess förälder.</p><blockquote>Alla barnelement behöver stängas innan vi stänger föräldern.</blockquote><div class="panel panel-danger"><div class="panel-heading">Icke-välformatterad HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;article&gt;
    &lt;p&gt;
        Hello world...
    &lt;/article&gt;
&lt;/p&gt;</code></pre></div></div><div class="panel panel-success"><div class="panel-heading">Välformatterad HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;article&gt;
    &lt;p&gt;
        Hello world...
    &lt;/p&gt;
&lt;/article&gt;</code></pre></div></div><h3>Indentering</h3><p>förhoppningsvis har du under läsningens gång märkt att vi i våra kodexempel <a href="http://sv.wikipedia.org/wiki/Indentering">indenterar</a> koden. Det vill säga "drar in" vissa linjer lite till höger. Placerar några mellanslag före vissa rader. Detta gör vi för att öka läsbarheten av koden.</p><p>Indentering är kotym bland programmerare och möjligheten till indentering finns i nästan alla moderna språk. I <a href="http://en.wikipedia.org/wiki/Python_(programming_language)">vissa</a> är det till och med obligatoriskt. Indentering kan i början kännas onödigt och krångligt. Men håll uppe glöden. Du kommer att tjäna på det i längden. De som läser din kod kommer tjäna på det. När du ber någon om hjälp kommer du tjäna på det. Indentering är en av de viktigaste kotymerna vi programmerare har.</p><p>Ok, så hur indenterar man då? Låt oss börja med några exempel.</p><div class="panel panel-success"><div class="panel-heading">Korrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;
    &lt;span&gt;Detta är ok!&lt;/span&gt;
&lt;/p&gt;</code></pre><pre><code class="language-markup">&lt;p&gt;
    &lt;span&gt;
        Också ok!
    &lt;/span&gt;
&lt;/p&gt;</code></pre><pre><code class="language-markup">&lt;p&gt;&lt;span&gt;Också ok men svårläsligt!&lt;/span&gt;&lt;/p&gt;</code></pre></div></div><div class="panel panel-danger"><div class="panel-heading">Inkorrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;
&lt;span&gt;Strunta _inte_ i indenteringen!&lt;/span&gt;
&lt;/p&gt;</code></pre><pre><code class="language-markup">&lt;p&gt;
    Indentera barn...
&lt;/p&gt;
    &lt;p&gt;
        ...men inte syskon!
    &lt;/p&gt;</code></pre></div></div><p>Ett enkelt sätt att veta när man ska indentera &mdash; alltså flytta en rad inåt, är följande minnesregel. Om vi öppnar ett element, ska allt som efterföljer indenteras, ända tills vi stängt elementet.</p><blockquote>Alla barn till ett element ska indenteras ett "steg".</blockquote><p>Öppningstaggar och stängningstaggar ska alltså vara indenterade in till samma nivå. Om vi indenterar korrekt kommer det vara busenkelt att snabbt identifiera vilka element som är barn till vilka element. Vilka element som är syskon. Vart ett element stängs. Och så vidare, och så vidare.</p><p>Att ta med sig ifrån det här stycket är alltså &mdash; indentera! Du kommer snabbt märka att de flesta programmerare är allergiska emot dålig indentering. Så skippa bara indenteringen om du vill skapa dig fiender :)</p><h3>Ett komplett dokument</h3><p>Ett validerande HTML-dokument måste alltså innehålla ett par saker. En dokumenttypsdeklaration, ett huvud, en titel och en kropp. Nyssnämnt direktäversättningar av de korrekta termerna <code>DOCTYPE</code>, <code>HEAD</code>, <code>BODY</code> och <code>TITLE</code>. Låt oss återgå till tidigare nämnt kod-exempel (se nedan), och fundera över hur dessa element ska nästlas i varandra. Med andra ord, låt oss diskutera vilka element som är barn/föräldrar till vilka.</p><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Page about kittenz!&lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Notera även att det absolut yttersta elementet är <code>&lt;html&gt;</code>. Ett HTML-dokument måste innehålla ett och endast ett <code>&lt;html&gt;</code>-element. I detta element måste det finnas ett och endast ett <code>&lt;head&gt;</code>- och respektive <code>&lt;body&gt;</code>-element. I huvudet måste vi även ange en sidtitel med hjälp av <code>&lt;title&gt;</code>. Detta är det minsta dokumentet vi kan skapa som validerar, och det är även så här <em>alla</em> html-dokument är strukturerade i botten.</p><h4>Head (meta-data)</h4><p>Så vad lägger vi då inanför <code>&lt;head&gt;</code>-taggarna? Det korta svaret är: meta-data.</p><p>Det längre svaret är att vi även laddar in externa referenser i huvudet. Följande kodruta är ett exempel på hur ett set av <code>&lt;head&gt;</code>-taggar skulle kunna se ut.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på HEAD</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">...
&lt;head&gt;
  &lt;title&gt; Hover cat &lt;/title&gt; 
  &lt;link rel="stylesheet" href="stylesheets/main.css"&gt;
  &lt;script src="javascripts/main.js"&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="keywords" content="Kittens,Hovercrafts"&gt;
&lt;/head&gt;
...</code></pre></div></div><p>Låt oss diskutera ovan kod rad för rad. </p><table class="table table-striped"><tr><th>Rad</th><th>Förklaring</th></tr><tr><td>3</td><td>Den titel som visas högst upp i en sidans "tab" i en webbläsare.</td></tr><tr><td>4</td><td>Säger åt webbläsaren att ladda in en <a href="#stylesheets">Stylesheet</a>-fil, som finns på platsen definerad av <code>href="sökväg-till-filen-här"</code>.</td></tr><tr><td>5</td><td>Säger åt webbläsaren att ladda in en <a href="#javascript">JavaScript</a>-fil, som finns på platsen definerad av <code>src="sökväg-till-filen-här"</code>.</td></tr><tr><td>6</td><td>Berättar för webbläsaren vilken "<a href="http://www.joelonsoftware.com/articles/Unicode.html">character encoding</a>" sidan är skriven i, så att tecken som åäö kan visas korrekt.</td></tr><tr><td>7</td><td>Definerar ett par <a href="http://www.w3schools.com/tags/tag_meta.asp">keywords</a> för sidan. Denna information används av bl.a. sökmotorer för att "förstå" sidans innehåll.</td></tr></table><h4>Body (Sidans faktiska innehåll)</h4><p>Om <code>&lt;head&gt;</code> beskrivs som sidans meta-content &mdash; alltså content om content. Då skulle vi kunna säga att <code>&lt;body&gt;</code> är sidans faktiska content.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på innehåll i BODY</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">...
&lt;body&gt;
  &lt;h2&gt; Sidans titel &lt;/h2&gt; 
  &lt;p&gt; Det här är en paragraf med text. &lt;p&gt;
  &lt;p&gt;
      Och det här är en till, som innehåller en
      &lt;a href="http://uu.se"&gt;länk&lt;/a&gt; till UU.
  &lt;p&gt;
&lt;/body&gt;
...</code></pre></div></div><div class="page-header"><h2 href="#02-02-html-common-elements" name="02-02-html-common-elements" id="02-02-html-common-elements">Vanligt förekommande element</h2></div><p>Låt oss nu bekanta oss med de vanligast förekommande elementen och relevanta attribut.</p><h3>Paragrafer och rubriker</h3><p>Låt oss börja genom att diskutera de två kanske vanligaste elementen. Paragrafer och rubriker. Paragrafer skapar vi genom att använda oss av elementet <code>&lt;p&gt;</code> och element genom att använda någon av rubrikelementen.</p><p>Ett exempel på användande av paragrafer följer nedan.</p><pre><code class="language-markup">&lt;p&gt;En paragraf denoterar alltså ett stycke text.&lt;/p&gt;
&lt;p&gt;Varje ny paragraf börjar, om inte annat anges, på en ny rad.&lt;/p&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>En paragraf denoterar alltså ett stycke text.</p><p>Varje ny paragraf börjar, om inte annat anges, på en ny rad.</p></div></div><p>De flesta dokument består ju inte bara av paragrafer utan även av rubriker. Vi skapar rubriker i HTML genom att använda oss av <code>&lt;hX&gt;</code>, där X ersätts med en siffra ifrån <code>1-6</code>. Alltså:</p><pre><code class="language-markup">&lt;h1&gt;En rubrik&lt;/h1&gt;
&lt;p&gt;Följd av en paragraf.&lt;/p&gt;
&lt;h2&gt;En underrubrik&lt;/h2&gt;
&lt;p&gt;Ytterligare en paragraf.&lt;/p&gt;</code></pre><p>Och så kan vi fortsätta hela vägen ned till <code>h6</code>. Rubriken <code>h1</code> är alltså den viktigaste rubriken (den högsta nivån av rubriker) och <code>h6</code> den minst viktiga. Resten följer förstås i inbördes ordning däremellan.</p><p>Om vi skulle exemplifera användandet av rubriker på den här sidan, löper vi en stor risk att skapa förvirring kring vad som faktiskt är rubriker och vad som är exempel på rubriker. Så för att se ett exempel på hur rubriker fungerar så råder vi dig att ta en snabb titt på ett <a href="http://www.w3schools.com/html/tryit.asp?filename=tryhtml_headers">exempel ifrån w3schools</a>. </p><h3>Fetstil och kursivitet</h3><p>Låt oss nu diskutera de vanligaste textformatteringselementen. Fetstil och kursivitet. För att uppnå fetstilt text, kan vi välja att använda någon av elementen <code>&lt;b&gt;</code> (bold) eller <code>&lt;strong&gt;</code>.</p><pre><code class="language-markup">All text &lt;b&gt;inom ett b-element&lt;/b&gt;
eller ett &lt;strong&gt;strong-element&lt;/strong&gt;
renderas i fetstil.</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">All text <b>inom ett b-element</b> eller ett <strong>strong-element</strong> renderas i fetstil.</div></div><p>Om vi istället skulle vilja ha kursiv text, även kallad <i>italics</i>, så kan vi välja att använda något utav elementen <code>&lt;i&gt;</code> (italics) eller <code>&lt;em&gt;</code> (emphasis).</p><pre><code class="language-markup">All text &lt;i&gt;inom ett i-element&lt;/i&gt;
eller ett &lt;em&gt;em-element&lt;/em&gt;
renderas som kursiv text.</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">All text <i>inom ett i-element</i> eller ett <em>em-element</em> renderas som kursiv text.</div></div><p>Men varför finns det två sätt att denotera fetstil text och två sätt att denotera kursiv text? Du kommer lättare förstå skillnaden mellan de olika elementen när vi börjar diskutera semantisk signifikans. Men som kort svar så denoterar alltså t.ex. <code>i</code> mer presentation snarare än semantik, och <code>em</code> mer semantik snarare än presentation. Föreställ dig en blind person. Den visuella effekten av kursiv text är inte av signifikans för den blinde. Men idéen <em>extra emfas</em> är signifikant. Att det sedan råkar sig så att visualiseringen av extra emfas sker genom samma visuella effekt som kursivitet är alltså i någon bemärkelse ett sammanträffande.</p><h3>Listor</h3><p>För att skapa punktlistor i HTML behöver vi kombinera två olika element. Ett element som denoterar vilken typ av lista vi vill skapa. Innuti detta element behöver vi upprepat använda ett annat element &mdash; en gång per punkt i vår punktlista.</p><p>Vi nämnde alltså att det första elementet denoterar vilken typ av lista vi vill skapa. Det finns, i HTML, alltså två typer av listor &mdash; numrerade listor och onumrerade listor. Numrerade listor denoteras genom elementet <code>&lt;ol&gt;</code> (<em>ordered lists</em>) och onumrerade listor genom elementet <code>&lt;ul&gt;</code> (<em>unordered lists</em>).</p><p>Som nämnt behöver vi sedan denotera varje element (punkt) i listan för sig. Detta gör vi helt enkelt genom att använda elementet <code>&lt;li<&gt;< code=""> (list item). Samma element används alltså oavsett om det skall användas i en numrerad eller onumrerad lista.</&gt;<></code></p><p>Låt oss se till ett exempel på en onumrerad lista.</p><div class="panel panel-default"><div class="panel-heading">Exempel på onumrerad lista</div><div class="panel-body"><pre><code class="language-markup">&lt;ul&gt;
  &lt;li&gt;Katt&lt;/li&gt;
  &lt;li&gt;Hund&lt;/li&gt;
  &lt;li&gt;Sköldpadda&lt;/li&gt;
&lt;/ul&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><ul><li>Katt</li><li>Hund</li><li>Sköldpadda</li></ul></div></div></div></div><p>Lagom intuitivt så är alltså skillnaden mellan en numrerad och en onumrerad lista att den numrerade listan använder nummer istället för symboler framför varje element i listan.</p><div class="panel panel-default"><div class="panel-heading">Exempel på numrerad lista</div><div class="panel-body"><pre><code class="language-markup">&lt;ol&gt;
  &lt;li&gt;Katt  &lt;/li&gt;
  &lt;li&gt;Hund&lt;/li&gt;
  &lt;li&gt;Sköldpadda&lt;/li&gt;
&lt;/ol&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><ol><li>Katt</li><li>Hund</li><li>Sköldpadda</li></ol></div></div></div></div><p>Självklart är vi inte bundna till att använda just dessa typer av symboler och/eller nummer framför varje listelement. Istället för att använda vanliga siffror skulle vi t.ex. kunna använda romerska siffror. Alltså <code>I, II, III, IV</code> o.s.v. Detta kommer vi att exemplifiera när vi börjar tala om css.</p><h3>Tabeller</h3><p>I de tidigare dagarna av HTML använde kreativa webbutvecklare ofta tabeller för att strukturera upp hela webbsidor. Tabeller i HTML är alltså helt vanliga tabeller. Kolumner, rader, rubriker och inget mer. Men eftersom tabeller betedde sig på ett mycket förutsägbart sätt så upptäckte man att det var tacksamt att strukturera sina sidor med hjälp av tabeller.</p><p>Idag används tabeller nästan uteslutande för att representera tabulär data. Såsom elementet rimligen var tänkt att användas ifrån början.</p><p>När vi kommer in på diskussionen om semantisk signifikans så kommer du förhoppningsvis förstå varför det är både viktigt och naturligt att inte använda tabeller till annat än representation av tabulär data. Men återigen handlar det om distiktionen mellan hur saker ser ut och vad de faktiskt innebär. Användandet av tabeller implicierar att ett stycke data kan behandlas tabulärt. Så om vi använder tabeller för att visuellt strukturera vår sida &mdash; så implicerar vi att vår sida är en enda stor tabell av strukturerad data. Vilket oftast inte är sant.</p><p>När vi diskuterar tabeller så finns det egentligen fyra element som vi behöver lära oss. För att skapa en tabell börjar vi alltid med elementet <code>&lt;table&gt;</code>. Detta element enkapsulerar hela tabellen. Alla dess rader, kolumner och data.</p><p>Innanför elementet <code>table</code> kan vi sedan placera ett valfritt antal element av typen <code>&lt;tr&gt;</code> (<em>table row</em>). Detta element skapar nya tabellrader. När vi skapar tabeller i HTML behöver vi alltså specificera kolumnerna i raderna och inte tvärtom. Syntaxen hade ju förstås likaväl kunnat fungera tvärtom men nu är fallet inte så.</p><blockquote>I tabeller specificerar vi först raderna &mdash; sedan kolumnerna. Aldrig tvärtom.</blockquote><p>Innanför elementet <code>tr</code> kan vi sedan placera ett valfritt antal element av typen <code>&lt;td&gt;</code> (<em>table data</em>. För att underlätta den mentala modellen kan du alltså tänka att elementet <code>td</code> skapar kolumner. Om vi använder <code>tr</code> för att skapa rader i tabellen så använder vi <code>td</code> för att skapa kolumner i en rad.</p><p>Det sista elementet vi kan använda när vi arbetar med tabeller är <code>&gt;th&lt;</code> (<em>table header</em>). Detta element kan ersätta vilket <code>&lt;td&gt;</code> som helst. Vi använder alltså elementet för att denotera att en viss cell inte innehåller vanlig celldata. Utan snarare bör behandlas som en rubrik.</p><p>Låt oss se till ett komplett exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på tabell</div><div class="panel-body"><pre><code class="language-markup">&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Djur&lt;/th&gt;
    &lt;th&gt;Storlek&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Golden Retriever&lt;/td&gt; 
    &lt;td&gt;Stor&lt;/td&gt; 
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Norsk Skogskatt&lt;/td&gt; 
    &lt;td&gt;Liten&lt;/td&gt; 
  &lt;/tr&gt;
&lt;/table&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><table style="width:auto;margin:auto 0;" class="table table-bordered"><tr><th>Djur</th><th>Storlek</th></tr><tr><td>Golden Retriever</td><td class="text-center">L</td></tr><tr><td>Norks Skogskatt</td><td class="text-center">S</td></tr></table></div></div></div></div><p>Var inte rädd för att använda tabeller! Men kom alltså ihåg att tabeller endast ska användas för data som är rimlig att presentera i tabeller.</p><h3>Definitionslistor</h3><p>Kommer snart...</p><h3>Bilder  </h3><p>Dags att bli visuella och diskutera hur vi får in bilder i våra HTML-dokument. Som vanligt när det kommer till HTML är det egentligen ganska enkelt. Genom att använda <code>&lt;img&gt;</code>-taggen tillsammans med attributet <code>src</code> kan vi infoga bilder i våra dokument. Låt oss se till ett exempel.</p><pre><code class="language-markup">&lt;img src="http://placekitten.com/g/60/60"&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><img src="http://placekitten.com/g/60/60" alt="En m&#xE4;sterkatt utan st&#xF6;vlar"></div></div><blockquote class="text-info">Prova gärna att klistra in adressen som bilden ovan pekar mot i webbläsaren och kolla vad som finns under adressen. </blockquote><p>Notera alltså att att adressen ovan (som antytt) pekar mot en URL som renderar en bild. (Tjänsten <a href="http://placekitten.com" target="_blank">placekitten</a> erbjuder helt enkelt bilder i olika storlekar under alla sina URL:er.) Således kan vi alltså ersätta den adressen med en bild som finns lokalt på vår dator, på vår egen server eller någon annanstans på internet. Attributet <code>src</code> förväntar sig helt enkelt en adress till en bild.</p><h4>Alternativ</h4><p>Men vad händer om en bild inte kan renderas? Och vad händer när en <a href="http://en.wikipedia.org/wiki/Screen_reader" target="_blank">screen reader</a> upptäcker en bild. In kommer <code>alt</code>-attributet och räddar dagen! Låt oss se till ett exempel innan vi går vidare.</p><div class="panel panel-default"><div class="panel-heading">Exempel på användning av alt-attributet</div><div class="panel-body"><pre><code class="language-markup">&lt;img src="http://placekitten.com/g/60/60" alt="En mästerkatt utan stövlar"&gt;</code></pre></div></div><p>Om vi nu försöker nå ovan bild genom någon form av läsare som inte kan rendera bilder så kommer vi istället få texten <em>En mästerkatt utan stövlar</em>. I annat fall kommer bilden att visas som vanligt och texten inte synas. Tänk på att attributet <code>alt</code> krävs för att en <code>&lt;img&gt;</code>-tagg ska vara <a href="http://www.w3schools.com/tags/tag_img.asp" target="_blank">valid</a>.</p><blockquote class="text-danger">Attributen <code>alt</code> och <code>src</code> krävs båda för att en <code>&lt;img&gt;</code>-tagg ska vara valid.</blockquote><h4>Bildtexter</h4><p>Om vi vill lägga till en bildtext till vår bild kommer de nya html5-elementen <code>&lt;figure&gt;</code> och <code>&lt;figcaption&gt;</code> väl till pass.</p><p>Dessa är <em>semantiska</em> attribut snarare än <em>visuella</em>. Med andra ord. Visst har <code>&lt;p&gt;</code>-taggen en semantisk innebörd &mdash; en paragraf representerar ju semantiskt ett stycke text, och således rimligen en tanke. Men i HTML så resulterar ju även en paragraf i någonting visuellt skillt ifrån plain-text och därmed </p><p>Elementen <code>figure</code> och <code>figcaption</code> är båda <em>semantiska</em> element snarare än direkt <em>visuella</em>. Med andra ord, om vi skulle välja att bara skriva ut vår bild följd av ett helt vanligt paragraf-element som innehåller vår bildtext, så skulle det visuella resultatet bli ungefär likadant som om vi använde figure och figcaption. Poängen med att dock istället använda figure och figcaption är att vi <a href="http://en.wikipedia.org/wiki/Semantic_HTML" target="_blank">berikar dokumentet med semantik</a>. Plus att vi har ett enhetligt sätt att angripa bildtexter ifrån våra stilmallar (css).</p><blockquote class="text-success"><code>&lt;figure&gt;</code> och <code>&lt;figcaption&gt;</code> är båda element med semantisk mening.</blockquote><div class="panel panel-default"><div class="panel-heading">Exempel på figurannotation med figcaption</div><div class="panel-body"><pre><code class="language-markup">&lt;figure&gt;
  &lt;img src="http://placekitten.com/g/130/130"&gt;
  &lt;figcaption&gt;
    En mästerkatt utan stövlar.
  &lt;/figcaption&gt;
&lt;/figure&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><figure><img src="http://placekitten.com/g/130/130" alt="En m&#xE4;sterkatt utan st&#xF6;vlar"><figcaption>En mästerkatt utan stövlar.</figcaption></figure></div></div><div class="page-header"><h2 href="#02-03-html-semantic-elements" name="02-03-html-semantic-elements" id="02-03-html-semantic-elements">Semantiska element</h2></div><p>När vi pratar om semantisk signifikans så pratar vi om vad någonting (t.ex.) ett stycke text har för kontextuell betydelse. Lite som att läsa emellan raderna. Vi har i tidigare kapitel flera gånger nämnt termerna semantik och semantisk signifikans. Nu är det dags att faktiskt bena ut vad det handlar om.</p><p>Intågandet av den "levande standarden" <a href="http://www.w3schools.com/html/html5_intro.asp">HTML5</a> &mdash; kan anses som en stark drivkraft i diskussionen om semantik och webben. Med HTML5 deprekerade man ett antal element som bl.a. var allt för fokuserade på <em>presentation</em>. Istället introducerade man ett par intressanta och nyttiga element som fokuserade på <em>semantik</em>.</p><p>Men vad pratar vi egentligen om när vi pratar om semantik? Och vad menar vi egentligen när vi säger att de var <em>för</em> fokuserade på presentation? Är inte det just presentation som är poängen med HTML? Att presentera information för en användare.</p><h3>Content är inte presentation</h3><p>Idéen om att <a href="http://en.wikipedia.org/wiki/Separation_of_presentation_and_content">separera presentation ifrån content</a> handlar i essens att det går att skilja på presentation (representation) av content ifrån faktiskt contentet. Med andra ord &mdash; att representationen av information inte är detsamma som informationen i sig. Låt oss omformulera oss &mdash; att uttrycka en tanke är inte samma sak som essansen av tanken. Den talade tanken är inte samma sak som tanken. And down the rabbit hole it goes...</p><p>Vi sniffar nu lite i gränslandet till filosofi. Vad är kunskap? Är det skillnad på kunskap och kommunicerad kunskap? Om vi kan lagra kunskap som är separerad ifrån representation borde vi inte då kunna skapa maskiner som är lika smarta som vi? Vi närmar oss kunskapsrepresentation. Vi närmar oss artificiell intelligens.</p><p>Som du märker finns det mycket att gräva i. Och det är därför vi uttrycker oss i termer av "down the rabbit hole". Men utan att gräva ned oss allt för djupt åt något håll så finns det intressanta potentiella förmåner vi kan dra nytta av genom att inse att presentation och content inte är samma sak. Och sedan agera därefter.</p><h3>Alla element denoterar någon semantik</h3><p>Varje gång vi i HTML använder ett element så säger vi någonting om det content som vi väljer att placera i just det elementet. Ta t.ex. <code>&lt;em&gt;</code>-elementet. Ett element som används för att denotera emfas. Emfas är inte bara någonting som är relaterat till presentation. Fundera över följande meningar.<ul><li>"Hon sa att du <em>skulle</em> göra det."</li><li>"Hon sa att <em>du</em> skulle göra det."</li><li>"<em>Hon</em> sa att du skulle göra det."</li></ul></p><p>Förhoppningsvis känner du, både ifrån verkliga livet och ifrån skolan, igen att emfas kan göra att samma mening betyder helt olika saker. Ovan tre meningar får tre helt olika innebörder beroende på hur vi väljer att intonera. Alltså vart vi väljer att lägga emfas.</p><h3>Accessibility</h3><p>Föreställ dig en blind person. Hur läser en blind person din webbsida? Rimligen med någon form av <a href="http://en.wikipedia.org/wiki/Screen_reader">screen reader</a>. En screen reader (t.ex.) är en maskin som läser källkoden för din webbsida och genom text-till-tal-syntes sedan läser upp relevant text på webbsidan.</p><p>När en screen-reader ska "läsa" våra webbsidor så skapar den egentligen en ny presentation. I termer av content och presentation. Screen-readern bryr sig egentligen bara om vårt content. Den vill identifiera vårt content, och sedan intelligent återrepresentera detta för användaren i ett format som är anpassat för denne.</p><p>Men vad är det screen readern behöver veta? Rimligen behöver den t.ex. veta vad som är meny-länkar så att den kan ge användaren en möjlighet att navigera ifrån den sidan den är på. Rimligen behöver den veta vilken del av sidan som är "huvud-content" (t.ex. en artikel) så att den inte börjar läsa upp annonserna för användaren. Rimligen behöver den veta vad artikeln har för rubrik så att den kan läsa upp den först, och sedan pausa i någon sekund så att användaren, lyssnaren, förstår att det är en rubrik. Rimligen behöver den veta vilka ord som ska läsas med extra emfas så att vi inte råkar ut för missförstånd såsom i det tidigare exemplet med punktlistan.</p><p>Detta är alltså varför det är viktigt att vi har element såsom t.ex. <code>&lt;em&gt;</code> som gör att vi kan denotera emfas. Eller <code>&lt;nav&gt;</code> för att kunna denotera meny-navigation. Detta är förstås inte ens en bråkdel av alla element med semantisk signifikans som existerar i HTML. Men vi återkommer till dessa strax.</p><h3>Bortom accessibility </h3><p>Låt oss bara understryka att den som tror att idéen om att separera content ifrån presentation endast är en tillgänglighetsfråga (accessibility) &mdash; är naiv. Vi diskuterar den blinde användaren för att ha ett exempel att utgå ifrån men både problemet och fördelarna gömmer sig mycket djupare än så. Vi är på väg mot en webb där <a href="http://en.wikipedia.org/wiki/Semantic_Web">information är fri ifrån presentation</a>. Där en multitud av maskiner kan läsa informationen på olika sätt. Allt ifrån TV-apparater till  <a href="http://en.wikipedia.org/wiki/Google_Glass">glasögon</a>.</p><p>Kommer snart...</p><h3>Maskinläsbarhet</h3><p>Kommer snart...</p><h3>Semantiska element i HTML5</h3><p>Kommer snart...</p><h3>Uppmaningar</h3><p>Poängen med detta kapitel är egentligen enkel. Vi vill plantera ett frö som förhoppningsvis gör att du börjar tänka på varför du väljer ett element över ett annat. Vi vill att du börjar tänka på att det finns en poäng med att hålla sin markup så "ren", minimalistisk och semantisk som möjligt. Vi vill att du börjar vara medveten om att alltid separera content ifrån presentation.</p><div class="page-header"><h2 href="#02-04-html-links" name="02-04-html-links" id="02-04-html-links">Sökvägar och Hyperlänkar</h2></div><p>Det, för HTML, kanske mest representativa elementet måste ju vara länken. En klickbar yta på skärmen som navigerar oss ifrån en webbsida till en annan. Den tagg vi använder för att denotera en länk är <code>&lt;a&gt;</code>. Ett komplett exempel på användandet av en länk skulle kunna se ut som följande.</p><pre><code class="language-markup">&lt;a href="http://www.example.com"&gt;Klicka på mig&lt;/a&gt;</code></pre><p>Vilket skulle rendera följande resultat:</p><div class="panel panel-default"><div class="panel-body"><a href="http://example.com">Klicka på mig</a></div></div><p>Notera alltså användandet av attributet <code>href</code> i ovan exempel. Attributets namn är en förkortning av "hyper reference". Det kan vara bra att fundera över vad de olika förkortningarna du kommer i kontakt med faktiskt éxpanderar till. Då blir det lättare att komma ihåg/på vad attributen faktiskt gör.</p><h3>Sökvägar</h3><p>Attributet <code>href</code> specificerar alltså en sökväg till en annan webbsida. Men vad kan ge attributet för olika typer av värden? När vi pratar om sökvägar är det viktigt att förstå att det finns två sätt att ange sökvägar.</p><ol><li>Absoluta sökvägar</li><li>Relativa sökvägar</li></ol><p>Dessa begrepp är generella och stämmer precis lika bra överens med sökvägar i operativsystemet på din dator. För att förstå skillnaden mellan de två, låt oss använda operativsystemet som exempel.</p><p>Under <i>Microsoft Windows</i> så skulle ett exempel på en absolut sökväg t.ex. vara <code>C:/Users/Jon Snow/Pictures/me.jpg</code>. Under samma operativsystem skulle ett exempel på en relativ sökväg kunna vara <code>Pictures/me.jpg</code>. Den huvudsakliga skillanden emellan de två exemplena är alltså att den första börjar med <code>C:/</code>. Förhoppningsvis är du familjär med att varje hårddisk (fysisk eller virtuell) under Windows blir tilldelad en enhetsbokstav, såsom C:, D:, E: o.s.v. Den absoluta sökvägen i ovan exempel utgick alltså ifrån en av dessa enheter. Den relativa däremot utgår inte ifrån någonting explicit. Istället utgår den ifrån den mapp "du är i just nu".</p><p>Det lättaste sättet att förstå sökvägar är att reflektera över hur vi själva navigerar igenom filsystemet i våra operativsystem. Tänk på det. När vi letar efter en fil på hårddisken så öppnar vi först någon mapp. Sedan finns det två saker vi kan göra:</p><ol><li>Öppna en ny mapp i den befintliga mappen,</li><li>Gå ett steg uppåt/bakåt, eller</li></ol><p>Det är även dessa tre verktyg vi har att arbeta med när vi specificerar sökvägar. Varje ord motsvarar en mapp eller en fil. Varje slash-tecken (<code>/</code>) motsvarar idéen om att klicka sig in i en ny mapp. Där ordet efter slash-tecknet denoterar namnet på mappen. Notationen punkt-punkt (<code>..</code>) motsvarar idéen om att gå upp/bakåt en mapp i hierarkin.</p><p>Vi pratade tidigare lite om absoluta och relative sökvägar i relation till <i>Microsoft Windows</i>. Låt oss även prata om absoluta och relativa sökvägar i <a href="http://en.wikipedia.org/wiki/Unix-like">*nix-baserade system</a>. I nästan alla operativsystem fungerar idéen om sökvägar på samma sätt. Punkt refererar relativt till den nuvarande mappen. Punkt-punkt till en mapp uppåt. Ett ord till en fil eller mapp i nuvarande mapp. Och slash används för att koppla ihop dessa. Varje slash denoterar alltså i någon bemärkelse "nästa steg".</p><blockuote>Slash-tecknet denoterar "nästa steg" i en sökväg.</blockuote><p>I t.ex. <i>Mac OS</i> och <i>Linux</i> så fungerar alltså sökvägar på samma sätt som ovan nämnt, med en skillnad. För att specificera absoluta sökvägar i *nix-baserade system så anger vi inte namnet på en enhet (ex: <code>C:</code>) såsom i Windows. Isället börjar vi helt enkelt med tecknet slash (<code>/</code>). Följande är alltså en absolut sökväg:</p><pre><code>/Users/jon-snow/pictures/me.jpg</code></pre><p>Om vi i ett *nix-baserat system vill nå en annan enhet, på samma sätt som vi i Windows kan nå ex. D: så fungerar det ofta som så:</p><pre><code>/Volumes/MyOtherDisk</code></pre><p>För att sammanfatta absoluta och relativa sökvägar så vill vi understryka att det egentligen alltså är mycket enkelt. En relativ sökväg utgår ifrån den mapp där den som använder sökvägen befinner sig. En absolut sökväg utgår ifrån "roten" av den nuvarande enheten.</p><blockquote>En relativ sökväg utgår ifrån nuvarande mapp. En absolut sökväg utgår ifrån någontings rot.</blockquote><p>Förhoppningsvis blir du lite förvirrad av att ovan uttrycker sig i termer av "någontings rot". Det finns olika typer av absoluta sökvägar när vi börjar tala om nätverk, och det är dessa vi ska se närmare på strax.</p><h3>Protokoll och URL:er</h3><p>För att kunna diskutera sökvägar på internet behöver vi skapa oss en förståelse för två saker: protokoll och URL:er. Låt oss diskutera de en för en.</p><p>Som du nu vet baseras webbsidor på standarden HTML. När vi med andra ord ber webbläsaren hämta en webbsida så anropar den en server som ger oss ett response som innehåller ett HTML-dokument. Vi har kort diskuterat request-response-modellen. Men vi har inte diskuterat de protokoll som möjliggör det. TCP, IP och HTTP bl.a. För att hålla oss fokuserade kommer vi inte att gräva i dessa. Men för att kunna intelligent angripa idéen om URL:er måste vi skapa oss en viss förståelse för protokollet HTTP.</p><p>Men först, vad är ett protokoll? Kom ihåg att vi sa att en klient skickar ett request och en server svarar med ett response. Ett protokoll är helt enkelt en överenskommelse kring hur klienten och servern ska tala med varandra. När vi skickar saker över nätet så skickar vi de i fragmenterade paket och för att routrar, ISP:er och servrar ska veta vart våra paket är på väg, behöver vi protokoll. Här kommer TCP/IP in i bilden. För att servern ska kunna förstå vårt request och för att webbläsaren ska kunna förstå serverns response behöver vi protokollet HTTP (HyperText Transfer Protocol). Protokoll kan alltså liknas vid ett överenskommet språk emellan två parter.</p><blockquote>För att två parter ska kunna kommunicera krävs ett överenskommet språk &mdash; ett protokoll.</blockquote><p>Du har säkert kommit i kontakt med både protokollet <code>http</code> och den säkrare varianten <code>https</code>. Varje gång du skriver in en adress i webbläsaren så anger vi <code>http://</code>. Om vi inte gör det själva är webbläsarna idag tillräckligt smarta för att slänga in det protokollet åt oss.</p><p>Nu när vi vet vad ett protokoll är &mdash; vad är då en URL (Uniform Resource Locator)? En URL är helt enkelt en webbadress. Den pekar på en plats på internet där en webbresurs bör finnas.</p><blockquote>En URL är en webbadress till en resurs på internet.</blockquote><p>När vi skriver in en webbadress i vår webbläsare så skriver vi alltså in en URL. Som tidigare nämnt så hjälper de flesta moderna webbläsare oss att skriva korrekta URL:er. En URL måste nämligen bl.a. innehålla ett protokoll. Var sig det är HTTP, HTTPS, FTP, SFTP o.s.v.</p><h3>Webbadresser i HTML</h3><p>Låt oss nu prata om sökvägar/webbadresser i HTML. Som tidigare nämnt så hanterar webbläsaren endast adresser i URL-format. Oavsett om det är en adress som pekar internt inom samma sida eller externt ut till en annan sida så behöver de vara i URL-format.</p><p>En webbläsare behöver alltså ha en absolut sökväg i URL-formatet. Men när vi specificerar hyperlänkar i vår HTML. T.ex. genom att använda <code>&lt;a&gt;</code>-taggen, så behöver vi faktiskt inte alltid ange kompletta URL:er enligt URL-formatet. De fall då vi inte behöver göra det är alltså när vi refererar till resurser inom vår egen sida (domän). Om vi däremot vill referera till en resurs utanför vår domän så behöver vi ange en komplett adress i URL-formatet.</p><blockquote>I HTML behöver vi inte ange protokoll när vi refererar till en URL inom samma domän.</blockquote><p>När vi refererar till en resurs inom vår egen domän så använder vi ett format som närmast liknar det *nix-system använder. Förnim dig det vi tidigare diskuterat! Alltså slash för att denotera nästa mapp, punkt-punkt för att vandra en mapp upp i hierarkin, och en initial slash för att denotera roten.</p><p>Detta blir antagligen enklare genom att diskutera ett par exempel. Anta att vi befinner oss på följande sida: <code>http://example.com/pages/links.html</code>. Nedan följer ett par exempel på hur webbläsaren kommer att översätta våra adresser, om vi specificerar de inom (t.ex.) en <code>&lt;a&gt;</code>-tagg.</p><table class="table table-condensed table-striped"><tr><th>Hyperlänk</th><th>Webbläsarens tolkning</th><th>Typ</th></tr><tr><td>images.html</td><td>http://example.com/pages/images.html</td><td>Relativ</td></tr><tr><td>../images.html</td><td>http://example.com/images.html</td><td>Relativ</td></tr><tr><td>/images.html</td><td>http://example.com/images.html</td><td>Absolut</td></tr><tr><td>/images/album.html</td><td>http://example.com/images/album.html</td><td>Absolut</td></tr></table><blockquote class="text-danger">Om vi inte anger ett protokoll kommer webbläsaren att tolka vår URL som intern! Även om vi börjar URL:en med www.</blockquote><p>Notera alltså att om vi inte anger ett protokoll så kommer webbläsaren att tolka våra URL:er som interna till vår domän. Ett vanligt misstag är således att glömma att ange protokollet när vi försöker ange en extern adress. Anta att vibefinner oss på <code>http://example.com</code> och skriver följande:</p><pre><code class="language-markup">&lt;a href="www.google.com"&gt;Klicka här&lt;/a&gt;</code></pre><p>Vi antar att länken ska ta användaren till google.com. Fallet är dock inte så. Eftersom vi inte angett protokoll tolkar webbläsaren adressen som intern. Webbläsaren översätter således adressen till följande:</p><pre>http://example.com/www.google.com</pre><p>Inte riktigt vad vi menade förstås. Det korrekta sättet att skapa ovan URL är alltså genom att även ange protokollet.</p><pre><code class="language-markup">&lt;a href="http://www.google.com"&gt;Klicka här&lt;/a&gt;</code></pre><h3>Ankare</h3><p>En typ av länkar vi ännu inte pratat om är ankare. Ankare är ett sätt att länka till en specifik del av en sida. Föreställ dig en lång sida. Alltså en sida med mycket content där du kan scrolla långt. Ankare hjälper dig då att skapa länkar <b>inom samma sida</b>.</p><blockquote>Ett ankare kan appliceras i slutet av vilken URL som helst.</blockquote><p>Ett ankare börjar med fyrkants-tecknet (hashtag) (<code>#</code>) och sedan vilken sträng som helst.</p><pre><code>#my_anchor</code></pre><p>Vi applicerar alltså ett ankare i slutet av en vanlig URL.</p><pre><code>http://example.com/index.html#my_anchor </code></pre><p>Vi kan alltså använda oss av ankare för att ge användaren en möjlighet att navigera inom samma sida. När vi klickar på en länk med ett ankare så kommer alltså webbläsaren inte bara att ladda den sida vi angett &mdash; utan även scrolla ned till ankarets målposition. Vi kan med andra ord se ankare som en form av "bokmärken" för långa sidor.</p><p>Ankaren har även fler, mer avancerade tillämpningsområdet men det kommer vi in på mycket senare. </p><p>Eftersom ankare är en del av URL:er så är det så att vi inte bara kan använda ankare när vi vill ge användaren en möjlighet att navigera inom samma sida. Vi kan även använda oss av dem när vi vill skicka användaren till ett visst ankare på en annan sida.</p><p>Låt oss exemplifiera för att göra det tydligare. Ponera att vi har en HTML-sida med följande länk i sig.</p><pre><code class="language-markup">&lt;a href="#images"&gt;Bildgalleriet&lt;/a&gt;</code></pre><p>Ovan länk kommer alltså inte att byta sida. Ovan länk är en relativ URL som i browsern kommer att översättas till samma URL som vi är vid, fast med ankaret "#images" pålagt i slutet.</p><p>Ponera om vi istället hade skapat en länk som pekade på en full URL med ett ankare i slutet, såsom nedan...</p><pre><code class="language-markup">&lt;a href="http://example.com/index.html#images"&gt;Bildgalleriet&lt;/a&gt;</code></pre><p>Om vi hade specificerat en URL såsom ovan, hade vi skickat användaren till index.html under domänen example.com. Oavsett vilken sida vi råkade vara på vid tillfället. Det viktiga att förstå är dock att ankaret kommer att fungera i vilket fall. När webbläsaren har nått den sida vi skickat användaren till så kommer den automatiskt att scrolla ned till den plats där ankaret är specificerat.</p><p>Det finns en sak vi ännu inte pratat om vad gäller ankare. Nu vet vi hur man skapar en länk <b>till</b> ett ankare. Men vi har inte pratat om hur man skapar ett ankare som man kan skickas till på en sida. Tidigare så använde vi exemplet <code>#my_anchor</code>, men vart hamnar användaren när den klickar på ankaret? Vart är "målet" för detta ankare specificerat?</p><p>Egentligen är det ganska enkelt. En länk till ett ankare specificeras där vi kan ange en URL, och ett mål för ett ankare specificeras i vilket element som helst, under attributet ID.</p><blockquote>Ankare pekar på egenskapen <code>id</code> i element.</blockquote><p>Låt oss se till ett exempel.</p><pre><code class="language-markup">&lt;!-- Om vi har någonting med ett ID --&gt;
&lt;h1 id="images"&gt;Bildgalleriet&lt;/h1&gt;
 
&lt;!-- Så kan vi sedan länka till det som ett ankare --&gt;
&lt;a href="#images"&gt;Gå till bildgalleriet&lt;/a&gt;</code></pre><p>Med andra ord så kan vi skapa "bokmärken" på våra sidor genom att ge olika element ID:n. När vi sedan vill att en användare snabbt ska kunna navigera till en viss del av sidan (ett "bokmärke") så skapar vi en länk som pekar på just det ID:t, som ett ankare.</p><p>Detta är bara en av många funktioner som ID:n fyller, men det återkommer vi till senare.</p><!-- TODO: This does not belong here--><!-- h4 Länkar och CSS--><!-- p Med hjälp av CSS så kan man skapa olika effekter på sina länkar beroende på vilket state som länken har. Exempelvis--><!--   | kan man få en länk att bli understruken när man "hovrar" över länken. följande CSS på till en länk gör detta. --><!-- pre--><!--   code.language-css--><!--     | a:link{ text-decoration:none; color:#CC3333; }--><!--     | a:visited{ text-decoration:none; color:#CC3333; }--><!--     | a:active{ text-decoration:none; color:#CC3333; }--><!--     | a:hover{ text-decoration:underline; }--><!-- p Det finns flera andra rollover-effekter och du ser några exempel nedan.--><!-- pre--><!--   code.language-css--><!--     | a:hover{ color:#CC6600; }--><!--     | a:hover{ background-color:#99CCFF; }--><!--     | a:hover{ text-decoration:underline overline; }--><!--     | a:hover{ font-style: italic; }--><!--     | a:hover{ background-image:url('egen_bild.gif'); }--><!--     | a:hover{ letter-spacing:5px}--><!--     | a:hover{ cursor:help; }--><!--     | a:hover{ cursor:e-resize}--><!--     | a:hover{ color:#FFFFFF; background-color:#006699; }--><div class="page-header"><h2 href="#02-09-html-formular" name="02-09-html-formular" id="02-09-html-formular"><a href="#formular" name="formular"><div class="icon-link"></div>Formulär</a></h2></div><p>För att användare av webbsidor ska kunna skicka data mellan olika sidor använder vi oss (bl.a.) av formulär.
För att vi som utvecklare ska kunna spara användardata i t.ex. en databas så behöver vi få in data ifrån "klient-sidan" (client-side) till "server-sidan" (server-side). Formulär ger oss ett mycket smidigt sätt att göra detta.</p><h3>Form-taggen </h3><p>Låt oss börja med att skapa ett skal till ett formulär. </p><div class="panel panel-default"><div class="panel-heading">Ett tomt formulär</div><div class="panel-body"><pre><code class="language-markup">&lt;form method="post" action="process-data.php"&gt;
   ...
&lt;/form&gt;</code></pre></div></div><p>Ovan kod resulterar rent visuellt inte i någonting. Under ytan så kommer ju ovan markup absolut att <em>finnas</em> i dokumentet, men rent visuellt ser användaren ingenting.</p><h3>Labels</h3><p>För att användaren ska veta vad hen ska fylla i vart, så använder vi oss av <code>&lt;label&gt;</code>'s.</p><p>Till synes så ser denna tagg inte mycket ut för världen eftersom den endast renderar ut som helt vanlig text. Men eftersom vi associerar labels med input-fält så gör (t.ex.) vissa browsers label-texten klickbar. För radiobuttons så innebär t.ex. ett klick på label:en då samma sak som ett klick på själva knappen.</p><p>Vi använder egenskapen <code>for</code> för att specificiera vilken formulärkontroll en viss label tillhör.</p><div class="panel panel-default"><div class="panel-heading">Exempel på label</div><div class="panel-body"><pre><code class="language-markup">&lt;label for="ett-input-id"&gt;Din e-post&lt;/label&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label>Din e-post</label></div></div><h3>Input, textarea &amp; select</h3><!-- p Så, låt oss lägga till någonting som faktiskt kan vara till användning. Frågan är alltså: hur kan vi ge användaren en möjlighet att skriva in data? Först och främst måste vi helt enkelt välja vad vi menar med data? Det är ju alltså formulär vi behandlar. Vill vi att användaren ska kunna skriva in "fri-text", eller välja mellan tre val, eller välja en/fler/ingen mellan tre val o.s.v. Det finns alltså ett antal olika input-metoder vi kan erbjuda en användare och några presenteras således nedan.--><p>För att skapa själva innehållet i formuläret använder vi oss i huvudsak av taggarna <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> och <code>&lt;select&gt;</code>.</p><p><code>&lt;input&gt;</code>-taggen kan vi använda till att skapa många olika typer av formulärsfält. Närmare bestämt: fritext, radioknappar, checkboxar och gömda fält. Vilken av dessa fält vi vill skapa bestämmer vi genom att sätta attributet <code>type</code>.</p><h4>Fritext (en rad)</h4><p>Följande är ett exempel på hur vi kan göra om vi vill ha ett en-rads-text-fält.</p><div class="row"><div class="col-md-6"><div class="panel panel-default"><div class="panel-heading">Input type text</div><div class="panel-body"><pre><code class="language-markup">&lt;input type="text" placeholder="Your email"&gt;</code></pre></div></div></div><div class="col-md-6"><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form><input type="text" placeholder="Your email" class="form-control"></form></div></div></div></div><h4>Radio buttons</h4><p>Radio-knappar ger användaren möjligheten att välja ett och endast ett av flera alternativ. Låt oss se till ett exempel, och notera även hur egenskapen <code>for</code> används till att peka <code>&lt;label&gt;</code>'s.</p><div class="panel panel-default"><div class="panel-heading">Radio buttons med labels</div><div class="panel-body"><pre><code class="language-markup">&lt;label for="alt-yes"&gt;Ja&lt;/label&gt;
&lt;input type="radio" id="alt-yes" name="yes-or-no" value="yes"&gt;
&lt;label for="alt-no"&gt;Nej&lt;/label&gt;
&lt;input type="radio" id="alt-no" name="yes-or-no" value="no"&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form><div class="radio"><label for="alt-yes">Ja</label><input type="radio" name="yes-or-no" id="alt-yes"></div><div class="radio"><label for="alt-no">Nej</label><input type="radio" name="yes-or-no" id="alt-no"></div></form></div></div><p>Det som vi har här är alltså en formtagg och i denna så ligger två inputfält varav typen är text och name är namnet som vi kommer
använda om vi skulle vilja hämta upp dessa värden med exempelvis PHP. Size anger vilken storlek denna skall ha och maxlength hur
många bokstäver vi kan skriva in i textboxen.</p><h4>Checkboxes</h4><p>Checkboxes använder vi till skillnad ifrån radio buttons när vi vill ge användaren möjligheten att välja ett, eller flera alternativ av många. Mycket användbart när det kommer till frukt!</p><div class="panel panel-default"><div class="panel-heading">Exempel på checkboxes med labels</div><div class="panel-body"><pre><code class="language-markup">&lt;input type="checkbox" name="fruit" value="apple" id="alt-apple"&gt;
&lt;label for="alt-apple"&gt;Apple&lt;/label&gt;
&lt;input type="checkbox" name="fruit" value="banana" id="alt-banana"&gt;
&lt;label for="alt-banana"&gt;Banan&lt;/label&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><div class="checkbox"><input id="alt-apple" type="checkbox" name="fruit" value="apple"><label for="alt-apple">Äpple</label></div><div class="checkbox"><input id="alt-banana" type="checkbox" name="fruit" value="banana"><label for="alt-banana">Banan</label></div></div></div><h5>Förklaring av attribut</h5><p>Nedan gäller både för <code>radio button</code>'s och <code>checkbox</code>:ar.</p><table class="table table-hover"><tr><td>name</td><td>Namnet på den grupp som valet tillhör. Detta kommer även att vara "nyckeln" vi använder för att hitta det/de värde/-n användaren valt när denne väl skickat formuläret.</td></tr><tr><td>value</td><td>Eftersom detta inte är ett fritextfält så kommer värdet som skickas vara förbestämt. Med andra ord, detta attribut specificerar det värde vi kommer att se när användaren valt detta alternativ.</td></tr><tr><td>id</td><td>Alla element kan ha unika id:n. I detta fall behöver vi id:n eftersom vi vill kunna referera till input-boxen via vår label.</td></tr></table><h4>Select list</h4><p>Om vi vill erbjuda en användare många alternativ, som t.ex länder, kan radiobuttons och checkboxes ofta ta alldeles för stor plats. Då kan vi använda oss av <code>&lt;select&gt;</code>-listor. </p><div class="panel panel-default"><div class="panel-heading">Exempel på select-lista</div><div class="panel-body"><pre><code class="language-markup">&lt;select name="fruit"&gt;
&lt;option value="banana"&gt;Banan&lt;/option&gt;
&lt;option value="apple"&gt;Äpple&lt;/option&gt;
&lt;option value="grapes"&gt;Vindruvor&lt;/option&gt;
&lt;/select&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label for="select-fruit">Vad vill du äta till frukost?</label><select id="select-fruit" name="frukter" class="form-control"><option value="banan">Banan </option><option value="&#xE4;pple">Äpple</option><option value="vindruvor">Vindruvor</option></select></div></div><h5>Multiple-choice select</h5><p>Om vi sätter egenskapen <code>multiple</code> så tillåter listan att användaren väljer flera alternativ genom att hålla in <code>ctrl</code> (Windows) eller <code>cmd</code> (Mac). Man kan även markera flera genom att trycka på en post, hålla ned <code>shift</code> och sen trycka på en till.</p><div class="panel panel-default"><div class="panel-heading">Exempel på select-lista</div><div class="panel-body"><pre><code class="language-markup">&lt;select name="fruit" multiple&gt;
...
&lt;/select&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label for="select-fruit">Vad vill du äta till frukost?</label><select id="select-fruit" name="frukter" multiple="multiple" class="form-control"><option value="banan">Banan </option><option value="&#xE4;pple">Äpple</option><option value="vindruvor">Vindruvor</option></select></div></div><h4>Submit</h4><p>För att skicka ett formulär måste vi in med en knapp, och använder oss då åter av taggen <code>&lt;input&gt;</code>, men denna gången med typ-attributet satt till <code>submit</code>.</p><p>Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på submit-knapp</div><div class="panel-body"><pre><code class="language-markup">&lt;input type="submit" value="Skicka!"&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><input type="submit" value="Skicka!" class="btn btn-default"></div></div><h3>Att skicka formuläret</h3><p class="N">är användaren klickar på en submit-knapp i ett formulär så skickas det ifyllda datat med i nästa request. Knappen leder oss till en ny sida som defineras genom attributet <code>action</code></p><p>Tyvärr är det så att HTML i sig är otillräckligt för att göra någonting signifikant vad gäller processning av formulär-data. För att faktiskt spara datat i en databas eller på något annat sätt hantera det så behöver vi ett script-språk (ex: JavaScript, PHP, Ruby, ASP o.s.v.)</p><div class="panel panel-default"><div class="panel-heading">Exempel på action</div><div class="panel-body"><pre><code class="language-markup">&lt;form action="process-form-data.php"&gt;</code></pre></div></div><h4>HTTP Method</h4><p>När vi konstruerar ett formulär som ska skicka data till en annan sida så gör vi det genom en <a href="http://www.w3schools.com/tags/ref_httpmethods.asp" target="_blank">HTTP-metod</a>. För nu kan vi ignorera detta eftersom vi endast pysslar med front-end-språk (html), men det kan ändå vara bra att känna till varför attributet finns där.</p><p>Attributet <code>method</code> kan alterneras mellan de två värdena <code>POST</code> och <code>GET</code>. Dessa är två olika typer av HTTP requests, och skillnaderna innefattar bl.a.a att förstnämnda "gömmer" datat som skickas i request:et, medan sistnämnda visar datat i URL:en. Läs mer i ovan nämnd länk!</p><p>Som tumregel brukar man säga att anrop med "sido-effekter" bör utföras över <code>POST</code> och övriga  över <code>GET</code>. Uttryckt i mer klarspråk: om postningen av formuläret kommer att <em>förändra</em> någonting på servern (ofta spara någonting i en databas) (t.ex. en kommentar), så bör vi arbeta över <code>POST</code>. Om postningen däremot endast syftar till att <em>hämta</em> någonting ifrån servern (t.ex. en sökning) så bör vi arbeta över <code>GET</code>.</p><h3>Komplett exempel</h3><p>Här har vi skapat ett formulär som har två textfält där vi kan skriva in vårt namn och även vad vi skulle vilja heta. Koden för denna 
är som nedanstående:</p><div class="panel panel-default"><div class="panel-heading">Komplett formulär-exempel</div><div class="panel-body"><pre><code class="language-markup">&lt;form action="#" method="GET"&gt;
&lt;div class="form-group"&gt;
  &lt;label for="field-current-name"&gt;Nuvarande namn&lt;/label&gt;
  &lt;input type="text" id="field-current-name" name="current-name" placeholder="Ditt nuvarande namn" required&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
  &lt;label for="field-new-name"&gt;Önskat namn&lt;/label&gt;
  &lt;input type="text" id="field-new-name" name="new-name" placeholder="Ditt önskade namn" required&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
  &lt;div class="radio"&gt;
    &lt;label for="field-gender-man"&gt;Man&lt;/label&gt;
    &lt;input type="radio" id="field-gender-man" name="gender" value="man"&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
  &lt;div class="radio"&gt;
    &lt;label for="field-gender-woman"&gt;Kvinna&lt;/label&gt;
    &lt;input type="radio" id="field-gender-woman" name="gender" value="kvinna"&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;input type="submit" value="Skicka!"&gt;
&lt;/form&gt;</code></pre></div></div><blockquote class="text-danger">Notera att alla <code>div</code>-taggar i ovanstående exempel egentligen är överflödiga. De är endast där för att orsaka radbrytningar mellan varje formulärgrupp och ge oss möjligheten att applicera css-stilar.</blockquote><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form action="#" method="GET"><div class="form-group"><label for="field-current-name">Nuvarande namn</label><input type="text" id="field-current-name" name="current-name" placeholder="Ditt nuvarande namn" required="required" class="form-control"></div><div class="form-group"><label for="field-new-name">Önskat namn</label><input type="text" id="field-new-name" name="new-name" placeholder="Ditt &#xF6;nskade namn" required="required" class="form-control"></div><p>Vänligen uppge ditt kön</p><div class="form-group"><div class="radio"><input id="field-gender-man" type="radio" name="gender" value="man" required="required"><label for="field-gender-man">Man</label></div><div class="radio"><input id="field-gender-woman" type="radio" name="gender" value="woman" required="required"><label for="field-gender-woman">Kvinna</label></div><div class="radio"><input id="field-gender-other" type="radio" name="gender" value="other" required="required"><label for="field-gender-other">Övrigt</label></div></div><input type="submit" value="Skicka!" class="btn btn-default"></form></div></div><blockquote class="text-info">Prova gärna att skicka formuläret och notera dels vad attributet <code>required</code> orsakar, samt vad som händer i webbläsarens adressfält.</blockquote><div class="page-header"><h2 href="#02-10-html-doctypes" name="02-10-html-doctypes" id="02-10-html-doctypes">Doctypes</h2></div><p>HTML har funnits i fler än ett par år, och det har länge funnits mer än en enda browser. Faktumet att de flesta browsers (självklarligen) vill äga majoriteten av marknaden har gett upphov till uttrycket <a href="http://en.wikipedia.org/wiki/Browser_wars" target="_blank">The Browser Wars</a>.</p><p>Detta (bland annat) har gett upphov till att webbläsare i olika skeden implementerat olika delar av HTML-, CSS- och JavaScript-specifikationerna. Med andra ord, att olika "dialekter" av samma språk varit tillåtet i olika webbläsare. Med andra ord att vi kan skriva vissa saker i vissa webbläsare och andra i andra, vilket gör att webbläsare A kanske inte förstår uttryck B, som webbläsare C förstår.</p><p>Detta (bland annat) har gjort att det är viktigt att deklarera vilken standard av HTML, ett visst dokument följer. Så att webbläsaren, "intelligent" (utan att gissa) kan "parse":a (läsa) vår fil enligt rätt specifikation.</p><p>Om du har svårt att förstå varför vi behöver dessa standarder, stanna upp och fundera över faktumet att html-dokument egentligen bara är text. Ingenting annat. Precis som med naturligt språk, så måste mottagaren av meddelandet förstå hur den ska avkoda informationen. Vi kan alltså se doctype-deklarationen lite som att vi berättar för webbläsaren som ska läsa filen vilket dialekt av HTML vi pratar. Löst uttryckt.</p><p>Vi definerar doctypes genom att använda syntaxen <code>&lt;!DOCTYPE x&gt;</code>, allra först i dokumentet. Där <code>x</code> ersätts med den faktiska doctype:en. Nedan följer ett par exempel för hur man deklarerar doctypes.</p><div class="panel panel-default"><div class="panel-heading">Detta dokument deklarerar standarden HTML5</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;Min sida&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h5>HTML 4.01 Strict</h5><p><code>HTML 4.01 Strict</code> tillåter alla HTML 4.01-element och -attribut, men tillåter inte de som exkluderats ("deprecated") ur HTML 4.01-standarden. Närmare bestämt, element och attribut som rör visuell presentation snarare än struktur och content, såsom elementet <code>&lt;font&gt;</code> eller attributet <code>bgcolor="#000000"</code>.</p><div class="panel panel-default"><div class="panel-heading">Doctype för HTML 4.01 Strict</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</code></pre></div></div><h5>HTML 4.01 Transitional</h5><p>Även <code>HTML 4.01 Transitional</code> tillåter alla element och attribut som är tillåtna i HTML 4.01, <em>inklusive</em> de som rör presentation (se förklaring i ovan paragraf).</p><div class="panel panel-default"><div class="panel-heading">Doctype för HTML 4.01 Transitional</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</code></pre></div></div><h5>Och så vidare...</h5><p>Det finns som sagt markant fler doctypes än dessa. Enklast numera är att helt enkelt hålla sig till <code>HTML5</code> och således deklarera <code>&lt;!DOCTYPE html&gt;</code>. Vill du läsa mer om doctypes kan du t.ex. göra det hos <a href="http://www.w3schools.com/tags/tag_doctype.asp" target="_blank">W3 Schools </a>eller på <a href="http://en.wikipedia.org/wiki/Document_type_declaration" target="_blank">Wikipedia</a>.</p><div class="page-header"><h2 href="#02-11-html-encodings" name="02-11-html-encodings" id="02-11-html-encodings">Character encoding</h2></div><p>Kanske har du redan märkt att när man skapar html-dokument som innehåller tecken såsom <code>å</code>, <code>ä</code>, <code>ö</code> kan det hända att de ersätts med en uppsjö a mystiska tecken. Lösningen på detta är <code>character sets</code>.</p><p>För att göra en lång historia kort så var det alltså så att man i datorernas tidiga dagar representerade tecken som <a href="http://sv.wikipedia.org/wiki/ASCII" target="_blank">ASCII</a>-koder. T.ex. så representerades <code>A</code> genom <code>65</code> och <code>a</code> genom <code>97</code>.</p><p>ASCII-tabellen använde sig av 7 bitar, vilket resulterade i 128 olika tecken (eftersom <code>2^7=128</code>), varvid vissa var "unprintable" kontroll-tecken. Som du säkert kan tänka dig upptäckte man snabbt att detta var fullt otillräckligt för att lagra all världens olika tecken. Vi har ju förstås inte bara åäö att arbeta med, utan även kinesiska, grekiska, arabiska o.s.v.</p><blockquote>There is no such thing as plain text<footer>&mdash; <a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></footer></blockquote><p>Ovan citat understryker faktumet att datorer egentligen är väldigt korkade och bara gör det vi säger åt dem. Utan att berätta för en dokumentläsare på vilket sätt vi sparat ett visst tecken så har den ingen chans att veta vad det är för tecken, hur det ska visas, eller ens vart tecknet slutar.</p><p>In kommer <a href="http://sv.wikipedia.org/wiki/UTF-8" target="_blank">utf-8</a> och räddar dagen! Detta är kort sagt är ett sätt att representera <a href="http://sv.wikipedia.org/wiki/Unicode_transformationsformat" target="_blank">Unicode</a>-tecken. Och kort sagt möjliggör användning av världens alla tecken. Och som kort sagt blivit den vanligaste teckenkodningen för webbsidor.</p><p>Ett dokuments teckenkodning sätter vi genom att skapa en <code>&lt;meta&gt;</code>-tag med attributet <code>charset</code> satt till valfritt charset (såsom just utf-8). Eftersom detta tillhör meta-information om dokumentet skall vi placera taggen under <code>&lt;head&gt;</code>. Vidare bör vi även specificera vårt <code>charset</code> så <a href="http://stackoverflow.com/questions/5572471/in-head-which-comes-first-meta-or-title" target="_blank">tidigt som möjligt</a> i <code>&lt;head&gt;</code> eftersom webbläsaren behöver veta vilken teckenkodning vi använt för att ordentligt kunna läsa det dokument den redan läser.</p><div class="panel panel-default"><div class="panel-heading">Ett dokument som definierar character set:et utf-8</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;The utf-8, I speak!&lt;/title&gt;
  &lt;/head&gt;
&lt;/html&gt;</code></pre></div></div><h1 href="#03-00-css-intro" name="03-00-css-intro" id="03-00-css-intro">CSS</h1><p class="lead">Om HTML beskriver en webbsidas innehåll så beskriver CSS hur detta innehåll ser ut. Om webben var en teaterpjäs skulle HTML vara manuset och CSS regissören. "Du ska stå där, du där och du där! Vänta nu, du behöver ha en grön hatt, och du behöver ha en mask och en cape!"</p><div class="page-header"></div><h2 href="#03-01-css-intro" name="03-01-css-intro" id="03-01-css-intro">Introduktion till CSS</h2><p>CSS &mdash; (Cascading StyleSheets) är stilmallar i praktiken används till att formge dokument. Formge färg, teckensnitt, positionering, justering, backgrunder, scroll, o.s.v. En enda CSS-mall kan styra tusentals dokument och det är då enkelt att ändra formateringen genom att det bara i CSS-mallen.</p><p>CSS har tagit HTML ett steg längre och möjliggjort formateringar och effekter som inte fanns i HTML standarden. En av fördelarna med CSS är att flera mallar kan användas  och de har då företräde inbördes så att en "huvudmall" med de övergripande formateringarna kan ersättas på en lägre nivå av en "lokal mall" som då gäller före huvudmallen. Det är detta som åsyftas när man säger att css är <code>cascading</code>.</p><blockquote>Med css kan vi separera innehåll och presentation.</blockquote><p>CSS är ett initiativ till att separera <b>innehåll</b> och <b>presentation</b>. Att definiera allt relaterat till presentation i en extern mall har många fördelar. Bland annat att:</p><ul><li>Vi kan återanvända presentationsreglerna över många sidor.</li><li>Sidorna laddas snabbare eftersom CSS-filen kan cachas av webbläsaren.</li><li>HTML-sidan lever rimligen längre eftersom vi kan förändra presentationen utan att behöva ändra avsevärt i innehållets struktur.</li></ul><h3>Tillgänglighet &amp; responsivitet</h3><p>En målsättning och effekt av att presentation separeras ifrån innehåll -- är adaptivitet. Om innehållet är helt "befriat ifrån" presentation så skulle man i teorin kunna visa innehållet med vilken typ av presentation som som helst.</p><p>För att göra det mer uppenbart, låt oss fundera över hur situationen såg ut tidigare. Om vi beblandar presentation (css) med vårt innehåll (html) så kommer det vara svårt för en maskin att avgöra vad som hör till presentationen och vad som hör till innehållet. Tänk t.ex. på radbrytningar. Används en radbrytning för att understryka att två paragrafer är skilda ifrån varandra, eller används den för att skapa ett bekvämt visuellt avstånd? Både fallen kan vara sanna. Detta är svårt för en maskin att avgöra.</p><p>I praktiken har detta t.ex. varit ett problem för syn- och hörselskadade. Tänk på <a href="http://en.wikipedia.org/wiki/Screen_reader">screen readers</a> t.ex. som genom text-to-speech försöker läsa upp en sidas innehåll för en användare. Hur skulle det vara om den började läsa saker som "blå bakgrund". </p><p>Ett av målen för W3C (standardsorganisationen för bl.a. css) är att underlätta för konumptionen av webbaserat innehåll på plattformar än just en dator. Det kan handla om allt ifrån Smartphones till enheter för talsyntes och punktskrift (Braille). Genom att separera innehåll ifrån presentation är det alltså markant lättare, eftersom maskinen inte behöver bry sig om att filtrera ut presentationen ifrån innehållet.</p><p>Detta betyder förstås att vi sedan lång tid tillbaka behövt lägga gamla troll som Frames, Iframes, Imagemaps, java applets, javascript, bilder utan ALT-text, GIF-animationer, Flash, Shockwave, PDF-dokument osv. Många funktioner som används idag går då alltså bort helt.</p><div class="page-header"><h2 href="#03-02-css-syntax-och-struktur" name="03-02-css-syntax-och-struktur" id="03-02-css-syntax-och-struktur">CSS syntax och struktur</h2></div><p>För att enklare förstå hur CSS hanteras, föreställ dig att webbläsaren består av två ninjateams. Det första ninjateamet läser HTML-filen och skriver ut en massa text, bilder, listor, tabeller och länkar på skärmen. När första teamet hittar en referens till en CSS-fil, skickar de det till det andra ninjateamet. Det andra ninjateamet går då lös med färgkritor och klipper och klistrar tills allt ser snyggt ut.</p><p>Även om ovanstående exempel är orimligt oseriöst är poängen att rendering av en webbsida (metaforiskt) sker i olika "pass". Där det första är att få ut resultatet av HTML:en på skärmen, och det andra att visuellt ändra på resultatet av HTML:en enligt det som definierats i CSS-filen. Du kommer upptäcka att det finns fler "pass" (och att ordningen kan variera) när vi kommer till JavaScript, men det lämnar vi för nu.</p><p>Varför är det då viktigt att förstå att CSS kommer i det "andra passet"? Jo, eftersom det är viktigt att förstå att CSS <em>appliceras</em> på ett befintligt dokument. Med andra ord, ett CSS-dokument är i sig helt meningslöst. Eftersom ett CSS-dokument då appliceras på ett HTML-dokument så måste varje CSS-regel veta <em>vad</em> den ska appliceras på. Och det är här <code>selectors</code> kommer in i bilden. Låt oss se till ett exempel.</p><blockquote>En css-<code>selector</code> definierar vilka html-<code>element</code> som ska påverkas av en viss effekt.</blockquote><div class="panel panel-default"><div class="panel-heading">CSS-selector för HTML-element</div><div class="panel-body"><p>index.html</p><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;The morning&lt;/title&gt;
    &lt;link rel="stylesheet" href="main.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;As Gregor Samsa awoke one morning from uneasy dreams [..]&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>main.css</p><pre class="line-numbers"><code class="language-css">body{
  background-color: lightblue;
}
p{
  color: #ffffff;
}</code></pre><p>Resultat</p><div class="panel panel-default"><div style="background-color:lightblue; color:#ffffff;padding-top:23px;" class="panel-body"><p>As Gregor Samsa awoke one morning from uneasy dreams [..]</p></div></div></div></div><p>Hur ska vi nu tänka kring det här? De viktigaste sakerna att poängtera är:</p><ul><li><em>Rad 5</em> i html-dokumentet är det som gör att det som säger åt HTML-ninjorna att de behöver hämta CSS-ninjorna och att de ska läsa filen <code>main.css</code>.</li><li><em>Rad 1</em> i css-dokumentet är en <code>selector</code> vars <code>target</code> är <code>&lt;body&gt;</code>-elementet. Det betyder att allt mellan följande <a href="http://en.wikipedia.org/wiki/Bracket#Curly_brackets_or_braces_.7B_.7D" target="_blank">måsvingar</a> (<code>{...}</code>) kommer att appliceras på <em>alla</em> <code>&lt;body&gt;</code>-element i html-dokumentet. Nu bör det ju förstås bara finnas ett body-element men förhoppningsvis har du redan förstått att vi hade kunnat välja vilket annat html-element som helst.</li><li><em>Rad 2 och 5</em> i css-dokumentet är faktiskt css-<code>deklarationer</code>. Det är de som således bestämmer vilken visuell effekt som ska appliceras på just den selector vi definierat.</li></ul><blockquote>En css-<code>selector</code> kan vara vilket html-<code>element</code> som helst.</blockquote><p>Låt oss se det rent generellt. Syntaxen är alltså som följande.</p><div class="panel panel-default"><div class="panel-heading">CSS-syntax uttryckt generellt</div><div class="panel-body"><pre class="line-numbers"><code class="language-css">css-selector{
  declaration-property: declaration-value;
}</code></pre></div></div><p>Så, låt oss uttrycka syntaxen för <code>deklarationer</code> i ord: En css-<code>deklaration</code> består av en <code>egenskap</code> (även kallat: property, nyckel, key), följt av ett kolon (<code>&#58;</code>) som fungerar som en avgränsare mellan nyckeln och värdet. Vidare följt av det faktiska <code>värdet</code> (som kan ges i en mängd olika format, såsom exempelvis <code>left</code>, <code>-32px</code>, <code>233%</code> eller <code>light</code>, beroende på vilken egenskap vi sätter värdet för). Slutligen anger vi ett semikolon (<code>&#59;</code>) för att terminera raden. Det sistnämnda gör det möjligt att skriva flera deklarationer på samma rad (vilket dock oftast gör filen väldigt svårläslig).</p><blockquote>En css-<code>deklaration</code> består av en <code>property</code> (även kallat: nyckel, key, egenskap), ett kolon (<code>&#58;</code>), ett <code>värde</code> och slutligen ett semikolon (<code>&#59;</code>).</blockquote><h3>Exempel på selectors genom klass och ID</h3><p>Utöver att skriva css-selectors som träffar html-element så kan vi även skriva selectors för <code>ID</code>:n och <code>klasser</code>.</p><p>Vi använder ID:n för att defineira "unika" element. Vad menar vi med unika? Jo att om någonting har id:et <code>container</code> så får det endast finnas ett enda element på sidan som har just det ID:et. Vi kan självklart skriva flera css-regler som använder just den selectorn. Men i html-dokumentet får ID:t alltså endast förekomma en enda gång.</p><p>Behöver vi kunna referera till flera element så använder vi oss av klasser. Klasser fungerar på exakt samma sätt som ID:n förutom just det att det är tillåtet att flera element använder samma klass.</p><p>Enklast är nog att som vanligt se till ett exempel över hur detta fungerar.</p><div class="panel panel-default"><div class="panel-heading">Klasser och ID:n</div><div class="panel-body"><p>index.html</p><pre class="line-numbers"><code class="language-markup">...
&lt;p class="redish"&gt;As Gregor Samsa awoke one morning&lt;/p&gt;
&lt;p id="blueish"&gt;from uneasy dreams&lt;/p&gt;
&lt;p&gt;he found himself transformed in his bed&lt;/p&gt;
&lt;p class="redish"&gt;into a monstrous vermin.&lt;/p&gt;
...</code></pre><p>main.css</p><pre class="line-numbers"><code class="language-css">p{
  color: orange;
}
.redish{
  color: red;
}
#blueish{
  color: blue;
}</code></pre><p>Resultat</p><div class="panel panel-default"><div class="panel-body"><p style="color:red;">As Gregor Samsa awoke one morning</p><p style="color:blue;">from uneasy dreams</p><p style="color:orange;">he found himself transformed in his bed</p><p style="color:red;">into a monstrous vermin.</p></div></div></div></div><!-- TODO: This really needs more flesh when it comes to selectors--><!-- There is yet nothing about pseudo elements, nesting nor siblings or--><div class="page-header"><h2 href="#03-03-css-selectorer" name="03-03-css-selectorer" id="03-03-css-selectorer">CSS-selectorer</h2></div><h3>Vanliga selektorer och atttribut</h3><p>Man kan ju tycka att det borde räcka med att kunna hänvisa till element bara via deras typ, klass eller typer. Detta är dock inte sant, suck! Det går att använda att komma åt element på andra sätt och detta gör det lättare man slipper sätta klass eller id på allt. Nedanför finner ni olika selektorer och exempel. Observera att det finns flera....Never ending story! </p><h4>Selektor: *</h4><div class="panel panel-default"><div class="panel-heading">Exempel på HTML och CSS med * </div><div class="panel-body"><pre><code class="language-markup">&lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
&lt;p&gt;En paragraf, yay!&lt;/p&gt;</code></pre><pre><code class="language-css">*{
  font-size: 24px; 
  background:#ff6600;
 }</code></pre></div></div><h4>Selektor: E</h4><div class="panel panel-default"><div class="panel-heading">Exempel på HTML och CSS med E </div><div class="panel-body"><p>E står i detta fall att man använder elementets typ som selektor. </p><pre><code class="language-markup">&lt;p&gt;En paragraf, yay!&lt;/p&gt;</code></pre><pre><code class="language-css">p{
  font-size: 24px; 
  background:#ff6600;
}</code></pre></div></div><h3>PseudoKlasser</h3><h4>E:link</h4><div class="panel panel-default"><div class="panel-heading">Exempel på ett element som är en länk som inte besökts än.</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;</code></pre><pre><code class="language-css">a:link{
  color:pink;
}</code></pre></div></div><h4>E:visited</h4><div class="panel panel-default"><div class="panel-heading">Exempel på ett element som har blivit besökt.</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;</code></pre><pre><code class="language-css">a:visited{
  color:blue;
}</code></pre></div></div><h4>E:hover</h4><div class="panel panel-default"><div class="panel-heading">Exempel på element som har muspekaren över sig.</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;</code></pre><pre><code class="language-css">a:hover{
  color:green;
}</code></pre></div></div><h4>E:active</h4><div class="panel panel-default"><div class="panel-heading">Exempel på länk som är aktivt (exempelvis när användaren trycker ner knappen)</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;</code></pre><pre><code class="language-css">a:active{
  color:purple;
}</code></pre></div></div><h3>Kombinationer</h3><h4>E F</h4><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><p>Alla element F som kommer efter E. Alltså i detta fall alla fyra första paragrafer. </p><pre><code class="language-markup">&lt;div class="yttre"&gt;
  &lt;p&gt;En första paragraf&lt;/p&gt;
  &lt;p&gt;En andra paragraf&lt;/p&gt;
  &lt;p&gt;En tredje paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En fjärde paragraf&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre><pre><code class="language-css">.yttre p{
  color:pink;
}</code></pre></div></div><h4>E+F</h4><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><p>alla element som direkt föregås av E. Alltså i detta fall kommer andra och tredje paragrafen att påverkas. </p><pre><code class="language-markup">&lt;div class="yttre"&gt;
  &lt;p&gt;En första paragraf&lt;/p&gt;
  &lt;p&gt;En andra paragraf&lt;/p&gt;
  &lt;p&gt;En tredje paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En rubrik, yay!&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre><pre><code class="language-css">p + p{
  color:pink;
}</code></pre></div></div><h4>E > F </h4><div class="panel panel-default"><div class="panel-heading">Exempel på element som är direkt barn av ett annat element. </div><div class="panel-body"><p>Anta att vi har följande html...</p><pre><code class="language-markup">&lt;div class="yttre"&gt;
  &lt;p&gt;En första paragraf&lt;/p&gt;
  &lt;p&gt;En andra paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En inre paragraf!&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre><p>Och sedan skriver denna regel..</p><pre><code class="language-css">.yttre > p{
  color:pink;
}</code></pre><p>Så kommer vi således alltså endast "träffa" de två första <code>&lt;p&gt;</code>-elementen eftersom endast de är <b>direkta</b> barn till elementet med klassen <code>.yttre</code>.</p><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><div><p style="color:pink;">En första paragraf</p><p style="color:pink;">En andra paragraf</p></div><div><p>En inre paragraf</p></div></div></div></div></div><!-- TODO: This really needs more flesh when it comes to selectors--><!-- There is yet nothing about pseudo elements, nesting nor siblings or--><div class="page-header"><h2 href="#03-04-css-placering" name="03-04-css-placering" id="03-04-css-placering">Vart skall jag lägga CSS:en?</h2></div><p>När du använder CSS för att formatera en sida kan du infoga CSS-formateringen på tre sätt:</p><ol><li>Extern CSS-mall<br>en extern CSS-mall som kopplas till dokumentet</li><li>I dokumentet<br>i dokumentets huvud head-taggen</li><li>Direkt i element)<br>i elementet där CSS-formateringen ska utföras </li></ol><h3>Extern CSS-mall</h3><p>Det här är den vanligaste användningen av CSS där ett externt dokument som innehåller formateringen kopplas till alla de 
sidor som ska tillämpa formatet. Namnet på CSS-mallen måste ha filtilläget .css och namnet på mallen i exemplet nedan är 
"mall.css". 
Den här metoden är mest effektiv, om formateringen ska ändras behöver du bara göra det i ett enda mall-dokument. 
Här uppfylls målet med att separera innehåll och struktur i dokumenten.
Så här kan koden för sidorna som kopplas till mallen se ut:</p><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;link href="mall.css" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Du kan koppla flera externa CSS-mallar till samma dokument. Om samma selektorer förekommer i båda
mallarna men med olika formatering gäller den mall som angivits senast i radvis ordning. I exemplet nedan 
gäller alltså "mall2.css" före "mall.css": </p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med referenser till flera stilmallar</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;link href="mall.css" rel="stylesheet"&gt;
    &lt;link href="en_till_mall.css" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h3>I dokumentet</h3><p>CSS-formatering angiven direkt i dokumentet kan användas när vissa sidor ska avvika från 
huvudmallens formatering. Den här metoden är inte lika effektiv som att använda en extern CSS-mall.
Om formateringen ska ändras måste det utföras i varje dokument som använder formateringen.
Här formateras rubriken direkt i dokumentet:</p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med css definierad direkt i HEAD</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;style type="text/css"&gt;
      h2 { font-size: 24px; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h3>Direkt i elementet som ska formateras </h3><p>Den här metoden är minst effektiv och här uppfylls inte målet med att separera innehåll och
struktur i dokumenten. CSS-formateringen anges i anslutning till de elementsom ska formateras. 
När formatet ska användas i ett nytt elememnt måste CSS-koden anges på nytt och det innebär att sidorna 
innehåller mycket kod och tar längre tid att laddas i webbläsaren.
Så här kan koden se ut när rubriken formateras direkt i elementet:</p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med css definierad i ett element (även kallat: inline)</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2 style="font-size:24px;"&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Prioriteringsordningen av formateringen är följande:</p><ol><li> HTML-formatering</li><li>CSS-kod i element eller avsnitt där formateringen ska tillämpas</li><li>CSS-kod i dokumentet</li><li>CSS i extern mall</li></ol><p>Detta innebär att du kan börja formateringen i en extern CSS-mall som du kopplar till dina dokument.
Vill du sedan ange avvikande format lokalt i ett dokument formaterar du CSS direkt i dokumentet 
(gäller då före den externa CSS-mallen). Om någon del av dokumentet ska avvika från övrig CSS-formatering 
anger du detta direkt i avsnittet/objektet (gäller då före både CSS i dokumentets HEAD och CSS i en extern
CSS-mall)</p><div class="page-header"><h2 href="#03-05-css-cascade" name="03-05-css-cascade" id="03-05-css-cascade">Cascading</h2></div><p>Tänk på namnet &mdash; <em>Cascading Stylesheets</em> &mdash; stilmallar som "kaskadar". Vad menas egentligen med att de "kaskadar" och hur kan vi använda det till vår fördel?</p><p>Just ordet "<a href="http://sv.wikipedia.org/wiki/Kaskad" target="_blank">kaskad</a>" åsyftar idén om att någonting "faller" ned ifrån en nivå till en annan och så vidare i etapper. I relation till just CSS så handlar detta om att (de flesta) CSS-regler som appliceras på en förälder även gäller för alla förälderns barn.</p><p>Låt oss se till exempel för att bättre förstå vad vi pratar om.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en regel kaskadar igenom ifrån föräldern till barnen</div><div class="panel-body"><pre><code class="language-markup">&lt;body&gt;
  &lt;p&gt;First paragraph&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;Second paragraph&lt;/p&gt;
  &lt;div&gt;
&lt;/body&gt;</code></pre><pre><code class="language-css">body {
  color: green;
}</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="color: green;" class="panel-body"><p>First paragraph</p><div><p>Second paragraph</p></div></div></div></div></div><blockquote>Mer specifika regler skriver över mindre specifika regler oavsett i vilken ordning de dyker upp i css-filerna.</blockquote><p>Att mer specifika regler skriver över mindre specifika regler innebär att vi kan utnyttja kaskadet till vår fördel. Genom att således definiera generella regler på en "hög" nivå och sedan skriva över med de specika ändringar som vi vill göra.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en mer specifik regel <em>skriver över</em> en mindre specifik (kaskadad) regel</div><div class="panel-body"><pre><code class="language-markup">&lt;body&gt;
  &lt;p&gt;First paragraph&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;Second paragraph&lt;/p&gt;
  &lt;div&gt;
&lt;/body&gt;</code></pre><pre><code class="language-css">body { color: green; }
div p { color: blue; }</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="color: green;" class="panel-body"><p>First paragraph</p><div><p style="color: blue;">Second paragraph</p></div></div></div></div></div><p>Låt oss se till ett till exempel där vi använder ett elements ID för att kunna skriva över stilarna specifikt. Notera hur den andra paragrafen fortsätter att vara <b>fetstilad</b> eftersom den "ärver" den regeln av sin förälder. Alltså, egenskapen kaskadar ned ifrån föräldern till barnet.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en mer specifik regel <em>skriver över</em> en mindre specifik (kaskadad) regel</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;First paragraph&lt;/p&gt;
&lt;p id="selected"&gt;Second paragraph&lt;/p&gt;
&lt;p&gt;Third paragraph&lt;/p&gt;</code></pre><pre><code class="language-css">p {
  color: red;
  font-weight: bold;
}
#selected {
  color: orange;
}</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="font-weight:bold; color:red;" class="panel-body"><p>First paragraph</p><p style="color: orange">Second paragraph</p><p>Third paragraph</p></div></div></div></div><div class="page-header"><h2 href="#03-06-css-boxmodell" name="03-06-css-boxmodell" id="03-06-css-boxmodell">Boxmodellen</h2></div><p>Varje element som finns på en sida är egentligen en box. Därav så brukar man ofta prata om Boxmodellen för att se vad som </p>händer runt varje element<pre><code class="language-markup"> -------------------------------------------------------------------------
|                            Margin                                       |
|  ---------------------------------------------------------------------  |
| |                          Border                                     | |
| |  -----------------------------------------------------------------  | |
| | |                        Padding                                  | | | 
| | |  -------------------------------------------------------------  | | |
| | | |                      Content                                | | | |
| | | |                                                             | | | |
| | |  -------------------------------------------------------------  | | |
| | |                                                                 | | |
| |  -----------------------------------------------------------------  | |
| |                                                                     | |
|  ---------------------------------------------------------------------  |
|                                                                         |
--------------------------------------------------------------------------|</code></pre><p>Förklaring av de olika delarna:</p><ul><li>Margin är en transparant area runt ramen. </li><li>Border är en area runt som man kan sätta att ha en viss färg eller typ av border. </li><li>Padding är en area runt ett innehåll och den kommer att ha färgen som själva boxen är färgad i.</li><li>Content är helt enkelt innehållet av boxen som exempelvis kan vara text. </li></ul><div class="page-header"><h2 href="#03-07-css-positionering" name="03-07-css-positionering" id="03-07-css-positionering">CSS Positionering</h2></div><p>Om man tar en sväng på internet och funderar lite på det vi hittills lärt oss om HTML och CSS så inser man snabbt att saker inte alls bara ligger rakt upp och ned i dokumentet. Texter ligger i mitten, vi har kolumner och rader, marginaler och boxar som verkar vara "sticky".</p><p>I det här kapitlet går vi igenom de olika värden vi kan ge css-attributet <code>position</code>, närmare bestämt <code>absolute</code>, <code>relative</code> och <code>static</code>.</p><p>Om vi inte anger någonting annat så är alla element statiskt placerade. Det är värt att notera att även om namnet på attributet <code>position</code> verkar antyda det så är det verkligen inte det enda sättet webbutvecklare positionerar saker genom. Men med rätt förståelse för attributet finns det knappt någon positionering vi inte kommer kunna åstadkomma.</p><h3>Static</h3><p>Om du inte anger någonting annat, kommer element att positioneras statiskt. Alltså följa sin naturliga plats i dokumentet.</p><p>Det är viktigt att uppmärksamma att ett statiskt element på de (tänk dig en sida som ett koordinatsystem) koordinaterna <code>{0,0}</code>, omöjliggör att ett statiskt placerat syskon också placeras på <code>{0,0}</code>. Med andra ord tar statiskt placerade element upp plats och således kan syskon inte ligga på varandra utan placeras istället under (om de är <a href="http://en.wikipedia.org/wiki/HTML_element#Block_elements" target="_blank">block-level element</a>) eller bredvid (om de är <a href="http://en.wikipedia.org/wiki/HTML_element#Inline_elements" target="_blank">inline-level element</a>) varandra.</p><blockquote>Statiska element tar upp plats</blockquote><p>Att ett statiskt element inte kan placeras på ett annat element gäller förstås bara element som är syskon. Ett elements barn placeras förstås naturligt "innuti" förälderelementet.</p><p>Med andra ord. Om ett förälderelement har de (hypotetiska) koordinaterna <code>{0,0}</code> så kommer även första barnet till det elementet ha koordinaterna <code>{0,0}</code>.</p><p>Låt oss se till några exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på statisk positionering för två <code>&lt;div&gt;</code>:ar efter varandra.</div><div class="panel-body"><div style="width:100px;height:100px;background:red; margin-bottom:12px;"></div><div style="width:100px;height:100px;background:blue;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på statisk positionering för en <code>&lt;div&gt;</code> i en <code>&lt;div&gt;</code></div><div class="panel-body"><div style="width:100px;height:100px;background:red;"><div style="width:70px;height:70px;background:blue;"></div></div></div></div><h3>Fixed</h3><blockquote>Fixerade element tar inte upp plats</blockquote><p>Med fixerad positionering säger vi åt ett element att ignorera sin "normala" plats i dokumentflödet och istället placera sig på en position i relation till webbläsarfönstret.</p><p>Med andra ord så är alltså (den tänkta koordinaten) <code>{0,0}</code> högst upp till vänster i webbläsaren. Detta förutsatt att vi sätter föregående värden för egenskaperna <code>left</code> och <code>top</code> vilket då i ett kordinatsystem skulle motsvaras av <code>x</code> och <code>y</code>. Således kan vi sluta oss till att origo är högst upp till vänster i webbläsaren.</p><p>Vad som gör positionering i css intressant är att vi även kan vända steken och istället sätta värden för egenskaperna <code>right</code> och <code>bottom</code>. Vi hanterar då fortfarande <code>x</code> och <code>y</code> i bemärkelsen horisontellt och vertikalt men vi har nu flyttat origo ner till högra hörnet. Plus att vårt koordinatsystem nu fungerar "baklänges". Ett högre värde för right innebär att vi flyttar vårt element längre åt vänster. Sätt detta i relation till att ett högre värde för left flyttar vårt element längre åt höger.</p><blockquote>Tänk på positioneringsteknikerna <code>fixed</code>, <code>absolute</code> och <code>relative</code> som positionering genom i ett  koordinatsystem.</blockquote><p>Medan ovan kommentarer gäller för alla <code>position</code>-värden utom <code>static</code>, gäller följande endast för <code>position</code>-värdet <code>relative</code>.</p><p>Relative ignorerar hur användaren scrollar i ett dokument. En tänkt koordinat, säg <code>{100,120}</code>, står i relation till browserns storlek och endast browserns storlek och det "fönster" där browsern renderar sidan. Med andra ord, kommer elementet alltid att befinna sig 120px ifrån fönstrets topp, <em>inte</em> ifrån dokumentets topp (vilket är hur <code>absolute</code> positionering beteer sig).</p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#blue {
  position: fixed;
  top:  20px;
  left: 30px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Bilden i detta exempel har fixed positionering</div><div class="panel-body"><iframe id="example-css-position-fixed" style="width:100%; height:200px; border:1px solid #dedede; overflow:scroll;"></iframe></div></div><h3>Absolute</h3><p>Även med absolut positionering så säger vi åt ett element att ignorera sitt "normala" dokumentsflöde och istället placera sig på precis de koordinater vi specificierar.</p><p>Frågan är då bara &mdash; precis på de koordinaterna i relation till vad? I det normala fallet så betyder det i relation till fönstret. Men om någonting absolut positionerat befinner sig i någonting annat som är absolut eller relativt positionerat så räknar vi då i relation till den föräldern.</p><p>Ovan blir nog enklare att förstå om vi ser till ett par exempel.</p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#red {
  position: absolute;
  top:   0;
  right: 0;
}
#blue {
  position: absolute;
  bottom: 0px;
  left:   0px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på absolut positionering för två <code>&lt;div&gt;</code>:ar</div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:absolute;top:0;right:0;"></div><div style="width:70px;height:70px;background:blue;position:absolute;bottom:0;left:0;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på absolut positionering för en <code>&lt;div&gt;</code> i en absolut positionerad <code>&lt;div&gt;</code></div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:absolute;top:0;right:0;"><div style="width:70px;height:70px;background:blue;position:absolute;bottom:0;left:0;"></div></div></div></div><h3>Relative</h3><p>När vi positionerar ett element relativt så är det som om vi kombinerar metoderna statisk och absolut. Vi positionerar ett element relativt till dess statiska position.</p><p>Med andra ord, elementet antar först den position den bör få i det statiska flödet, och vi ser nu den platsen som "nollpunkten" (origo). Sedan tas elementet ut ur dokumentflödet och vi placerar det absolut (enligt de koordinater vi angett) i relation till sin statiska placering. </p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#red {
  position: relative;
  top:  0;
  left: 0;
}
#blue {
  position: relative;
  top: -10px;
  left: 10px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på relativ positionering för två <code>&lt;div&gt;</code>:ar</div><div style="height:200px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:relative;top:0;left:0;"></div><div style="width:70px;height:70px;background:blue;position:relative;top:-10px;left:10px;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på relativ positionering för en <code>&lt;div&gt;</code> i en relativt positionerad <code>&lt;div&gt;</code></div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:relative;top:0;right:0;"><div style="width:70px;height:70px;background:blue;position:relative;top:-10px;left:10px;"></div></div></div></div><h3>Video om centrering</h3><p>Om du finner ovan lite konfunderande finns nedan en film som applicerar några av dessa metoder i praktiken.</p><p>I videon är målet att centrera en <code>&lt;div&gt;</code> horisontellt och vertikalt på sidan. Detta vilket bl.a. leder oss in på en teknik som använder sig av positionering genom <code>absolute</code>.</p><div class="panel panel-default"><div class="panel-heading">En video om horisontell &amp; vertikal centrering med css</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/GqCj_sHxzGE?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><h1 href="#04-00-js-intro" name="04-00-js-intro" id="04-00-js-intro">JavaScript</h1><p class="lead">Den största limitationen med HTML och CSS skulle kunna beskrivas med ett att de är ett ord &mdash; statiska. De båda språken klarar av en viss nivå av interaktivitet, men i huvudsak behöver vi någonting mycket mer dynamiskt för att kunna uppnå seriös interaktivitet. Ridån faller.. och in kommer JavaScript!</p><div class="page-header"><h2 href="#04-01-js-intro" name="04-01-js-intro" id="04-01-js-intro">Introduktion till JavaScript</h2></div><p>Om du börjar jobba med HTML och CSS kommer du snabbt upptäcka att de båda teknikerna har sina limitationer. Limitationen skulle enkelt kunna beskrivas som avsaknaden av ett ord &mdash; interaktivitet!</p><h3>Problemet</h3><p>Visst, vi kan använda HTML för att strukturera content, och visst, vi kan använda CSS för att positionera, och style:a innehållet så att det inte bara är snyggt utan även kognitivt lättillgängligt för en människa. Men hur är det egentligen med interaktiveten?</p><p>Förvisso kan vi använda pseudo-selektorn <code>:hover</code> i css för att skapa effekter när användaren låter musen rulla över länkar (såsom t.ex. understrykning). Och visst, vi kan ju genom HTML skapa olika sidor som vi sedan sammanlänkar genom hyperlänkar (<code>&lt;a&gt;</code>-taggen), vilket alltså betyder att användaren interaktivt kan navigera sig emellan dessa sidor.</p><p>Onekligen är ovan två nämnda exempel just det, exempel på interaktiviet vi kan uppnå genom HTML och CSS. Men finns det interaktivitet vi skulle vilja skapa som vi inte kan uppnå med bara HTML och CSS? Föreställ dig en delete-knapp. Föreställ dig att vi har en applikation, vilken som helst, och det finns en knapp som säger "Ta bort mitt konto". Vore det inte då rimligt att be användaren att konfirmera att denne verkligen vill ta bort sitt konto när den trycker på knappen? Självklart.</p><p>Tänk på ovan exempel en stund. Hur skulle vi lösa det genom HTML? Om vi ignorerar galna lösningar (som jag inte alls skulle rekommendera) med <code>&lt;iframe&gt;</code>'s så har vi egentligen bara ett val. Säg att knappen ligger på en sida som heter <code>delete.html</code>. När man trycker på den knappen behöver vi skicka användaren till en annan sida, vi kallar den för <code>confirm_delete.html</code> där användaren presenteras med två möjligheter till. Alltså två nya länkar till två andra sidor. Kanske är dessa länkar samma sidor som innan, kanske inte. Om inte, så har vi skapat två sidor till, nämligen: <code>yes_delete.html</code> och <code>no_delete.html</code>. Rimligen ser du vilken soppa av sidor det här snabbt blir. Och rimligen har du nu kommit på att det är här JavaScript kommer in i bilden.</p><p>Vi diskuterar nu förstås lite halvsanningar eftersom lösningen skulle kunna bli enklare med ett server-side-språk. Men lita på oss när vi säger att JavaScript kommer göra det ännu enklare.</p><p>Låt oss se till hur vi skulle kunna lösa samma sak genom JavaScript.</p><script>$(function(){
  (function(){
    var $container = $('#example-js-confirmation');
    var setup = function(){
      $container.find('a').click(function(){
        if(confirm("Do you really want to delete your account?")){
          var photo = $container.html();
          $container.html('<p style="color:red !important;">La résistance est futile...... <br><br> ALL YOUR BASE ARE BELONG TO US. <br><br> Your account is sleeping with the fishes..<br><br> <a href="#" class="btn btn-info">Oh noes, click to turn back time!</a>');
          $container.find('a').click(function(){
            $container.html(photo);
            setup();
            return false;
          });
        }
        return false;
      });
    }
    setup();
  })();
});</script><div class="panel panel-default"><div class="panel-heading">Exempel på en confirmation dialog genom JS</div><div id="example-js-confirmation" class="panel-body"><a href="#" class="btn btn-large btn-danger">Delete my account</a></div></div><p>När du provat ovan exempel, finns det en till viktig sak att inse. Interaktiveten i ovan exempel sker "isolerat" i den lilla exempelrutan. Resten av sidan påverkas inte. Slutsatsen vi drar är alltså att vi kan använda JavaScript till att uppnå en nivå av interaktivet vi omöjligen kan uppnå med endast HTML och CSS utan att använda flera sidor.</p><blockquote>Med JavaScript kan vi låta användaren interaktivt interagera med sidan utan att den behöver "laddas om".</blockquote><div class="page-header"><h2 href="#04-02-js-placering" name="04-02-js-placering" id="04-02-js-placering">Vart ska jag skriva JavaScript?</h2></div><p>Innan vi lärt oss ett dugg om JavaScript ska vi köra en djupdyk med näsan först, och skriva vårt första skript. Samtidigt kommer vi att diskutera var vi väljer att placera vår kod och hur man bör arbeta med JavaScript.</p><h3>Ett exempelskript</h3><p>Om det enkla skriptet i nästföljande figur körs på en webbsida så tar den helt sonika bort allt dokumentet innehåller och ersätter det med texten "Evil rabbits... osv". När vi använder det här skriptet som ett exempel i detta dokument så får du låtsas som om varje exempel-ruta är en egen webbsida. För om vis kulle köra <code class="language-javascript">document.write("");</code> på hela denna sida skulle vi ju rensa hela sidan vilket skulle göra det väldigt svårt för dig att fortsätta läsa denna text.</p><div class="panel panel-default"><div class="panel-heading">Exempelskriptet</div><div class="panel-body"><pre><code class="language-javascript">document.write("Evil rabbits are taking over our servers! Must find carrots!");</code></pre></div></div><p>Hursomhelst, låt oss nu istället diskutera lite olika platser vi skulle kunna lägga in detta skript på.</p><h3>Direkt i HEAD</h3><p>Ett ställe vi kan placera vår JavaScript på är rakt upp och ner i <code>&lt;HEAD&gt;</code>-taggen. Så länge som vi snurrar in vår JavaScript emellan starttaggen <code>&lt;script&gt;</code> och sluttaggen <code>&lt;/script&gt;</code>. Nedan följer ett exempel i ett minimalistiskt HTML-dokument. När du läser exemplet, tänk framförallt på vart <code>&lt;script&gt;</code>-taggarna och ovan nämn javascript-rad är placerad/-e.</p><div class="panel panel-danger"><div class="panel-heading">JavaScript i <code>&lt;HEAD&gt;</code>-taggen</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
    &lt;script&gt;
      document.write("Evil rabbits...");
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Denna text kommer inte att synas eftersom JavaScriptet skriver över den.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">Evil rabbits...</div></div><p>För att illustrera att detta är någonting som verkligen skapas av JavaScript, så tar vi och <em>kommenterar ut</em> rad 6 såsom nedan. Att kommentera ut en rad gör att den ignoreras av webbläsaren och således inte exekveras.</p><pre data-start="6" class="line-numbers"><code class="language-javascript">// document.write("Evil rabbits...");</code></pre><p>...så får vi istället nedan resultat.</p><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">Denna text kommer inte att synas eftersom JavaScriptet skriver över den.</div></div></div></div><h3>onClick</h3><p>Ett annat ställe vi kan placera vår JavaScript-kod på är i onClick-attributet. Som namnet <code>onClick</code> antyder kommer då koden att exekveras just då &mdash; "on click". Alltså när användaren klickar på elementet i fråga.</p><p>Låt oss se till ett exempel, som använder sig av samma kod.</p><div class="panel panel-danger"><div class="panel-heading">Anonym funktion vid onClick</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;button&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;a onClick="document.write('Evil rabbits...');"&gt;Engage descrution!&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div id="example-js-onclick" class="panel-body"><button class="btn btn-warning">Click to engage destruction!</button><script>$(function(){
  $('#example-js-onclick button').click(function(e){
    $('#example-js-onclick').text('Evil rabbits...');
    e.preventDefault();
  });
});</script></div></div></div></div><p>I ovan exempel finns det tre viktiga skillnader att notera i relation till det första exemplet. Först och främst. Vår JavaScript ligger nu inte längre inom <code>&lt;HEAD&gt;</code>-taggen utan inom <code>&lt;BODY&gt;</code>. Det betyder alltså att vi har specificerat vårt skript bland vårt content och inte vårt meta-content. Eftersom skript inte är content så borde det här ringa en varningssignal om att vi sysslar med en dålig "practice", men det återkommer vi till senare.</p><p>Den andra viktiga skillnaden vi bör inse är att vi inte längre kör vårt JavaScript när sidan laddas utan istället när användaren klickar på en knapp. Vi har alltså inte bara lagt vårt skript rakt av, utan vi har lagt det som en <em>anonym funktion</em> som kommer att köras när <em>event lyssnaren</em> <code>onClick</code> avfyras. Vi kommer att prata mer om <em>event listeners</em> senare men för nu kan du helt enkelt tänka dig det så här. Egenskapen <code>onClick</code> är ett nyckel-värde-par där värdet är en sträng. Denna sträng kommer inte att tolkas som vilken sträng som helst, utan kommer att exekveras som JavaScript. Vi hade således kunnat skriva vilken arbiträr mängd JavaScript som helst mellan de två citationstecknena som delimiterade värdet. Låt oss se till ett exempel till för att verkligen förstå hur det fungerar.</p><div class="panel panel-danger"><div class="panel-heading">Anonym funktion vid onClick</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;a onClick="alert('Hello...'); alert('...you!');"&gt;Welcome me!&lt;/a&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div id="example-js-onclick" class="panel-body"><button onclick="alert(&apos;Hello...&apos;);alert(&apos;...you!&apos;);" class="btn btn-warning">Welcome me!</button></div></div></div></div><blockquote class="text-danger">Glöm nu allt du lärt dig om att skriva inline-javascript i <code>onClick</code> och glöm nästan allt du lärt dig om att skriva JavaScript direkt i <code>&lt;head&gt;</code> &mdash; det finns bättre sätt!</blockquote><p>Som vanligt är detta bättre sätt baserat på idéen om "<a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>" och innebär att vi flyttar vår JavaScript till en separat fil. Och det är detta vi kommer göra i nästa stycke.</p><h3>JS i separat fil</h3><p>Om du inte har en medveten anledning till varför du inte ska göra det så är det bästa sättet att hantera JavsScript &mdash; i en separat fil. På precis samma sätt som vi arbetar med CSS så skapar vi en ny fil som vi döper till <code>ett-schysst-filnamn.js</code>. Notera alltså ändelsen <code>.js</code>. Sedan gör vi på precis (nästan) samma sätt som när vi har en extern CSS-fil. Alltså, vi lägger in ett element i <code>&lt;head&gt;</code> som pekar på vår JavaScript-fil. Som så:</p><div class="panel panel-success"><div class="panel-heading">Ladda in en extern javascript-fil</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">document.write("Oh noes evil rabbits...");</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Oh noes evil rabbits...</p></div></div></div></div><p>Notera alltså rad 5 i ovan exempel. Det är just rad 5 som berättar för webbläsaren vart JavaScript-filen finns. Vi anger .js-filens plats med en relativ sökväg genom att bara skriva <code>filnamnet.js</code> rakt upp och ned. Så webbläsaren kommer alltså leta efter en fil vid namn <code>filnamnet.js</code> i <em>samma mapp</em> som index.html ligger.</p><div class="panel panel-warning"><div class="panel-heading">Överkurs</div><div class="panel-body"><p>Kanske har du märkt att många webbutvecklare laddar in sina JavaScript-filer i <code>&lt;body&gt;</code> och inte i <code>&lt;head&gt;</code>. Detta har med performance och göra, och är egentligen en superb idé! Låt oss prata om varför.</p><p>När en webbläsare renderar en webbsida så går den uppifrån och ned. Och när den stöter på ett request till en extern resurs, såsom en bild, en css-fil, eller en javascript-fil etc. så behöver den stanna, vänta, och ladda in filen. Tänk på det en stund. När vi lägger in en bild i ett html-dokument så lägger vi ju faktiskt inte in bilden utan endast en <em>referens till den plats <code>url</code> där bilden befinner sig</em>. Detta innebär att webbläsaren alltså måste <em>hämta</em> ("ladda ner") denna bild för att faktiskt kunna visa den.</p><p>Eftersom webbläsare endast kan hantera ett limiterat antal requests parallelt så betyder det att sidan lätt fastnar i en <a href="http://en.wikipedia.org/wiki/Bottleneck">flaskhals</a>. Standarden HTTP/1.1 specificerar att en browser max bör hålla <a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">två öppna connections per server</a>, detta vilket uppenbart orsakar en flaskhals ifall vi hämtar 10 bilder, 2 css-filer och 1 javascript-fil ifrån vår egen server.</p><p>Moderna browsers har dock valt att ignorera dessa maxtal och hanterar faktiskt fler <a href="http://www.browserscope.org/?category=network&amp;v=top">parallella uppkopplingar</a> men trots detta har det blivit praxis att låta JavaScript-filerna laddas in allra sist i <code>&lt;body&gt;</code>. Anledningen till detta är alltså att om webbläsaren får en chans att parse:a hela <code>&lt;body&gt;</code>:n innan den krockar med det element som pekar på en javascript-fil, så betyder det att webbläsaren kommer ha en chans att visuellt printa ut sidan för användaren och <em>SEN</em> börja hämta denna javascript-fil.</p><p>Faktum är att det t.o.m. är <a href="http://www.w3schools.com/js/js_howto.asp">tillåtet enligt specifikation</a> att placera <code>&lt;script&gt;</code>-taggar i <code>&lt;body&gt;</code>. Låt oss se till ett exempel över hur detta skulle kunna se ut.</p><div class="panel panel-default"><div class="panel-heading">Ladda in JavaScript-filer i slutet av <code>&lt;body&gt;</code></div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Först lägger vi allt vårt content&lt;/p&gt;
    &lt;p&gt;Och sen sist, laddar vi in js:&lt;/p&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Således används alltså denna teknik för att ge användaren en känsla av att sidan har laddat klart snabbare än den egentligen gör. Om vi lägger våra javascript-filer i <code>&lt;head&gt;</code> kommer webbläsaren alltså att "blocka" sidan och inte printa ut någonting visuellt förrän <em>hela</em> javascript-filen har laddats ned. Men om vi lägger referensen till vår javascript fil i slutet av <code>&lt;body&gt;</code> kommer webbläsaren att rendera hela <code>&lt;body&gt;</code>:n innan den börjar blocka och ladda in javascript-filen.</p><p>Såsom mycket annat i världen så är detta inte svart eller vitt, utan det finns många fall där vi faktiskt bör ladda in JavaScript i <code>&lt;head&gt;</code>. Du kan läsa mer om detta bl.a. <a href="http://stackoverflow.com/questions/14328449/when-do-you-put-javascript-in-body-when-in-head-and-when-use-doc-load">här</a>.</p></div></div><div class="page-header"><h2 href="#04-03-js-variabler" name="04-03-js-variabler" id="04-03-js-variabler">Variabler</h2></div><p>Eftersom JavaScript, som namnet antyder, är ett skriptspråk har vi tillgång till mäktiga koncept såsom variabler och funktioner. En variabel kan metaforiskt ses som en box vi lägger någonting i, och det är just denna box vi kommer att fokusera på i detta kapitel.</p><h3>Vad är variabler?</h3><p>Variabler kan ses som en arbiträr box, av arbiträr storlek, där vi kan placera ett stycke, och endast ett stycke, arbiträr data. Tänk på det en stund. Låt oss formulera om samma sak. En variabel är en pekare mot en arbiträr plats i minnet, av arbiträr storlek, som innehåller arbiträr data. Det är lite närmare sanningen men fortfarande en metafor.</p><blockquote>Variabler kan ses som en arbiträr box, av arbiträr storlek, där vi kan placera ett och endast ett stycke arbiträr data.</blockquote><p>Så hur deklarerar vi då en variabel? Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Variabeldeklaration och tilldelning</div><div class="panel-body"><pre><code class="language-javascript">var name = "Dr. Zaius";</code></pre></div></div><p>I ovan exempel deklarerar ("skapar") vi alltså en variabel och tilldelar den värdet av texten "Dr. Zaius". Således finns det alltså två saker vi gör här. Vi (1) deklarerar, och vi (2) tilldelar. Låt oss se till ett nytt exempel där vi gör dessa steg för steg.</p><div class="panel panel-default"><div class="panel-heading">Deklarering och tilldelning</div><div class="panel-body"><pre><code class="language-javascript">// Deklaration
var name;     // name =&gt; undefined
var age;      // age  =&gt; undefined
 
 // Tilldelning
name = "Dr. Zaius";   // name =&gt; "Dr. Zaius"
age = 42;             // age  =&gt; 42
 
// Deklaration och tilldelning samtidigt
var species = "Orangutang";</code></pre></div></div><p>Notera alltså att ovan exempel illustrerar att det är fullt möjligt att först deklarera en variabel och sedan tilldela den ett värde, i två steg. Detta kommer sig av den enkla anledningen att tilldelning och deklaration är två olika saker.</p><dl class="dl-horizontal"><dt>Deklaration</dt><dd>Att säga att någonting <em>existerar</em>
(<code class="language-javascript">var foo;</code>)</dd><dt>Tilldelning</dt><dd>Att säga vad någonting <em>innehåller</em>
(<code class="language-javascript">foo = "bar";</code>)</dd></dl><p>I många språk deklarerar vi variabler som olika <em>typer</em> beroende på vad för typ av innehåll vi vill kunna lagra i variabeln (text, heltalsnummer, decimaltal etc.) men i JavaScript räcker det med att vi deklarerar att variabeln <em>finns</em>. Vilken typ den sedan är av, avgörs av vad vi sedan väljer att lagra i den. JavaScript är alltså vad vi brukar kalla för ett <a href="http://sv.wikipedia.org/wiki/Typsystem">Dynamiskt typat språk</a>.</p><h3>Video</h3><p>Nedan följer en kort videointroduktion till variabler i JavaScript.</p><div class="panel panel-default"><div class="panel-heading">Videointroduktion till variabler i JavaScript</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/J_XO0AzXE6Q?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><h3>Datatyper</h3><p>Vad kan vi lagra? Kort sagt: vad som helst som faller under JavaScripts tre <a href="http://msdn.microsoft.com/en-us/library/ie/7wkd9z69(v=vs.94).aspx" target="_blank">datatypskategorier</a>: primära datatyper, komposit-datatyper, eller speciella datatyper. Dessa är som följer:</p><table class="table table-condensed"><tr><th>Datatyp</th><th>Förklaring</th><th>Exempel (separerade med ;)</th></tr><tr><td colspan="3" class="table-divider">Primary datatypes</td></tr><tr><td><code>number</code></td><td>Siffror</td><td><code class="language-javascript">0;   12;   -432;   11.4;   -32.4;</code></td></tr><tr><td><code>string</code></td><td>Text</td><td><code class="language-javascript">"Ekonomikum 1A";</code></td></tr><tr><td><code>boolean</code></td><td>Sant eller falskt</td><td><code class="language-javascript">true;   false;</code></td></tr><tr><td colspan="3" class="table-divider">Composite datatypes</td></tr><tr><td><code>array</code></td><td>Listor innehållandes andra datatyper</td><td><code class="language-javascript">[1, 3, 2];   ["Hello", 123];</code></td></tr><tr><td><code>object</code></td><td>Nycklar som pekar på värden</td><td><code class="language-javascript">{ title:"Dr", name:"Snuggles" }</code></td></tr><tr><td colspan="3" class="table-divider">Special datatypes</td></tr><tr><td><code>null</code></td><td>Värdet för ingenting</td><td><code class="language-javascript">null;</code></td></tr><tr><td><code>undefined</code></td><td>Värdet för avsaknaden av ett värde</td><td><code class="language-javascript">undefined;</code></td></tr></table><h3>Likhetstecknet</h3><p>Någonting som ofta är förvirrande när det kommer till programmering är att likhetstecknet (<code>=</code>) i programmering skiljer sig signifikant ifrån likhetstecknet i matematik. Likhetstecknet i matematik implicerar ekvivalens medan likhetstecknet i programmering implicerar tilldelning. Vad är då skillnaden?</p><p>Om två uttryck är ekvivalenta menar vi att vi kan ersätta det första uttrycket med det andra och det betyder samma sak. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Ekvivalens i matematik</div><div class="panel-body"><pre>(1 + 1)  =  (2)</pre>De två uttrycken, isolerade av paranteser, är ekvivalenta och vänstra ledet kan således ersättas med det högra. Detta gäller inte i programmering.</div></div><blockquote>Likhetstecknet i matematik implicerar ekvivalens medan likhetstecknet i programmering implicerar tilldelning.</blockquote><p>Men om ekvivalens inte gäller i programmering, vad gäller då istället? Jo, tilldelning. Med matematisk ekvivalens menar vi att evalueringen (resultatet av att beräkna) av det vänstra ledet är exakt samma sak som evalueringen av det högra ledet. Med tilldelning däremot, menar vi att evalueringen (resultatet av beräkningen) av det högra ledet <em>representeras</em> av det vänstra ledet.</p><p>I matematik tänker vi ofta i termer av sanning, men för att lättare förstå hur imperativ programmering fungerar kan det vara fördelaktigt att istället försöka tänka i termer av att vi "räknar ut värden och lägger de i lådor (variabler)". Boxarna har ingen aning om vart värdena kom ifrån, och värdena har ingen aning om i vilka boxar de kommer placeras.</p><p>Kanske hade det varit lättare att förstå tilldelning om syntaxen (notationen) istället hade varit <code>a &lt;= 23</code>. Alltså: lagra värdet 23 i variabeln a.</p><div class="panel panel-default"><div class="panel-heading">Tilldelning i programmering</div><div class="panel-body"><pre><code class="language-javascript">var a = 1;            // a =&gt; 1
var b = a + 3;        // b =&gt; 4
var c = a + b;        // c =&gt; 5
var d = a + b + c;    // d =&gt; 10</code></pre>Läs ovan, rad för rad, och fundera över varför det resultat som sparas i variabeln blir det som visas i kommentaren till höger.</div></div><blockquote>När vi pratar om programmering är det lättare att tänka att vi "räknar ut värden och lägger resultaten i boxar".</blockquote><div class="page-header"><h2 href="#04-04-js-funktioner" name="04-04-js-funktioner" id="04-04-js-funktioner">Funktioner</h2></div><p>Nu börjar vi närma oss de signifikant mer intressanta delarna av programmering. Funktioner! Funktioner i programmering kan med fördel jämföras med funktioner i matematik. En funktion är som en maskin. En maskin där du kan stoppa in ett ting och få ut ett annat ting. Alltså en funktion (<code>F</code>) som tar emot ett ting (<code>x</code>) och returnerar ett annat ting (<code>y</code>), där detta andra ting, i matematik, kan uttryckas som en funktion applicerad på det första (<code>F(x)</code>).</p><p>PS. Vänligen anmäl oss inte till Högeskoleverket om det skulle vara så att våra matematiska metaforer är inkorrekta. Vi försöker bara använda de här för att skapa en förståelse.</p><p>Innan vi fortsätter prata om hur funktioner fungerar, låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Funktionsdefinition</div><div class="panel-body"><pre><code class="language-javascript">var addition = function(x, y){
  return x + y;
}</code></pre><p>Ovan definerar vi en funktion, som vi namnger <code>addition</code>, och som returnerar resultatet av en addition av dess två parametrar. Motsvarande funktion skulle matematiskt kunna uttryckas:</p><pre>F(x, y) = x + y</pre></div></div><p>Vi har nu sett hur man definierar en funktion. Men hur använder vi den då? Låt oss återigen se till några exempel.</p><div class="panel panel-default"><div class="panel-heading">Funktionsanrop</div><div class="panel-body"><pre><code class="language-javascript">// Först definierar vi en funktion
var addition = function(x, y){
  return x + y;
}
 
// Sen anropar vi funktionen
addition(1, 1);                         // =&gt; 2
addition(30, 5);                        // =&gt; 35
addition(addition(1,2), 4)              // =&gt; 7
addition(addition(1,addition(1,1)), 4)  // =&gt; 7</code></pre><p>Låt oss uttrycka samma sak i matematik för att skapa ytterligare förståelse för vad vi gör:</p><pre><code>Först definierar vi funktionen...
F(x, y) = x + y
 
Sen använder vi den...
         F(1, 1) = 2
        F(30, 5) = 35
    F(F(1,2), 4) = 7
F(F(1,F(1,1), 4) = 7</code></pre></div></div><p>Notera alltså att vi kan skicka resultatet av en funktion som parameter (input) till en annan funktion. Precis som i matematik så måste den innersta beräkningen utföras först innan vi kan utföra den yttre.</p><blockquote>Precis som i matematik behöver det innersta uttrycket räknas ut först innan vi kan fortsätta "utåt".</blockquote><h3>Olika sätt att deklarera funktioner</h3><p>Eftersom JavaScript på gott och ont är väldigt flexibelt finns det olika sätt att deklarera funktioner.</p><h4>Function statement</h4><p>Detta är det klassiska sättet att deklarera funktioner i JavaScript.</p><pre><code class="language-javascript">function myFunc(){ //work };</code></pre><p>Denna metod gör att funktionsnamnet är tillgängligt i hela sitt scope. Även innan den är deklarerad.</p><pre><code class="language-javascript">console.log(myFunc());  // => Hello
function myFunc(){ return "Hello" };</code></pre><h4>Function expression</h4><p>Detta sätt att deklarera kan ses som att vi tilldelar en anonym funktion till en variabel.</p><pre><code class="language-javascript">var myFunc = function(){ //work };</code></pre><p>När vi deklarerar en funktion så här så är den inte tillgänglig före deklarationen, endast efter.</p><pre><code class="language-javascript">console.log(myFunc()); // => TypeError
var myFunc = function(){ return "Hello" };</code></pre><h4>Kombination</h4><p>Vi kan även kombinera ovan två metoder som så:</p><pre><code class="language-javascript">var myFunc = function myFunc(){ // work };</code></pre><h4>Vilket sätt bör vi använda?</h4><p>Så, istället för att gräva ned oss i vilket sätt man bör använda så föreslår vi att du följer <a href="http://www.unicodegirl.com/function-statement-versus-function-expression.html">Douglas Crockford's rekommendation</a> om att använda function expressions. Alltså:</p><pre><code class="language-javascript">var myFunc = function(){ //work };</code></pre><blockquote class="text-info">Välj function expressions över function statements, tills den dag kommer du då intresserar dig av att lära dig varför.</blockquote><div class="page-header"><h2 href="#04-05-js-dom" name="04-05-js-dom" id="04-05-js-dom">Document Object Model</h2></div><p>Document Object Model(DOM) är ett API för HTML och XML dokument. Den definierar den logiska strukturen och hur man kommer åt ett dokument och manipulerar det. </p><h3>Javascript och DOM </h3><p>Med denna modell kan vi nu med hjälp av Javascript kunna modifiera trädet och skapa dynamiska hemsidor. Det handlar alltså om att vi kan ta bort, komma åt, modifiera och lägga till element.</p><h3>Document</h3><p>Document är ett objekt som "Äger" alla andra objekt, med det menas att utifall du vill komma åt andra objekt i DOM:en görs detta genom <code> document.method()</code>. </p><table class="table table-condensed"><tr><th>Metod</th><th>Förklaring</th></tr><tr><td colspan="3" class="table-divider">Hitta element</td></tr><tr><td><code>document.getElementById()</code></td><td>Hämtar ett element med hjälp av dess ID </td></tr><tr></tr><tr><td><code>document.getElementsByTagName()</code></td><td>Hämtar alla element med hjälp av dess tagnamn </td></tr><tr></tr><tr><td><code>document.getElementsByClassName()</code></td><td>Hämtar ett element med hjälp av dess klassnamn</td></tr></table><h3>Element</h3><p>När vi hämtar ett element ur DOM:en genom någon av de metoder som diskuterades ovan, så kan vi sedan läsa och skriva information till det elementet. Ett element är alltså bara ännu ett objekt med ett antal egenskaper och metoder. Med andra ord kan vi inte bara läsa ifrån DOM:en, utan vi kan även förändra den. Nedan ser du några exempel på vad vi kan göra med ett element</p><table class="table table-condensed"><tr><td colspan="3" class="table-divider">Antag att vi har ett element i variabeln elem</td></tr><tr><td><code>elem.innerHTML</code></td><td>Ändrar den inre HTML:en av ett element</td></tr><tr><td><code>elem.attribute</code></td><td>Ändrar ett elements attribut.</td></tr><tr><td><code> elem.style</code></td><td>Ett objekt som vi kan läsa/skriva css från/till</td></tr></table><h3>Exempel</h3><p>Låt oss se till ett par exempel på hur vi kan manipulera DOM:en.</p><div class="panel panel-default"><div class="panel-heading">Exempel på att gömma ett element.</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="secret"&gt; LYSSNA PÅ MIG! &lt;/p&gt; </code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var p = document.getElementById("secret");
p.style.display = "none";</code></pre></div></div></div></div><p>Vad vi gör ovan är alltså helt enkelt att vi först hämtar elementet med hjälp av dess ID. Sedan hämtar vi <code>style</code>-objektet på elementet. På <code>style</code>-elementet sätter vi egenskapen <code>display</code> till värdet <code>none</code>. JavaScriptkoden skulle kunna komprimeras till att skrivas på en enda rad, vet du hur?</p><div class="panel panel-default"><div class="panel-heading">Exempel på att hämta med tagnamn.</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt; A &lt;/p&gt;
&lt;p&gt; B &lt;/p&gt;
&lt;p&gt; C &lt;/p&gt;
&lt;p&gt; D &lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript"> var as = menu.getElementsByTagName('p');  
 as[0].innerHTML = "Ett";
 as[1].innerHTML = "Två";
 as[3].innerHTML = as[1].innerHTML;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Ett</p><p>Två</p><p>C</p><p>Två</p></div></div></div></div><p>Ok, nu kanske det krävs en liten förklaring. Om vi som i första exemplet hämtar med id då vet vi att vi endast får ett objekt tillbaka. I andra exemplet ovan ber vi om objekten med hjälp av tagnamnet och därför returneras dessa i en array. Med andra ord: när vi hämtar ett element genom ett ID kan vi alltid vara hundra på att det bara finns ett (eftersom ett ID endast får förekomma en gång i ett HTML-dokument). Men när vi söker element via tagnamn så kan vi omöjligen veta hur många instanser det finns av just den taggen. Således har man valt att låta <code>getElementsByTagName</code> returnera en array. Således är det även därför vi ovan använder bracket-notationen (<code>[x]</code>) för att arbeta med resultatet.</p><blockquote class="text-warning">Se till att du förstår varför outputen i exemplet ovan blir som den blir innan du går vidare</blockquote><h3>onload</h3><p>När vi skriver JavaScript som på något sätt interagerar med DOM:en, är det viktigt att vi är säkra på att DOM:en är redo (inladdad) innan vi börjar försöka nå den. Detta gör vi enkelt genom att använda oss av metoden <code>onload</code>.</p><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi använder onload.</div><div class="panel-body"><pre><code class="language-javascript">window.onload = function(){
  // do all fancy work here
}</code></pre></div></div><p>Varför gör vi alltså detta? Jo, om vi inte skulle göra det så finns alltså risken för att de element vi försöker komma åt inom funktionskroppen i ovan exempel ännu inte finns.</p><p>Ovan kan förstås lika gärna göras i två steg, genom att registrera en redan deklarerad funktion.</p><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi använder onload.</div><div class="panel-body"><pre><code class="language-javascript">// Declare the init function
var init = function(){
}
 
// Register it as a listener to the onload event
window.onload = init;</code></pre></div></div><p>Vad vi har gjort nu kallas mer generellt för att registrera en funktion (en <code>event handler</code>) till ett <code>event</code>. Mer om detta i avsnittet om events.</p><div class="page-header"><h2 href="#04-05-js-events" name="04-05-js-events" id="04-05-js-events">Event listeners</h2></div><p>Nästa ämne vi ska prata om är eventlyssnare. Något som finns i många programmeringsspråk och som ofta beteer sig liknande, om än med olika syntax. För att förstå event listeners, fundera över följande: hur vet vi att en användare har klickat på en knapp?</p><p>Mer generellt uttryckt: Event listeners hjälper oss att exekvera specifik kod vid en specifik händelse. Det kan tyckas trivialt. Men tänk på när vi skriver ett program. Om vi inte hade events skulle hela programmet endast kunna köras i ett svep (rufft uttryckt). Programmet börjar exekveras, och oavsett hur mycket klasser och funktioner vi använder så kommer programmet att köras ifrån början till slut. Med events så kan vi däremot registrera vad som kallas för <code>lyssnare</code>. Programmets exekvering "fryser" inte. Programmet stannar alltså inte när vi registrerar en event listener utan fortsätter exekvera som vanligt. När den händelse som eventlyssnaren lyssnar efter (exempelvis en knapptryckning) händer så exekveras koden lyssnaren pekar på. Detta kallas ofta för <a href="http://en.wikipedia.org/wiki/Event-driven_programming">event-driven programming</a>.</p><p>Vi ska i det här kapitlet prata om metoden <code>addEventListener()</code>, men för att enklare förstå hur de fungerar behöver vi först prata om vad det betyder att JavaScript har en <code>Asynkron Event Model</code>. Beakta följande kodexempel:</p><div class="panel panel-default"><div class="panel-heading">Exempel på asynkron exekvering i JavaScript</div><div class="panel-body"><pre><code class="language-javascript">console.log("a");
 
 
// setTimeout är en funktion som kör en annan
// funktion efter en given väntetid i millisekunder
 
setTimeout(function(){
  console.log("b");
}, 1000)
 
 
console.log("c");</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>a</p><p>c</p><p>b</p></div></div></div></div><p>Hur kan det komma sig att vi fick outputen i ovan ordning? Detta har alltså att göra med den asynkrona event modellen i JavaScript. Den funktion som körs av <code>setTimeout</code> körs inte förrän väntetiden på <code>1000 ms</code> har passerat. Men, eftersom JavaScript har asynkrona event, så registreras denna funktion som ett event. Således kommer programmet fortsätta att exekvera. När tiden sedan gått ut, och event-loopen är "ledig" så exekveras den givna funktionen.</p><p>Om <code>setTimeout</code> hade varit en synkron metod hade exekveringen avstannat ("fryst") vid anropet till <code>setTimeout</code>, och inte fortsatt förrän väntetiden passerat.</p><div class="panel panel-info"><div class="panel-heading">Kuriosa</div><div class="panel-body"><p>Även om vi hade satt timeout-tiden ovan till 0ms så hade vi fått samma output. Varför? Jo, för att även om väntetiden för <code>setTimeout</code> är 0 så registrerar den funktionen till event-loopen utan att exekvera den på en gång. Således kan den givna funktionen inte exekveras förrän nästa lediga "tick" i event-loopen.</p></div></div><p>Varför är detta då viktigt? Jo, detta gäller alltså även för när vi registrerar event-lyssnare.</p><h3>addEventListener</h3><p>Istället för att gräva ned oss i mer teori, låt oss kolla på ett exempel kring hur vi kan använda <a href="p Varf&#xF6;r &#xE4;r detta d&#xE5; viktigt? Jo, detta g&#xE4;ller allts&#xE5; &#xE4;ven f&#xF6;r n&#xE4;r vi registrerar event-lyssnare.">addEventListener</a>.</p><div class="panel panel-default"><div class="panel-heading">Exempel på asynkron exekvering i JavaScript</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="eventlistener-example-1"&gt;
  hello
&lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var tag = document.getElementById('eventlistener-example-1');
tag.addEventListener("click", function(){
  if(tag.innerHTML == "hello")
    tag.innerHTML = "world";
  else
    tag.innerHTML = "hello";
});</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat (prova att klicka på texten!)</div><div class="panel-body"><p id="eventlistener-example-1">hello</p></div></div></div></div><script>var tag = document.getElementById('eventlistener-example-1');
tag.addEventListener("click", function(){
  if(tag.innerHTML == "hello")
    tag.innerHTML = "world";
  else
    tag.innerHTML = "hello";
});</script><h4>Webbläsarstöd</h4><p>Nu är en bra tid att prata om webbläsarstöd. Äldre webbläsare stödjer inte metoden addEventListener, så om ovan exempel inte fungerar för dig så betyder det att din webbläsare är för gammal. Internet Explorer, tidigare och upp till, 8 har en alternativ implementation där metoden heter <code>attachEvent</code>. Så för att ovan exempel även ska fungera i Internet Explorer 8 behöver vi välja vilken metod vi använder berodende på vilken som finns. Läs mer om det i denna tråd på <a href="http://stackoverflow.com/questions/6927637/addeventlistener-in-internet-explorer">Stack Overflow</a>.</p><h4>Återanvändbara event handlers</h4><p>Den funktion som körs när ett event avfyras, kallas för en <code>event handler</code>. Självklart hade vi ju kunnat skriva denna event handler som en function declaration eller function expression istället för att bara skriva den inline. Detta är bra eftersom vi då kan återanvända beteende. Såsom nedan:</p><div class="panel panel-default"><div class="panel-heading">Exempel på användning av addEventListener</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="eventlistener-example-2"&gt;
  hello
&lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var onClick = function(element){
  if(element.target.innerHTML == "hello")
    element.target.innerHTML = "world";
  else
    element.target.innerHTML = "hello";
}
 
document.getElementById('eventlistener-example-2-1').addEventListener('click', onClick);
document.getElementById('eventlistener-example-2-2').addEventListener('click', onClick);</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat (prova att klicka på olika texterna!)</div><div class="panel-body"><p id="eventlistener-example-2-1">hello</p><p id="eventlistener-example-2-2">world</p></div></div></div></div><script>var onClick = function(element){
  if(element.target.innerHTML == "hello")
    element.target.innerHTML = "world";
  else
    element.target.innerHTML = "hello";
}
document.getElementById('eventlistener-example-2-1').addEventListener('click', onClick);
document.getElementById('eventlistener-example-2-2').addEventListener('click', onClick);</script><p>Styrkan i ovan exempel är ju alltså att vi nu kan återanvända vår eventhandler och attacha den till flera olika events. En annan lärdom vi kan dra av ovan exempel är att eventhandlers anropas med argument. Detta kan vi använda för att upptäcka vilket element som faktiskt har avfyrat eventet.</p><!-- TODO: Need to write more about event handler arguments--><!-- TODO: Need to write about event--><div class="page-header"><h2 href="#04-05-js-objekt" name="04-05-js-objekt" id="04-05-js-objekt">Objekt</h2></div><p>JavaScript är inte ett <a href="http://sv.wikipedia.org/wiki/Objektorienterad_programmering">objektorienterat</a> språk i den klassiska bemärkelsen utan istället ett <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototypbaserat</a> språk. Vad detta innebär kommer vi inte fokusera på i denna sektion, och därmed kommer vi inte syssla med instansiering. Istället kommer vi använda objekt som ett sätt att organisera vår kod.</p><h3>Vad är ett objekt?</h3><p>Om du programmerat i ett tidigare språk så kan du jämföra JavaScript-objekt med <code>map</code>'s eller <code>dictionary</code>'s. Om du inte har programmerat tidgare så kan du jämföra objekt med uppslagsverk. Va? Jo, precis så! Helt vanliga gamla bokuppslagsverk. Vänta nu? Va? Jo men tänk dig. Hur fungerar ett uppslagsverk. Om jag undrar vad ordet "katt" betyder så tar jag mitt fysiska uppslagsverk (objektet) och börjar leta efter uppslagsordet "katt" (nyckeln), och när jag väl hittat det så läser jag beskrivningen av vad en katt är (värdet).</p><p>Låt oss analysera de tre nyckelorden vi identifierat i ovan stycke.</p><dl class="dl-horizontal"><dt>Objekt</dt><dd>En datatyp som innehåller en kollektion av nycklar som pekar på värden (nyckel-värde-par)</dd><dt>Nyckel</dt><dd>En unik identifierare, såsom "namn", eller "nummer".</dd><dt>Värde</dt><dd>Ett värde kan vara av vilken annan datatyp som helst. Ett värde kan således vara 1 såväl som 32 såväl som "Kapten Haddock" såväl som ett annat objekt.</dd></dl><p>Innan vi snurrar vidare är det nog bäst att vi börjar undersöka syntaxen vi använder för att skapa objekt och således diskutera ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Object literals</div><div class="panel-body"><pre><code class="language-javascript">var haddock = {
  name : 'Kapten Haddock',
  beard: 'black as the night',
  rank: 1
}</code></pre><p>Nu har vi skapat ett objekt och lagrat det i variabeln <code>haddock</code>. Låt oss nu se hur vi kan interagera med objektet.</p><pre><code class="language-javascript">haddock.name;         // =&gt; "Haddock"
haddock.rank;         // =&gt; 1
haddock.beard;        // =&gt; "black as the night"
haddock.weapon;       // =&gt; undefined</code></pre><p>Vi kan nu alltså använda <em>punkt-notation</em> för att nå de värden som gömmer sig bakom ett objekts nycklar. Men faktum är att vi även kan nå värdena genom att använda samma notation vi använder för att nå värdena i en array. Enda skillnaden är att vi istället för att be om en arrays numeriska index ber vi om värdet bakom en viss nyckel. Låt oss se till ett exempel, och tänk på att det är exakt samma objekt som vi arbetar med i båda dessa två exempel.</p><pre><code class="language-javascript">haddock['name'];         // =&gt; 'Haddock'
haddock['rank'];         // =&gt; 1
haddock['beard'];        // =&gt; "black as the night"
haddock['vegetables'];   // =&gt; undefined</code></pre></div></div><div class="panel panel-warning"><div class="panel-heading">Överkurs</div><div class="panel-body"><p>Om vi jämför de två olika sätten att nå ett objekts värden märker vi snabbt att vi i det första exemplet skriver nyckelns namn rakt av, medan vi i det andra exemplet skriver nyckeln i formen av en sträng. Det betyder att vi skulle kunna byta ut denna <em>sträng</em> emot ett <em>uttryck</em>. Alltså en variabel, eller t.o.m. en funktion! Låt oss prova:</p><pre><code class="language-javascript">var prop = 'name';
haddock[prop];        // =&gt; 'Haddock'
prop = 'rank'
haddock[prop];        // =&gt; 1
prop = 'beard'
haddock[prop];        // =&gt; "black as the night"
prop = 'fruit'
haddock[prop];        // =&gt; undefined</code></pre><p>Beroende på vilket värde vi lägger i variabeln hämtar vi värdena vid olika nycklar. Men om det är så att vi inom klammrarna kan ha ett uttryck vilket som helst så skulle vi ju förstås kunna göra ännu galnare grejer.</p><pre><code class="language-javascript">haddock['na' + 'me'];     // =&gt; 'Haddock'
prop = 'na';
haddock[prop + 'na'];     // =&gt; 'Haddock'
 
// eller vad sägs om funktioner..
function getKey(){
  return 'name'
}
haddock[getKey()];        // =&gt; 'Haddock'</code></pre></div></div><h1 href="#05-00-oss-intro" name="05-00-oss-intro" id="05-00-oss-intro">Open source</h1><p class="lead">Mycket av världens mjukvara drivs av open source. Alltså mjukvara vars källkod är öppen för allmänheten. Men vad är egentligen open source? Hur kan vi använda det? Hur kan vi bidra?</p><div class="page-header"><h2 href="#05-01-oss-intro" name="05-01-oss-intro" id="05-01-oss-intro">Open Source</h2></div><p>Open-source, eller öppen källkod på svenska, är idéen om att lämna ut sin källkod till allmänheten så att vemsomhelst kan använda, modifiera eller bygga vidare på den. Idag är det nästan omöjligt att surfa omkring på internet utan att använda sådant som del- eller helvis står på axlarna av open-source.</p><p>Ett par exempel på lösningar som är drivna med öppen källkod är bloggmotorn <a href="http://sv.wikipedia.org/wiki/Wordpress">WordPress</a>, operativsystemet <a href="http://sv.wikipedia.org/wiki/Linux">Linux</a>, webbservern <a href="http://sv.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a> och databashanteraren <a href="http://sv.wikipedia.org/wiki/MySQL">MySQL</a>.</p><p>Om man ska diskutera de projekt som storskaligt verkligen haft influens på hur vi webbutvecklar är det nästan hädelse att inte nämna <a href="http://jquery.com">jQuery</a>. JavaScript-biblioteket med stort B, som hjälper oss att göra allt ifrån <a href="http://api.jquery.com/animate/">animation</a>, <a href="http://api.jquery.com/each/">iteration</a>, <a href="http://api.jquery.com/jQuery.post/">ajax</a> och att fånga <a href="http://api.jquery.com/category/events/keyboard-events/">tangentbordstryckningar</a>.</p><h1 href="#06-00-jquery-intro" name="06-00-jquery-intro" id="06-00-jquery-intro">jQuery</h1><p class="lead">Att koda JavaScript är en fröjd i många avseenden, men framförallt för att språket genomsyras av en fantastisk open-source-kultur där en multitud av problem redan är lösta. I den här sektionen pratar vi lite om open-source och js-bibliotek generellt. Men framförallt ska vi lära oss att skaka fram webbläsareffekter som en annan jQuery-Houdini. <code>slideIn(); fadeOut();</code></p><div class="page-header"><h2 href="#06-01-jquery-intro" name="06-01-jquery-intro" id="06-01-jquery-intro">jQuery snabbstart</h2></div><p><a href="http://jquery.com/">jQuery</a> är verkligen JavaScript-biblioteket med stort B. Biblioteket hjälper oss att göra allt ifrån <a href="http://api.jquery.com/animate/">animation</a>, <a href="http://api.jquery.com/each/">iteration</a>, till att bygga <a href="http://en.wikipedia.org/wiki/Single-page_application">one-pagers</a> som använder <a href="http://api.jquery.com/jQuery.post/">ajax</a> för att ladda in data, eller att bygga tangentbordsvänliga applikationer genom att fånga <a href="http://api.jquery.com/category/events/keyboard-events/">tangentbordstryckningar</a>. I detta kapitel ska vi dyka rakt in i och börja använda jQuery, utan att fundera särskilt mycket över varför saker fungerar som de fungerar.</p><h3>jQuery är ett bibliotek</h3><p>jQuery är ju alltså ett JavaScript-bibliotek. Ett bibliotek kan, oavsett språk, ses som någonting som utökar det språk vi skriver i för att underlätta vissa aktiviteter.</p><p>Säg att vi t.ex. ofta utför aktivitet <code>A</code>, <code>B</code> och <code>C</code> i följd. Någonting ett bibliotek ofta gör är då att t.ex. ge oss ett nytt namn &mdash; säg <code>Z</code>, vilket vi kan använda för att utföra alla tre aktiviteter samtidigt.</p><p>Ett bibliotek består då alltså av kod, i detta fall kod skriven i JavaScript. Så, för att kunna använda jQuery behöver vi "koppla in" jQuery i våra egna dokument. Låt oss uttrycka oss mer specifikt. Hela jQuery-biblioteket behöver laddas in på varje .html-sida som ska använda jQuery, innan vi försöker använda det.</p><h3>Ladda in jQuery</h3><p>Att ladda in jQuery är enkelt. Hela biblioteket får plats i fil. Vi har två alternativ. Antingen kan vi...</p><ol><li>Kopiera hela biblioteket, eller <a href="http://jquery.com/download/">ladda ned filen</a>, och spara filen i mappen som innehåller vår webbsida, eller..</li><li>Låta våra html-sidor ladda ned jQuery via internet ifrån vad som kallas för en <a href="http://en.wikipedia.org/wiki/Content_delivery_network">CDN</a>.</li></ol><p>För enkelhetens skull kommer vi att arbeta med det senare alternativet. Detta gör vi helt enkelt genom att placera följande script-element i vår .html-fil:</p><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre><code class="language-markup">&lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt;</code></pre></div></div><h3>Ladda in en fil som använder jQuery</h3><p>Så, nu har vi jQuery tillgängligt i vårt dokument. Men efter detta behöver vi ladda in en till JavaScript-fil där vi faktiskt <em>använder</em> jQuery. Låt oss alltså skapa en till .js-fil och ladda in den direkt efter som så:</p><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre><code class="language-markup">&lt;script src="main.js"&gt;&lt;/script&gt;</code></pre></div></div><h3>Använda jQuery</h3><p>Låt oss nu faktiskt använda jQuery till att göra någonting. Vi fortsätter alltså skriva kod i filen <code>main.js</code>. Följande kod kommer att vänta tills <a href="http://sv.wikipedia.org/wiki/Document_Object_Model">DOM</a>:en (alltså HTML-trädet) har laddats in av webbläsaren, och sedan "poppa" up en alert-ruta. Prova att klistra in koden i <code>main.js</code> och ladda om din html-sida.</p><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">$(function(){
  alert("Hello from jQuery");
});</code></pre></div></div><p>Tada!! Vi har nu använt oss av biblioteket jQuery. Låt oss prova någonting annat. Följande kod identifierar alla länkar (<code>&lt;a&gt;</code>-taggar) på din html-sida. Inaktiverar deras vanliga funktionalitet, och gör istället så att de klistrar in bilder på en massa fantastiska katter varje gång du klickar. Tänk på att du alltså behöver lägga in länkar i din html-sida för att nedan kod ska ha någon effekt. Annars har vi ju inga länkar att klicka på.</p><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">$(function(){
  var randomNum = function(){
    return Math.floor(Math.random()*101);
  }
 
  $('a').click(function(){
    e.preventDefault();
    var size = 75 + randomNum(),
    x = randomNum() + '%',
    y = randomNum() + '%',
 
    $img = $('&lt;img/&gt;');
    $img.attr('src', 'http://placekitten.com/'+size+'/'+size);
    $img.css({
      'position': 'fixed',
      'left'    : x,
      'top'     : y
    });
 
    $('body').append($img);
  });
});</code></pre></div></div><p>Om du inte själv har valt att implementera den fantastiska jQuery-koden ovan så kan du få en sneak-peak på vilken underbar värld som väntar genom att prova exemplet nedan!</p><div class="panel panel-default"><div class="panel-heading">Resultat (prova!)</div><div class="panel-body"><p><a class="btn btn-large btn-success jquery-intro-example-1">All your base!</a></p><p><a class="btn btn-large btn-danger jquery-intro-example-2">Reset (you will need it I promise);</a></p><script>$(function(){
 (function(){
   $('.jquery-intro-example-2').click(function(e){
     $('.jquery-intro-example-1-output').remove();
   });
   $('.jquery-intro-example-1').click(function(e){
     e.preventDefault();
     var randomNum = function(){
       return Math.floor(Math.random()*101);
     }
 
     var size = 75 + randomNum(),
     x = randomNum() + '%',
     y = randomNum() + '%',
 
     $img = $('<img/>');
     $img.attr('src', 'http://placekitten.com/'+size+'/'+size);
     $img.addClass('jquery-intro-example-1-output');
     $img.css({
       'position': 'fixed',
       'left'    : x,
       'top'     : y
     });
     
     $('body').append($img);
   });
 })();
});</script></div></div><p>Svårare än så är det inte! Så, när du använder jQuery behöver du helt enkelt komma ihåg tre saker.</p><ol><li>Se till att du laddar in jQuery-biblioteket.</li><li>Se till att din kod som använder jQuery laddas in efter själva biblioteket.</li><li>Se till att den kod som använder jQuery ligger inom <code class="language-javascript">$(document).ready(function(){ /* din kod här */ });</code>.</li></ol><p>Sedan är det bara att tuta och köra!</p><div class="panel panel-info"><div class="panel-heading">Tips!</div><div class="panel-body"><p>Ett kortare sätt att skriva..</p><pre><code class="language-javascript">$(document).ready(function(){
  /* din kod här */
});</code></pre><p>...är att skriva så här...</p><pre><code class="language-javascript">$(function(){
  // din kod här... 
});</code></pre><p>Båda sätten ger samma resultat.</p></div></div><div class="page-header"><h2 href="#06-02-jquery-documentready" name="06-02-jquery-documentready" id="06-02-jquery-documentready">$(document).ready</h2></div><p>I vår första djupdykning in i jQuery pratade vi kort om att det är viktigt att vänta tills hela DOM:en är inladdad innan vi börjar exekvera vår jQuery-beroende kod. I det här kapitlet kollar vi närmare på hur just <code>.ready()</code>-funktionen fungerar. Detta kapitel hjälper dig att skapa en djupare förståelse för både jQuery såväl som JavaScript.</p><h3>När dokumentet är redo för manipulation</h3><p>Denna mystiska ovan nämnda metod vid namn <code>.ready()</code> är en metod vi använder för att kunna vänta med att exekvera jQuery-kod tills webbläsaren har hunnit ladda in ("ned") hela sidan. Låt oss först se till ett exempel och sen diskutera det:</p><div class="panel panel-default"><div class="panel-heading">Att säga åt jQuery att vänta tills DOM:en är inläst</div><div class="panel-body"><pre><code class="language-javascript">$(document).ready(function(){
  alert("Hello world from jQuery");
});</code></pre></div></div><p>Ovan exempel använder jQuery för att avvakta tills webbläsaren har laddat in hela sidan. Sedan använder vi helt vanlig JavaScript för att poppa up en alert-ruta med meddelandet "Hello world...". Låt oss dissekera ovan kod, rad för rad och del för del, för att faktiskt förstå vad det är som händer.</p><h4>$() är syntaktiskt socker för jQuery()</h4><p>Först ut är detta mystiska dollartecken. Förklaringen till vad detta <em>är</em>, är egentligen ganska enkel. Förklaringen till varför vi <em>använder</em> tecknet inte lika. Men låt oss först diskutera vad det är. <code>$</code>-tecknet är egentligen ingenting annat än <a href="http://sv.wikipedia.org/wiki/Syntaktiskt_socker">syntaktiskt socker</a>. Alltså ett annat sätt att skriva någonting. Detta någonting är jQuery's huvudmetod med samma namn, alltså <code>jQuery</code>. Så, när vi med andra ord säger <code class="language-javascript">$(document)</code> är det <em>exakt samma sak</em> som när vi säger <code class="language-javascript">jQuery(document)</code>. Det förstnämnda är helt enkelt bara ett kortare sätt att uttrycka det på för att vi som programmerare ska slippa skriva så mycket.</p><h4>Variabeln document är dokumentets rot</h4><p><code>document</code> är helt enkelt en <em>variabel</em>. Men notera här alltså att vi säger att document är en variabel, vi säger inte att det är ett keyword. Varför är det viktigt att tänka på? Jo, <code>var</code> är ett keyword, en <a href="http://en.wikipedia.org/wiki/Language_construct">language construct</a> som alltid finns i JavaScript oavsett vart vi kör språket. Variabeln window är däremot ett koncept som är uppfunnit sonika för browsers. Om vi kör en JavaScript-interpretator i en <a href="http://en.wikipedia.org/wiki/Bash_(Unix_shell)">terminal</a> (alltså inte en browser) så existerar inte variabeln <code>document</code>. I browsern däremot, för att överhuvudtaget kunna manipulera en webbsida, behöver vi något sätt att genom javascript komma åt noderna (elementen) i vårt HTML-dokument. Således är <code>document</code>, löst uttryckt, vår "entry-point" in till noderna i html-dokumentet. I variabeln <code>document</code> hittar vi elementet <code>&lt;html&gt;</code> och som barn till det elementet hittar vi förstås resten av noderna. För att sammanfatta så är alltså <code>document</code> den variabel som innehåller hela vårt html-dokument och således den variabel vi behöver interagera med för att manipulera vårt dokument.</p><h4>$(document) eller jQuery(document)</h4><p>Nu vet vi alltså att <code>$()</code> är en korthandssyntax, och således samma sak som att anropa <code>jQuery()</code>. Men vad gör då denna metod? Jo, metoden returnerar ett jQuery-objekt som innehåller det vi har skickat in till den. Vi kan alltså se det som att jQuery <em>dekorerar</em> det vi har skickat in med alla dessa fantastiska jQuery-metoder. Låt oss exemplifiera.</p><pre><code class="language-javascript">// Dekorerar alla länkar med jquery
// Sparar referensen i variabeln link
var link = $('a');</code></pre><p>Vi använder alltså denna "jquery-dekorerade version" av ett html-element för att anropa de fantastiska metoder jquery utökar våra element med. Låt oss exemplifiera.</p><pre><code class="language-javascript">// Fade:a ut alla länkar
$('a').fadeOut();
 
// Samma sak i två steg
var link = $('a');
link.fadeOut();</code></pre><p>Det kan snabbt bli virrigt gällande vilka variabler som är jquery-dekorerade och vilka som inte är det. <a href="http://en.wikipedia.org/wiki/Coding_conventions">Konventionen</a> brukar således vara döpa sina variabler med ett initial <code>$</code>-tecken. Som så:</p><pre><code class="language-javascript">// Konventionen är att döpa jquery variabler med ett intialt $-tecken
var $link = $('a');</code></pre><p>För att återgå till det här med <code class="language-javascript">$(document)</code>. Vad betyder det då alltså att skicka in dokumentet till jquerys dekorationsmetod? Jo att vi nu kan anropa alla de fantastiska metoderna jquery erbjuder på vår rotnod. Det vill säga hela dokumentet. Att dekorera dokumentet med jquery har egentligen exakt samma effekt som att dekorera ett enskilt element (t.ex. en länk).</p><h4>För att veta när dokumentet är redo använder vi .ready()</h4><p>Precis som rubriken säger så använder vi metoden för att helt enkelt veta när dokumentet (DOM:en) är färdigladdat. Tänk efter. Eftersom vi använder jQuery-metoden för att dekorera element i vårt dokument. Så är det viktigt att alla element är "konstruerade" innan vi försöker komma åt dem. Hur ska vi kunna hitta alla länkar om vi inte är säker på att webbläsaren har hunnit läsa in alla länkar?</p><p>Vi kan använda <a href="http://learn.jquery.com/using-jquery-core/document-ready/">.ready()</a>-metoden, men vi kan också använda <a href="http://api.jquery.com/load/">.load()</a>-metoden. Den första nöjer sig med att <a href="http://sv.wikipedia.org/wiki/Document_Object_Model">DOM</a>:en (vilket kan ses som dokumentets struktur) har laddat. Den senare väntar på att alla resurser såsom bilder o.s.v. har laddat.</p><h4>Funktionen skickad till ready körs när dokumentet är redo</h4><p>Så vad ska vi skicka som argument till denna funktion? Jo, en till funktion! Va? Vääänta nu. En funktion som tar en funktion som argument? Det låter ju helknäppt. Men det är faktiskt inte så knäppt. Faktum är att mycket kod vi skriver i JavaScript går ut på att just skicka funktioner till funktioner. För att kunna skapa <a href="http://en.wikipedia.org/wiki/Callback_(computer_programming)">"callbacks"</a>. Den funktion vi skickar till <code>.ready()</code>-funktionen kan ses som ett callback som körs när dokumentet har laddat.</p><p>Tänk dig.. vi anropar jquery ready-metoden, och säger "Hej, nu vill jag att du säger till mig när sidans DOM har laddat klart". Sedan skickar vi in en funktion till ready-metoden och då är det som att vi säger "..och när sidans DOM har laddat klart, då vill jag att du utför allt som står i den här andra funktionen". Inga konstigheter!</p><h4>Allt i ett svep</h4><p>Så, låt oss repetera den kod vi pratar om i helhet.</p><pre class="line-numbers"><code class="language-javascript">$(document).ready(function(){
  alert("Hello world from jQuery");
});</code></pre><p>Låt oss beskriva koden i ord, rad för rad.</p><ol><li>Skapa ett <code>jQuery</code>-objekt av innehållet i variabeln <code>document</code>. Anropa sedan funktionen <code>ready()</code> på det jquery-dekorerade dokumentet. Skicka en <em>anonym funktion</em> som argument.</li><li>Låt den anonyma funktionen innehålla en enda rad. Denna rad anropar JavaScript-funktionen <code>alert()</code>, med strängen "Hello world.." som argument, och kommer således att visa göra så att alert-ruta "poppar upp" med texten "Hello world..".</li><li>Stäng den anonyma funktionen med <code>}</code>. Stäng sedan funktionsanropet med <code>)</code>. Terminera raden med <code>;</code>.</li></ol><div class="page-header"><h2 href="#06-03-jquery-jqueryobjects" name="06-03-jquery-jqueryobjects" id="06-03-jquery-jqueryobjects">Objektet jQuery</h2></div><p>I JavaScript-kapitlet använde vi rå JavaScript för att hämta och manipulera objekt i DOM:en. Vi har alltså direkt interagerat med DOM:ens API. Eftersom det lätt blir frustrerande att t.ex. skriva <code>document.getElementsByTagName</code> gång på gång så finns det ramverk som kan hjälpa oss. Därför ska vi nu istället göra detta med jQuery, och därför behöver vi prata om det mest grundläggande objektet i jQuery, själva jQuery-objektet. Således även reflektera över skillnaden mellan att arbeta med jQuery-objekt och <code>HTMLElement</code>-objekt.</p><h3>Varför?</h3><p>När vi hämtar element ifrån DOM:en m.h.a JavaScript får vi alltså tillbaka just DOM-element. Men när vi arbetar emot "råa" DOM-element blir många saker, som tidigare nämnt, ofta "tjatiga" och onödigt komplicerade. Beakta nedan exempel:</p><div class="panel panel-default"><div class="panel-heading">Hämta elementet <code>&lt;body&gt;</code></div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">Med JavaScript</div><div class="panel-body"><pre><code class="language-javascript">document.getElementsByTagName('body');</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('body')[0];</code></pre></div></div></div></div><p>Uppenbart kräver jQuery-exempelet ovan att vi skriver markant mindre kod. Onödigt, kanske du tänker nu. Visst, vinsten i ovan exempel är inte massiv. Men låt oss istället se till ett mer avancerat exempel. Anta att vi skulle vilja ta bort alla <code>&lt;p&gt;</code>-element ur ett dokument. Nedan ser du hur vi först skulle kunna lösa det med JavaScript och sedan med jQuery.</p><div class="panel panel-default"><div class="panel-heading">Ta bort alla <code>&lt;p&gt;</code>-element</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">Med JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var all = document.getElementsByTagName('p');
for(i=all.length-1; i>=0; i--){
  all[i].parentNode.removeChild(all[i]);
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('p').remove();</code></pre></div></div></div></div><p>Förhoppningsvis ser du nu styrkan! jQuery försökt att ta hand om den del vanligt återkommande problem och således försökt erbjuda oss utvecklare lite mindre huvudvärk. Nu kanske du redan fått huvudvärk flera gånger och känner den komma igen av att du behöver lära dig någonting nytt &mdash; men lugn! När du väl fått kläm på syntaxen kommer jQuery hjälpa dig ofantligt, och förhoppningsvis kommer du vara arg på att vi försökte lära dig JavaScript först.</p><blockquote>Förutom att jQuery gör det lättare för oss att utföra omständiga DOM-operationer gör den också att vi får mer webbläsarkompatibel kod, eftersom jQuery bygger på mycket "best practices".</blockquote><h3>Vad är det?</h3><p>jQuery-objektet fungerar helt enkelt så att vi "wrappar" (omsluter/dekorerar) ett helt vanligt <code>HTMLElement</code> med jQuery. När vi har gjort det har vi helt plötsligt ett objekt som dels innehåller en referens till detta helt vanliga <code>HTMLElement</code> men även en massa smidiga hjälpmetoder som hjälper oss att interagera med detta <code>HTMLElement</code>.</p><p>jQuery-objekt kan göra mycket fler saker än att hämta och manipulera element men nu ska vi fokusera på att det kan göra just det sistnämnda &mdash; alltså hämta element, och sedan manipulera dem. Låt oss se till det tidigare diskuterade exempelet som tog bort alla <code>&lt;p&gt;</code>-element ur ett dokument.</p><div class="panel panel-default"><div class="panel-heading">Ta bort alla &lt;p&gt;-element med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('p').remove();</code></pre></div></div><p>Det viktigaste vi måste förstå med ovan exempel, är att jQuery opererar på kollektioner av element och inte på enstaka element. Nu är det ju förstås så att det är fullt möjligt att vår kollektion endast innehåller ett element, men det är ändock en kollektion. För att dra en parallell så kan du tänka på hur JavaScript-metoden <code>document.getElementsByTagName()</code> fungerar. Namnet på metoden är pluraliserad eftersom även den returnerar en kollektion av <code>HTMLElement</code>. Detta alltså till skillnad ifrån <code>document.getElementById</code> som i alla fall returnerar max ett <code>HTMLElement</code>.</p><blockquote>jQuery opererar på kollektioner av element.</blockquote><p>Men vad betyder då detta i praktiken? Jo, det betyder alltså att jQuery inte bryr sig om huruvida vi hittade ett eller flera element, när vi i ovan exempel anropar metoden <code>.remove()</code> så tar den alltså bort alla element i hela den kollektion den hade hittat. Låt oss se till ytterligare ett exempel för att illustrera detta:</p><div class="panel panel-default"><div class="panel-heading">Tänk på att jQuery alltid arbetar på kollektioner av element</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt; hello &lt;/p&gt;
&lt;p&gt; world &lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">jQuery</div><div class="panel-body"><pre class="line-numbers"><code class="language-javascript">$('p')[0].innerHTML;    // => "hello"
$('p')[1].innerHTML;    // => "world"
$('p').text();          // => "hello world"</code></pre></div></div></div></div><p>Vi kan hantera jQuery-objektet som en array. På rad 1 och 2 i ovan exempel gör vi just det. När vi använder klammerparantesnotationen (<code>[i]</code>) och ger ett index, så hämtar vi alltså det <code>HTMLElement</code> som gömmer sig under det indexet. När vi sedan anropar <code>innerHTML</code> får vi ut den text som finns i just det <code>HTMLElementet</code>. När vi däremot på rad 3 anropar <code>text()</code>-metoden (som alltså är en jQuery-specifik metod) så opererar vi alltså på kollektionen av alla träffade element. Anledningen till att vi inte använder <code>text()</code>-metoden på rad 1 och 2 är alltså för att den metoden är specifik för jQuery. Eftersom vi på rad 1 och 2 redan plockat ut ett <code>HTMLElement</code> ur jQuery-objektet så har vi alltså inte längre tillgång till jQuery's metoder. Vice versa gäller alltså på rad 3. Eftersom vi inte plockat ut något <code>HTMLElement</code> ur jQuery-kollektionen kan vi inte använda "vanliga" <code>HTMLElement</code>-metoder (eftersom det är ett <code>jQuery object</code>) utan måste istället använda jQuery-specifika metoder. Vill vi använda de vanliga <code>HTMLElement</code>-metoderna behöver vi plocka ut ett specifikt element ur kollektionen.</p><h3>Hämta element</h3><p>Låt oss nu prata om vi hämtar element-kollektioner m.h.a. jQuery. Att hämta element med jQuery är egentligen mycket enkelt. Vi skriver helt enkelt <code>$(x)</code> där <code>x</code> ersätts med vilken css-selektor som helst. Med andra ord kan vi återanvända alla våra css-kunskaper nu när vi dyker in i jQuery.</p><p>Utan att snöa ner oss i svårare selektorer så kommer du förhoppningsvis ihåg de enklaste. De vanligaste css-selektorerna är:<dl class="dl-horizontal"><dt><code> x</code></dt><dd>Element av typ x</dd><dt><code>#x</code></dt><dd>Element med id x</dd><dt><code>.x</code></dt><dd>Element med klassen x</dd></dl></p><blockquote>Om du behöver läsa på om css-selektorer, läs mer i css-kapitlet!</blockquote><p>Ok, men nu var det ett väldigt generellt prat här. Låt oss istället se till några exempel där vi faktiskt använder dessa selektorer.</p><div class="panel panel-default"><div class="panel-heading">Hämta element av typ x</div><div class="panel-body"><pre><code class="language-markup">&lt;div&gt; Anta &lt;/div&gt;
&lt;div&gt; att vi har &lt;/div&gt;
&lt;div&gt; ett par div:ar &lt;/div&gt;</code></pre><pre><code class="language-javascript">// Då väljer vi alla så här:
var allaDivar = $('div');</code></pre></div></div><p>Ovan hämtade vi alltså element baserat på deras <code>tagName</code>. Låt oss nu istället hämta alla element, oavsett typ, som har en viss <code>class</code>.</p><div class="panel panel-default"><div class="panel-heading">Hämta element med klassnamn</div><div class="panel-body"><pre><code class="language-markup">&lt;div class="dog"&gt; Woof! &lt;/div&gt;
&lt;div class="cat"&gt; Mjau! &lt;/div&gt;
&lt;div class="dog"&gt; Bark! &lt;/div&gt;</code></pre><pre><code class="language-javascript"> // Använd klass-selektorn för att hämta alla element med en viss klass
 var dogs = $(".dog");
 
 // För att illustrara att det verkligen fungerar
 dogs.text();    // => "Woof! Bark!"</code></pre></div></div><p>Busenkelt! Du börjar se mönstret? Låt oss nu istället prova en sista gång genom att hämta alla element med ett visst <code>ID</code>.</p><div class="panel panel-default"><div class="panel-heading">Hämta element med ID</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="super-woman"&gt;Kryptonite!&lt;/p&gt;
&lt;p id="cat-woman"&gt;In your house eating your cat food!&lt;/p&gt;
&lt;p id="modesty-blaise"&gt;Secret agent&lt;/p&gt;</code></pre><pre><code class="language-javascript">// Vi använder css-selektorn för ID
var hero = $('#super-woman');
 
// Och har nu valt rätt element
hero.text();   // => "Kryptonite!"</code></pre></div></div><div class="page-header"><h2 href="#06-04-jquery-modify-elements" name="06-04-jquery-modify-elements" id="06-04-jquery-modify-elements">Modifiera element</h2></div><p>När vi väl lärt oss att välja element m.h.a. jQuery är det busenkelt att börja modifiera dessa. jQuery-objektet exponerar oss en mängd behändiga funktioner och egenskaper vi kan använda för att modifiera kollektionen av element som gömmer sig under objektet. I detta kapitel kommer vi att prata om några av de vanligaste.</p><h3>html()</h3><p>Metoden <code>html()</code> kan ses som jQuery's motsvarighet till JavaScript's <code>innerHTML</code>. Lagom straight forward så hämtar den eller sätter helt enkelt elements <code>innerHTML</code>.</p><h4>Exempel</h4><div class="panel panel-default"><div class="panel-heading">jQuery-metoden html()</div><div class="panel-body"><p>Om vi har följande html..<pre><code class="language-markup">&lt;p&gt;
  &lt;span&gt;En katt&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;satt i en hatt&lt;/p&gt;</code></pre></p><p>Kan vi läsa första paragrafen genom att säga...<pre><code class="language-javascript">$('p').html();         // => "&lt;span&gt;En katt&lt;/span&gt;"</code></pre></p><p>Men vi kan även modifiera den genom att säga...<pre><code class="language-javascript">$('p').html('En hund') // => Ändrar ALLA p-elements inre html till "En hund"</code></pre></p><p>Vilket förändrar vår html så att vi nu har...<pre><code class="language-markup">&lt;p&gt;En hund&lt;/p&gt;
&lt;p&gt;En hund&lt;/p&gt;</code></pre></p><p>Notera alltså att vi "blev av" med <code>&lt;span&gt;</code>-elementet. Samt att <b>båda</b> <code>&lt;p&gt;</code>-elementens inre html rensades.</p></div></div><p>Men vänta nu, vad hände nu? Om du var uppmärksam så märkte du att när vi använde metoden <code>html()</code> för att <b>läsa</b> ifrån en element-kollektion så fick vi endast värdet ifrån det första elementet i kollektionen. Men när vi däremot använda <code>html()</code>-funktionen för att <b>skriva</b> så opererade vi på alla element i objekt-kollektionen. Vad händer nu egentligen?</p><blockquote class="text-warning">Alla metoder på jQuery-objektet arbetar <u>inte alltid</u> på alla element i kollektionen.</blockquote><h3>Vilka metoder opererar över hela kollektionen?</h3><p>Oavsett vilket jQuery-metod vi använder är det alltså alltid viktigt att vara medveten om huruvida den arbetar på hela kollektionen eller ett specifikt element. En tumregel vi kan använda är att många av metoderna <b>läser ifrån det första</b> elementet i kollektionen och <b>skriver till alla</b> i kollektionen. Anropar vi alltså <code>html()</code> för att <b>läsa</b> kommer vi bara att få all inre html för det första elementet, medan om vi använder metoden till att skriva <code>html('something')</code> kommer vi förändra <code>innerHTML</code> för alla element i kollektionen.</p><blockquote class="info">En bra tumregel är att många jQuery-metoder läser ifrån första elementet i en objekt-kollektion, och skriver till alla.</blockquote><h3>text()</h3><p>Metoden <code>text()</code> påminner mycket om metoden <code>html()</code> förutom att den fantastiskt nog ger oss innehållet i det första elementet i en element-kollektion utan html. Vi får alltså allt som webbläsaren faktiskt uppfattat som text, utan all störande html. Detta är en mycket användbar metod! Vi kan förstås, precis som med metoden <code>html()</code> använda den för att även skriva text till alla element i en kollektion. Låt oss se till några exempel:</p><h4>Exempel</h4><div class="panel panel-default"><div class="panel-heading">jQuery-metoden html()</div><div class="panel-body"><p>Om vi har följande html..<pre><code class="language-markup">&lt;p&gt;
  En liten men 
  &lt;span&gt;mästerlig&lt;/span&gt;
  katt, satt en 
  &lt;span&gt;solig dag &lt;/span&gt;
  och beundrade en hatt.
&lt;/p&gt;</code></pre></p><p>Och sedan hämtar <code>&lt;p&gt;</code>-elementets text så här...<pre><code class="language-javascript">$('p').text();   // Hämtar all text i elementet fritt ifrån alla html-element</code></pre></p><p>Så får vi...<pre><code class="language-javascript">"En liten men mästerlig katt, satt en solig dag och beundrade en hatt."</code></pre></p><p>Vilket ju är fantastiskt, för om vi istället hade använt metoden <code>html()</code> eller JavaScript's egna <code>innerHTML</code> hade vi istället fått...<pre><code class="language-javascript">"En liten men &lt;span&gt;mästerlig&lt;/span&gt; katt, satt en &lt;span&gt;solig dag &lt;/span&gt; och beundrade en hatt."</code></pre></p><p>Vilket förstås skulle vara mycket jobbigt att arbeta med om det skulle vara så att vi faktiskt bara vill åt texten, oavsett dess inre elementstruktur.</p></div></div><h3>attr() &amp; prop()</h3><p>Låt oss nu prata om två metoder som till synes verkar likna varandra. Metoden <code>attr()</code> hämtar och sätter <code>attribut</code> (<code>attributes</code>), medan metoden <code>prop</code> hämtar och sätter <code>egenskaper</code> (<code>properties</code>). På samma sätt som <code>text()</code> och <code>html()</code> hämtar båda metoderna ifrån det första elementet, och skriver till alla i en kollektion. Men för att förstå skillnaderna mellan de två metoderna <code>attr()</code> och <code>prop()</code> behöver vi först förstå skillnaden mellan <code>attribut</code> och <code>egenskaper</code>.</p><h4>Attribut</h4><p>När vi pratar om attribut så pratar vi attribut på html-element. Exempel på attribut är alltså <code>id</code>, <code>class</code>, <code>name</code> och <code>name</code>, för att nämna några. Med andra ord, attribut är sådant som vi "tilldelar" ett element i vår html. Självklart kan vi både hämta och sätta attribut via JavaScript, men för att förstå skillnaden mellan attribut och egenskaper är det lättast att tänka på attribut som det som vi sätter i html. Nedan följer ett exempel på ett html-element med ett antal attribut.<div class="panel panel-default"><div class="panel-heading">Att läsa ett elements attribut</div><div class="panel-body"><p>Om vi har ett element med ett antal attribut...</p><pre><code class="language-markup">&lt;p class="quote" id="welcome"&gt;
  What a wonderful world
&lt;/p&gt;</code></pre><p>Så kan vi förstås läsa attributen med JavaScript som så...</p><pre><code class="language-javascript">document.getElementsByTagName('p')[0].getAttribute('class');
// => "quote"
 
document.getElementsByTagName('p')[0].getAttribute('id');
// => "welcome"</code></pre><p>Och förstås med jQuery som så...</p><pre><code class="language-javascript">$('p').attr('class');  // => "quote"
$('p').attr('id');     // => "welcome"</code></pre></div></div></p><h4>Egenskaper</h4><p>Egenskaper å andra sidan, refererar till egenskaper på ett <code>HTMLElement</code>-objekt när den hanteras i JavaScript. Med andra ord (löst uttryckt) publika instansvariabler på JavaScript-representationen av samma element. Vad skulle då egenskaper kunna vara för någonting?<div class="panel panel-default"><div class="panel-heading">Att läsa ett elements egenskaper</div><div class="panel-body"><p>Anta att vi har ett <code>&lt;p&gt;</code>-element på sidan..</p><pre><code class="language-javascript">var p = document.getElementsByTagName('p')[0];
var i = document.getElementsByTagName('input')[0];
 
p.tagName;  // => "P"
i.tagName;  // => "INPUT"</code></pre><p>Således kan vi förstås göra samma sak genom jQuery...</p><pre><code class="language-javascript">$('p').prop('tagName');       // => "P"
$('input').prop('tagName');   // => "INPUT"</code></pre></div></div></p><h4>Undantag</h4><p>Av historiska skäl och förändringar över tid så beteer sig ovan metoder, i tidigare versioner av jQuery, tyvärr inte alltid såsom man kan tänka sig. Du kan läsa mer om det i jQuery-dokumentationen för<a href="http://api.jquery.com/prop/">prop</a> eller<a href="http://api.jquery.com/attr/">attr</a> eller helt enkelt på följande tråd på <a href="http://stackoverflow.com/questions/5874652/prop-vs-attr">StackOverflow</a>.</p><div class="page-header"><h2 href="#06-05-jquery-event-listeners" name="06-05-jquery-event-listeners" id="06-05-jquery-event-listeners">Event listeners i jQuery</h2></div><p>En av styrkorna med jQuery är att vi kan binda event-lyssnare till flera element samtidigt. Jämför detta med att behöva iterera över en array med element, plocka ut ett för ett och applicera samma lyssnare. Markant enklare att göra det på alla samtidigt!</p><p>jQuery har några generella metoder för att applicera event-lyssnare (som med fördel kan jämföras med JavaScripts <code>addEventListener()</code>). Men jQuery har även några specifika för vanligt förekommande events som <code>click</code> och <code>hover</code>. Låt oss kolla på ett exempel, och kom ihåg att jQuery arbetar på kollektioner av element, alltså flera stycken samtidigt.</p><div class="panel panel-default"><div class="panel-heading">Exempel att applicera lyssnare på alla divar samtidigt</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;div&gt;Oh no no no...&lt;/div&gt;
&lt;div&gt;Please do not click me, oh no no, please...&lt;/div&gt;
&lt;div&gt;I don't want to fade, please...&lt;/div&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('div').click(function(){
  $(this).fadeOut();
});</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><style>.jquery-events-example-1{
  width:100%; min-height:50px; background:rgb(200,200,200); margin:6px;
  padding:10px; text-align:center; font-size:20px;
}</style><div class="jquery-events-example-1">Oh no no no...</div><div class="jquery-events-example-1">Please do not click me, oh no no, please...</div><div class="jquery-events-example-1">I don't want to fade, please...</div><script>$('.jquery-events-example-1').click(function(){
  $(this).fadeOut();
});</script></div></div></div></div><p>Om du försöker bygga ovan exempel med ren JavaScript kommer du snabbt märka varför det gör livet så hiskelens mycket enklare att arbeta med ett JavaScript-bibliotek såsom jQuery.</p><h3>Vem avfyrade ett event?</h3><p>Som du kanske märkte i senaste exemplet, så använde vi oss av följande syntax: <code>$(this)</code>. Mystiskt kan tyckas, men mycket smidigt faktiskt. När vi kör jQuery-funktionen (<code>$()</code>) och ger den en css-selektor så kommer jQuery att välja alla element som matchar den selektorn. Men vi kan faktiskt också ge jQuery-metoden ett annat <code>HTMLElement</code>. T.ex. så här:</p><div class="panel panel-default"><div class="panel-heading">Wrappa ett HTMLElement i jQuery</div><div class="panel-body"><pre><code class="language-javascript">// First grab the first &lt;p&gt;-element using regular JavaScript
var paragraph = document.getElementsByTagName('p')[0];
 
// Then wrap it as a jQuery object
var $paragraph = $(paragrah);
 
// And now we can do all the regular cool jQuery stuff
$paragraph.fadeOut();</code></pre></div></div><p>Men vänta nu, i det tidigare diskuterade exemplet så skickade vi ju faktiskt inte ett html-element, utan vi skickade nyckelordet <code>this</code>. Löst uttryckt så refererar nyckelordet <code>this</code> i JavaScript alltid till den nuvarande kontexten. Det intressanta är alltså att om vi skickar den nuvarande kontexten till jQuery-metoden så kommer den försöka skapa ett jQuery-objekt av det. Om vi då befinner oss i en <code>event handler</code> (t.ex. den kod som exekveras när en knapp klickas på) så kommer det element som avfyrade elementet bli det objekt som hamnar i jQuery-objektet. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Att identifiera den som avfyrade ett event med jQuery</div><div class="panel-body"><p>Om vi har följande html...<pre><code class="language-markup">&lt;p&gt;Hello world&lt;/p&gt;</code></pre></p><p>Kan vi göra följande i jQuery...<pre><code class="language-javascript">// First define a click function, that we want to
// execute whenever something is clicked.
var onClick = function(){
  var sender = $(this);  // Creates a jQuery object of the element that was clicked
  alert(sender.text());  // Sends a message with the contents of the clicked element
}
 
// Then we need to attach our click function to the &lt;p&gt;-element,
// so that it will be fired when the element is clicked.
$('p').click(onClick);</code></pre></p><p>Detta kommer nu alltså att ge oss följande...</p><div class="panel panel-default"><div class="panel-heading">Resultat (testa att klicka på paragrafen)</div><div class="panel-body"><p class="jquery-events-example-2">Hello world</p><script>$('p.jquery-events-example-2').click(function(){
  alert($(this).text());
});</script></div></div></div></div><p>Detta går självklart även att göra med helt vanlig JavaScript, såsom du förhoppningsvis kommer ihåg ifrån JavaScript-kapitlet. Att det är enklare att göra i jQuery är ju förstås ett plus! Men det viktiga att komma ihåg är här alltså att detta gör det möjligt för oss att skriva mycket mer generella <code>event handlers</code> (alltså metoden som körs när ett event avfyras). Om vi t.ex. har tre knappar som alla gör väldigt liknande saker, så finns det alltså ingen anledning att binda separata event-hanterare (<code>event handler</code>) för varje knapp. Istället generaliserar vi koden i event-hanteraren och binder alla events till samma hanterare. Sött som sylt!</p><h1 href="#07-00-versioning-intro" name="07-00-versioning-intro" id="07-00-versioning-intro">Versionshantering (kommer snart)</h1><p class="lead">Kommer snart...</p><div class="page-header"><h2 href="#07-01-versioning-whatis" name="07-01-versioning-whatis" id="07-01-versioning-whatis">Vad är versionshantering?</h2></div><p>Kommer snart...</p><div class="page-header"><h2 href="#07-02-versioning-install" name="07-02-versioning-install" id="07-02-versioning-install">Komma igång</h2></div><p>Kommer snart...</p><div class="page-header"><h2 href="#07-03-versioning-staging-and-commiting" name="07-03-versioning-staging-and-commiting" id="07-03-versioning-staging-and-commiting">Staging &amp; commiting</h2></div><p>Kommer snart...</p><div class="page-header"><h2 href="#07-04-versioning-branching" name="07-04-versioning-branching" id="07-04-versioning-branching">Branching</h2></div><p>Kommer snart...</p><div class="page-header"><h2 href="#07-04-versioning-rolling-back" name="07-04-versioning-rolling-back" id="07-04-versioning-rolling-back">Rulla tillbaka</h2></div><p>Kommer snart...</p><h1 href="#08-00-php-intro" name="08-00-php-intro" id="08-00-php-intro">PHP och andra server-side-språk (kommer snart)</h1><p>Kommer snart...</p><h2 href="#08-01-php-server-side-languages" name="08-01-php-server-side-languages" id="08-01-php-server-side-languages">Vad är server-side-språk?</h2><p>Kommer snart...</p><h2 href="#08-02-php-installation" name="08-02-php-installation" id="08-02-php-installation">Komma igång</h2><p>Kommer snart...</p><h2 href="#08-03-php-syntax" name="08-03-php-syntax" id="08-03-php-syntax">PHP Syntax</h2><p>Kommer snart...</p><h2 href="#08-04-php-organizing-code" name="08-04-php-organizing-code" id="08-04-php-organizing-code">Kodorganisation</h2><p>Kommer snart...</p><h2 href="#08-05-php-data-forms" name="08-05-php-data-forms" id="08-05-php-data-forms">Skicka data till servern</h2><p>Kommer snart...</p><h2 href="#08-06-php-oop" name="08-06-php-oop" id="08-06-php-oop">Objektorienterad PHP</h2><p>Kommer snart...</p><h2 href="#08-07-php-debugging" name="08-07-php-debugging" id="08-07-php-debugging">Felsökningstekniker</h2><p>Kommer snart...</p><h1 href="#30-00-efterord-intro" name="30-00-efterord-intro" id="30-00-efterord-intro">Epilog</h1><div class="page-header"><h2 href="#30-01-efterord-intro" name="30-01-efterord-intro" id="30-01-efterord-intro">Efterord</h2></div><p>HTML-hunden är skriven av <span class="authors"><em class="author">Christopher Okhravi</em> (<a href="http://twitter.com/chrokh" target="_blank">@chrokh</a>) och <em>Madelen Hermelin</em>. Guiden är skriven för att användas under kurser vid <a href="http://www.im.uu.se/" target="_blank">Institutionen för informatik och media</a> under <a href="http://www.uu.se" target="_blank">Uppsala universitet</a> men du är förstås välkommen att använda den vemän du är :) </span></p><p>Projektet har <a href="http://sv.wikipedia.org/wiki/%C3%96ppen_k%C3%A4llkod" target="_blank">öppen källkod</a>, och om du således är intresserad av att bidra på något sätt så välkomnar vi alla tankar, idéer och korrigeringar. Projektet tillsammans med dokumentation finns på <a href="https://github.com/chrokh/htmlhunden" target="_blank">GitHub</a>.</p></div><script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.0.3/js/bootstrap.min.js"></script><script src="/dist/assets/javascripts/jquery.fittext.js"></script><script src="/dist/assets/javascripts/prism.js"></script><script src="/dist/assets/javascripts/main.js"></script></body></html>