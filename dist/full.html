<!DOCTYPE html utf-8><html lang="sv"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HTMLHunden | En pragmatisk höghastighetsguide till webbutveckling, använd vid Uppsala Universitet</title><link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css" rel="stylesheet"/><link href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css" rel="stylesheet"/><link href="assets/stylesheets/main.css" rel="stylesheet"/><link href="assets/stylesheets/prism.css" rel="stylesheet"/><link href="http://fonts.googleapis.com/css?family=Lily+Script+One" rel="stylesheet"/><!-- Feedback tab--><style>@import url("http://getbarometer.s3.amazonaws.com/assets/barometer/css/barometer.css");</style><script src="http://getbarometer.s3.amazonaws.com/assets/barometer/javascripts/barometer.js" type="text/javascript"></script><script type="text/javascript" charset="utf-8">BAROMETER.load('zFXKA2467y8YdpZaQK3gq');</script><script>if(document.location.hostname.search("localhost") === -1 && document.location.origin !== "file://"){
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45465391-1', 'htmlhunden.se');
  ga('send', 'pageview');
}</script></head><body></body></html><div id="toc-single" class="toc"><a id="toggle-toc" class="btn btn-sm btn-default">TOC</a><hr/><ul><li class="toc-h1"><br/><a href="01-00-intro-intro.html">intro</a></li><ul><li class="toc-h2">........ <a href="01-01-intro-intro.html">intro</a></li><li class="toc-h2">........ <a href="01-02-intro-forord.html">forord</a></li><li class="toc-h2">........ <a href="01-03-intro-arkitektur.html">arkitektur</a></li></ul><li class="toc-h1"><br/><a href="02-00-html-intro.html">html</a></li><ul><li class="toc-h2">........ <a href="02-01-html-element.html">element</a></li><li class="toc-h2">........ <a href="02-02-html-kommentarer.html">kommentarer</a></li><li class="toc-h2">........ <a href="02-03-html-struktur.html">struktur</a></li><li class="toc-h2">........ <a href="02-04-html-indentering.html">indentering</a></li><li class="toc-h2">........ <a href="02-05-html-head-och-body.html">head</a></li><li class="toc-h2">........ <a href="02-06-html-lankar.html">lankar</a></li><li class="toc-h2">........ <a href="02-07-html-lists.html">lists</a></li><li class="toc-h2">........ <a href="02-08-html-tables.html">tables</a></li><li class="toc-h2">........ <a href="02-09-html-formular.html">formular</a></li><li class="toc-h2">........ <a href="02-10-html-doctypes.html">doctypes</a></li><li class="toc-h2">........ <a href="02-11-html-encodings.html">encodings</a></li><li class="toc-h2">........ <a href="02-12-html-bilder.html">bilder</a></li></ul><li class="toc-h1"><br/><a href="03-00-css-intro.html">css</a></li><ul><li class="toc-h2">........ <a href="03-01-css-intro.html">intro</a></li><li class="toc-h2">........ <a href="03-02-css-selectorer.html">selectorer</a></li><li class="toc-h2">........ <a href="03-03-css-syntax-och-struktur.html">syntax</a></li><li class="toc-h2">........ <a href="03-04-css-placering.html">placering</a></li><li class="toc-h2">........ <a href="03-05-css-cascade.html">cascade</a></li><li class="toc-h2">........ <a href="03-06-css-boxmodell.html">boxmodell</a></li><li class="toc-h2">........ <a href="03-07-css-positionering.html">positionering</a></li></ul><li class="toc-h1"><br/><a href="04-00-js-intro.html">js</a></li><ul><li class="toc-h2">........ <a href="04-01-js-intro.html">intro</a></li><li class="toc-h2">........ <a href="04-02-js-placering.html">placering</a></li><li class="toc-h2">........ <a href="04-03-js-variabler.html">variabler</a></li><li class="toc-h2">........ <a href="04-04-js-funktioner.html">funktioner</a></li><li class="toc-h2">........ <a href="04-05-js-dom.html">dom</a></li><li class="toc-h2">........ <a href="04-05-js-events.html">events</a></li><li class="toc-h2">........ <a href="04-05-js-objekt.html">objekt</a></li></ul><li class="toc-h1"><br/><a href="05-00-oss-intro.html">oss</a></li><ul><li class="toc-h2">........ <a href="05-01-oss-intro.html">intro</a></li></ul><li class="toc-h1"><br/><a href="06-00-jquery-intro.html">jquery</a></li><ul><li class="toc-h2">........ <a href="06-01-jquery-intro.html">intro</a></li><li class="toc-h2">........ <a href="06-02-jquery-documentready.html">documentready</a></li><li class="toc-h2">........ <a href="06-03-jquery-jqueryobjects.html">jqueryobjects</a></li><li class="toc-h2">........ <a href="06-04-jquery-modify-elements.html">modify</a></li><li class="toc-h2">........ <a href="06-05-jquery-event-listeners.html">event</a></li></ul><li class="toc-h1"><br/><a href="07-00-efterord-intro.html">efterord</a></li><ul><li class="toc-h2">........ <a href="07-01-efterord-intro.html">intro</a></li></ul></ul></div><div class="container single">h1 Introduktion<p class="lead">Välkommen till HTMLHunden! En pragmatisk höghastighetsguide som inte bara lär dig att bygga webbsidor ifrån den absoluta grunden utan även hela tiden ser till att förklara varför vi gör såsom vi gör. HTMLHundens filosofi är inte att lära dig allt &mdash; utan att lära dig tillräckligt mycket för att du ska kunna lära dig själv! Det tror vi är det snabbaste sättet. Så på med rakethatten så kör vi!</p><div class="page-header"><h2><a name="start">Så kommer du igång!</a></h2></div><p>Skapa ett tomt textdokument och välj "spara som". Döp filen till index.html och spara. För att kolla på denna fil med webbläsaren
så dubbelklickar man endast på filen. Vill man editera den så kan man exempelvis använda notepad, för att göra detta väljer "öppna med"
Om man dubbelklickar på filen kommer endast en tom sida komma upp. detta är för att vi inte skapat något på sidan. </p><h3>Grundstruktur</h3><p>Varje html-dokument består av taggar som i sin strukur är uppbyggt som ett träd. Det betyder att taggarna kommer parvis.</p><div class="panel panel-default"><div class="panel-heading">Exempel på HTML-taggar</div><div class="panel-body"><pre><code class="language-markup">&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>som ni ser så startar vi med html-tagg som omsluter head och body. I headern läggs ofta metainformation om sidan eller kan 
innehålla stilar eller script.
Inannför body så skrivs sådant som skall synas på din sida, alltså de element som byggar upp din sida.</p><h3>Video-introduktion</h3><p>Innan vi verkligen ger oss på hur man använder HTML, CSS och JavaScript så kan det vara skönt att få en snabb introduktion till hur allt hänger samman.</p><p>Om du håller med om ovanstående påstående så kan det hända att nedanstående film är någonting för dig. På ca. 25 minuter går videon snabbt igenom de grundläggande koncepten kring HTML, CSS, JavaScript, och hur de hänger ihop.</p><div class="panel panel-default"><div class="panel-heading">Introduktionsvideo om html, css och javascript</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/wrdR5Su_Stg?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><div class="page-header"><h2><a name="frord">Om denna guide</a></h2></div><p>Den här guiden är till för dig. Just ja. Precis just dig. Inte någon hypotetisk student någonstans. Den är inte heller mer till för dina kompisar än för dig. Eller mer till för de som du tycker kan så himla mycket mer än vad du kan. Den här guiden är till för vemsomhelst som vill lära sig att skapa webbsidor. Så oavsett om du vill lära dig ifrån grunden, eller vill förbättra dina redan existerande kunskaper, så är den här guiden till för just dig.</p><h3>Feedback</h3><p>Om du har något du vill berätta, så tryck gärna på feedback-knappen till höger. Eftersom det är du som ska läsa den här guiden så är din åsikt superviktig för oss. Om du tycker att någonting är konstigt, bra, dåligt, kunde bli bättre, fel, eller rent utsagt helt uppåt väggarna så vill vi gärna ha in din åsikt.</p><p>Om du redan är webbutvecklare, så lyssnar vi även gärna på dig! Vi är medvetna om att denna guide är högst opinionerad, och således partisk. Om du står för andra åsikter än dem som presenteras här så skulle vi fantastiskt gärna vilja höra dina åsikter. Allt för att bli bättre.</p><h3>Ett levande dokument</h3><p>Det är viktigt att förstå att det här är ett levande dokument. Vi skriver om, skriver nytt, och skriver om konstant. Såldes kan det hända att delar av denna guide känns inkompletta. Detta är för att de med stor sannolikhet är just det &mdash; inkompletta. Se det som en chans att vara med att påverka vad som ska stå i denna guide!</p><h3>Videomaterial</h3><p>Vi jobbar även på att skapa videos för stora delar av det här materialet. Det finns en del video nu, vilket du hittar inbäddat i löptexten. Om du är intresserad av att se alla videoklippen i ordning utan att leta omkring här så hänvisar vi dig vänligast till vår <a href="http://www.youtube.com/watch?v=wrdR5Su_Stg&list=PLrhzvIcii6GOVLttYLcxO-92GxuPPwbul">playlist på YouTube</a>.</p><h3>Författare</h3><p>Den här guiden är framtagen av <a href="http://katalog.uu.se/empInfo/?id=N12-1461">Christopher Okhravi</a> (<a href="http://twitter.com/chrokh">@chrokh</a>) (Universitetsadjunkt, Uppsala Universitet) och <a href="http://katalog.uu.se/empInfo/?id=N10-407">Madelen Hermelin</a> (Forskningsassistent, Uppsala Universitet). Detta är ett dokument som delvis används vid undervisning under <a href="http://www.im.uu.se/">Institutionen för Informatik och Media</a> vid <a href="http://www.uu.se/en">Uppsala Universitet</a>. Ändock bör detta dokument inte ses som ett uttryck för åsikter ifrån Uppsala Universitet.</p><div class="page-header"><h2><a name="arkitektur">Hur fungerar en webbsida?</a></h2></div><p>Hur fungerar egentligen en hemsida? Vad händer egentligen när vi öppnar webbläsaren och skriver in en adress? Det här kapitlet ger dig en kort och mycket övgripande introduktion om hur allting hänger ihop.</p><h3>HTML</h3><p>HTML (<a href="http://sv.wikipedia.org/wiki/HTML" target="_blank">Hypertext markup language</a>) är  ett <a href="http://sv.wikipedia.org/wiki/M%C3%A4rkspr%C3%A5k" target="_blank">märkespråk</a> vi använder för att konstruera webbsidor. Kort sagt kan vi se det som att språket HTML är ett sätt att semanstiskt strukturera ett dokuments information.</p><p>HTML skriver vi med hjälp av taggar. Nedan kan du se ett enkelt exempel på hur HTML fungerar.<pre><code class="language-markup">Sista ordet kommer bli &lt;b&gt;fetstilat&lt;/b&gt;.</code></pre><div class="panel panel-default"><div class="panel-body">Sista ordet kommer bli <b>fetstilat</b></div></div></p><h4>Endast för statiska sidor</h4><p>HTML är alltså ett statiskt språk. Men vad menar vi då med statiskt och vad skulle motsatsen innebära?</p><p>Med statiskt menar att om vi renderar ett HTML-dokument i en webbläsare, stänger webbläsaren, öppnar den igen och renderar samma sida igen &mdash; så kommer sidan se exakt likadan ut som första gången. HTML ger oss alltså inga möjligheter att t.ex. koppla till databaser, hämta information ifrån andra sidor (bortsett ifrån användandet av <a href="http://sv.wikipedia.org/wiki/IFRAME" target="_blank">iframe</a>'s som skulle kunna bädda in en annan sida som utför logik), räkna ut matematik eller utföra någon form av logik.</p><p>Som en tankelek. Föreställ dig ett dokument skrivet i Microsoft Word, Pages, Open Office eller dylik dokumenthanterare. Tänk nu på att vi har rubriker,  underrubriker, stycken, text-snuttar som är <b>fetstilta</b> och <i>kursiva</i>. Ett HTML-dokument är egentligen exakt samma dokument som i denna tankelek fast varje gång vi vill att någonting ska representeras som någonting annat än text rakt upp och ned på samma rad så måste vi använda oss av <em>taggar</em> och <em>element</em>.</p><p>Således kan vi se våra HTML-dokument som motsvarigheten till en <code>.doc</code>-fil, och våra webbläsare som <em>Open Office</em>. Med andra ord, HTML-filer är rakt upp och ned textfiler med inblandad <em>markup</em>, och webbläsare är tolkare av detta markupspråk.</p><p>Låt oss fundera lite på hur ovan beskriven process fungerar.</p><div class="panel panel-default"><div class="panel-heading">Processen av en webbläsare (klient) som renderar en HTML-fil</div><div class="panel-body"><pre> FIL          PROGRAM              RESULTAT
=================================================
.html   =>   webbläsare   =>   Renderad webbsida!</pre></div></div><h3>Client-server architecture</h3><p>Innan vi kan gå djupare in på varför vi inte kan utföra komplex logik i html så behöver vi lära oss lite om ansvarsområden för <a href="http://sv.wikipedia.org/wiki/Klient%E2%80%93server" target="_blank">klienter och servrar</a>.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en server konstruerar en fil, som den sedan skickar till klienten</div><div class="panel-body"><pre> SERVER            =>    FIL       =>         CLIENT
 genererar en...        .html           ..som tar emot den </pre></div></div><blockquote>En server <em>servererar</em> filer till en klient. </blockquote><p>Låt oss formulera det med andra ord. En server servererar filer till en klient. Men vad är då en server egentligen? När vi tänker på serverhallar så är det lätt att tänka sig stora mörka haller med dundrande monster till maskiner. Så må fallet vara ibland &mdash; men inte alltid. En server kan likväl vara din egen dator. När själva vi utvecklar dynamiska webbsidor kan det mycket väl hända att vi både kör en server och en klient på vår dator.</p><h4>Request-response</h4><p>Som sagt, så är en servers uppgift att servera ett <code>response</code> vid en förfrågan, alltså ett <code>request</code>. Låt oss se till det lite närmare. Vi har alltså (1) en server (t.ex. någon ananstans), (2) en klient (t.ex. vår egen dator) och (3) internet. Hur hänger då allt det här ihop?</p><div class="panel panel-default"><div class="panel-heading">Request/response för en webbsida över internet</div><div class="panel-body"><pre>      CLIENT              INTERNET             WEBSERVER
 
 skickar request   -->  över internet  -->   som behandlas     (REQUEST)
 
 som kan renderas  <--  över internet  <--   skickar response  (RESPONSE)</pre></div></div><p>Ovan figur är alltså en visualisering av hur ett request-response-scenario skulle kunna spela ut sig, när en klient ber om en webbsida. Och i essens är det ungefär det här som händer <em>varje gång</em> vi öppnar vår webbläsare och skriver in en adress såsom <em>www.google.com</em>.</p><h3>Server-side-språk</h3><p>Så, vad är då egentligen ett server-side-språk? Tänk så här. Vi skulle kunna ha en klient-server-arkitektur helt utan ett server-side-språk. Hur? Jo, klienten ber om en sida genom ett request som vandrar över internet och når rätt server som rakt av svarar med ett response som är en html-sida.</p><p>Men nu är det ju så att det moderna internet består av mycket mer komplexitet än statiska sidor. Den enda skillnaden vi introducerar i ovanstående process handlar då om att vi introducerar ett språk som ansvarar för att konstruera html-sidor beroende på response.</p><p>Vi omformulerar ovan paragraf. Ett server-side-språks huvudsakliga uppgift är alltså att "hitta på" ett html-dokument. Ett statiskt response skulle vara att bara svara med en existerande html-fil. Men ett dynamiskt response skulle innebära att server-side-språket först utför en del logik, och sen "on the fly" skapar den html-fil som servern svarar med.</p><p>Exempel på server-side-språk är t.ex. PHP, Ruby, Python, ASP.NET etc.</p><blockquote>Eftersom datorer är korkade, måste vi berätta exakt vad vi vill ha</blockquote><p>Så om server-side-språket "genererar" HTML-filer &mdash; varför måste vi då lära oss att skriva det själva? Enkelt svarat &mdash; eftersom det är vi som skriver server-side-koden, och därmed även vi som definierar hur HTML-sidorna ska genereras. Det finns alltså inte någon magisk HTML-generator utan någonstans måste vi definera exakt hur HTML-sidorna ska genereras beroende på de request vi får in. Vi återkommer alltså till den gamla tanken mdash; eftersom datorer är korkade, så måste vi berätta för dem exakt vad vi vill ha.</p><h1>Hypertext Markup Language</h1><p class="lead">Navet i det stora webbhjulet skulle vi nog kunna hävda är just HTML. Detta markup-language har hängt med länge och är just det språk vi använder för att strukturera upp information på ett sätt som en webbläsare förstår. Detta kapitel kommer lära dig hur HTML fungerar och hur vi skriver det.</p><div class="page-header"><h2><a href="#element" name="element"><div class="icon-link"></div>Element</a></h2></div><p>HTML-dokument bygger vi upp genom att huvudsakligen använda oss av <em>element</em> och <em>attribut</em>.</p><h3>Element</h3><p>Element skapar vi genom att använda oss av <code>&lt;</code>, och <code>&gt;</code>-tecken.</p><h4>Element med start- och slut-taggar</h4><p>De flesta tags har en start och en slut-tagg. Exempel på en sådan tagg är <code>&lt;p&gt;paragraf-taggen&lt;/p&gt;</code>.</p><p>Med paragraf-taggen definierar vi att allting emellan <code>&lt;p&gt;</code>och <code>&lt;/p&gt;</code>tillhör en paragraf. Tänk dig att du skriver ett dokument i en textbehandlare. När du trycker ENTER skapas en ny paragraf på en ny rad och exakt samma effekt når du genom att stänga en befintlig paragraf och öppna en ny.</p><p>För att fortsätta ovan analogi, med ett klarare exempel. Tänk dig att du markerar ett stycke text och klickar på bold. Texten blir fetstilt. Detta uppnår vi i HTML såsom nedan:</p><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi markerar text i fetstil</div><div class="panel-body"><pre><code class="language-markup">Ett av orden ska vara i<br>
&lt;b&gt;fetstil&lt;/b&gt;, men inte resten.</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">Ett av orden ska vara i <b>fetstil</b>, men inte resten</div></div></div></div><p>Låt oss återgå till paragraf-taggen igen.</p><div class="panel panel-default"><div class="panel-heading">Exempel på separata styckesindelning i paragrafer.</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;Första paragrafen&lt;/p&gt;
&lt;p&gt;Andra paragrafen&lt;/p&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Första paragrafen</p><p>Andra paragrafen</p></div></div></div></div><p>Tänk på radavståndet som uppstår eftersom vi använder två paragraf-taggar. Jämför med nedan exempel.</p><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt; Radbrytningar<br>
  inom<br>
  en<br>
  p-tagg har ingen effekt.
&lt;/p&gt;<br></code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Radbrytningar
inom
en p-tagg har ingen effekt.</p></div></div></div></div><h4>Element utan slut-taggar</h4><p>Vissa element har bara en början och inget slut. Ett bra exempel på ett sådant element är <code>&lt;hr&gt;</code> (horizontal ruler). Ett horisontellt streck rakt över sidan.</p><p>Ett koncept som ett streck innefattar ingen idé om innehåll. Visst ett streck har en start och en början men försök att föreställa dig start- och slut-taggar som att de innehåller, eller enkapsulerar någonting annat.  Generellt betyder det att:</p><blockquote><p>Ett element kan antingen innehålla ett annat element eller helt vanlig text.</p></blockquote><div class="panel panel-default"><div class="panel-heading">Exempel på <code>&lt;hr&gt;</code></div><div class="panel-body"><hr/></div></div><h4>Attribut</h4><p>Ett elements öppnande tag kan även innehålla attribut med värden. Exempel på ett attribut är <code>href</code>, som används för att berätta var en hyperlänksresurs befinner sig någonstans. </p><p>För att skapa länkar använder vi elementet <code>&lt;a&gt;</code>och för att berätta att det ska länka någonstans, använder vi attributet <code>href</code>, och för att berätta vart länken ska gå ger vi attributet ett värde. Så för att skapa en länk skriver vi alltså:</p><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;a href="http://uu.se"&gt;Klicka på mig&lt;/a&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><a href="http://www.uu.se">Klicka på mig</a></div></div></div></div><blockquote><p>Alla attribut är<i> inte </i>möjliga att använda på alla element, men många återkommer, såsom t.ex. <code>title</code>, <code>href</code>och <code>src</code></p></blockquote><div class="page-header"><h2><a href="#kommentarer" name="kommentarer"><div class="icon-link"></div>Kommentarer</a></h2></div><p>All text vi skriver i ett HTML-dokument har således effekt på det renderade resultatet -- alltså webbsidan som visas i webbläsaren. Men hur skriver vi kommentarer till oss själva i HTML-dokument?</p><p>Kommentarer kan vi skriva i HTML-dokument av olika anledningar men t.ex. skulle vi kunna använda de till att skriva förklarande kommentarer, för att logiskt gruppera olika delar av HTML-dokumentet (för utvecklaren), eller kanske för att skriva en TODO-notis om någonting som måste bättras på senare.</p><!-- comment YOYO--><div class="panel panel-default"><div class="panel-heading">Exempel på en kommentar</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;En valig paragraf som syns&lt;/p&gt;
&lt;!-- Det här är kommentar som alltså inte kommer synas --&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>En vanlig paragraf som syns</p></div></div><div class="page-header"><h2><a href="#struktur" name="struktur"><div class="icon-link"></div>Dokumenstruktur</a></h2></div><p>Genom att bygga upp ett dokument m.h.a. element skapar vi vad som brukar kallas en DOM (Document Object Model). För att en webbläsare ska förstå din sida kan denna DOM då dock inte se ut hursomhelst.</p><h3>Dokument-struktur</h3><p>Följande kod är ett exempel på det enklaste html-dokumentet vi kan skriva utan att bryta emot några regler (i standarden för html 5).</p><div class="panel panel-default"><div class="panel-heading">Ett enkelt html-dokument</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Min hemsida &lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h4>HTML-dokument kan ses som trädstrukturer</h4><p>DOM:en kan alltså ses som en trädstruktur.</p><div class="row"><div class="col-md-6"><p>Vi skulle kunna visualisera den som lådor i varandra.</p><pre> ---------------------------
|         DOCTYPE          |
 ---------------------------
 ---------------------------
|           html            |
|   ---------------------   |
|  |        head         |  |
|  |   ---------------   |  |
|  |  |     title     |  |  |
|  |   ---------------   |  |
|   ---------------------   |
|   ---------------------   |
|  |        body         |  |
|   ---------------------   |
 ---------------------------</pre></div><div class="col-md-6"><p>Eller som en indenterad lista.</p><pre>DOCTYPE
html
  head
    title
  body</pre><p>Detta med indentering leder oss även in på en meningsfull vana html-utvecklare respekterar.</p><blockquote><p>Om en tag är ett barn till tag:en ovan, indentera ett steg.</p></blockquote><p>Notera alltså hur <code>title</code> är indenterad i relation till <code>head</code>, men hur <code>body</code><i>inte </i>är indenterad i relation till <code>head.</code></p></div></div><h4>Välformatterade trädstrukturer</h4><p>Eftersom vi jobbar med trädstrukturer gäller det att alla barn-taggar avslutas innan vi avslutar den omslutande föräldern.</p><div class="row"><div class="col-md-6"><div class="panel panel-danger"><div class="panel-heading">Oavstlutade barn-taggar</div><div class="panel-body"><pre>&lt;p&gt;<br/>  &lt;span&gt;Vilken huvudvärk!<br/>  &lt;/p&gt;<br/>&lt;/span&gt;</pre></div></div></div><div class="col-md-6"><blockquote><p>Ett sätt att ta reda på ifall ett dokument är "dåligt" indenterat är att försöka rita en sådan lista som ritats ovan under "indenterad lista". Är det svårt att veta hur man ska rita den listan så betyder det antagligen att indenteringen är felaktig.</p></blockquote></div></div><div class="page-header"><h2><a href="#indentering" name="indentering"><div class="icon-link"></div>Indentering</a></h2></div><p>Några fler exempel på indentering.</p><div class="panel panel-success"><div class="panel-heading">Korrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;
  &lt;span&gt;Detta är ok!&lt;/span&gt;
&lt;/p&gt;</code></pre></div></div><div class="panel panel-success"><div class="panel-heading">Korrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;
  &lt;span&gt;
    Också ok!
  &lt;/span&gt;
&lt;/p&gt;</code></pre></div></div><div class="panel panel-success"><div class="panel-heading">Korrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;&lt;span&gt;Också ok men svårläsligt!&lt;/span&gt;&lt;/p&gt;</code></pre></div></div><div class="panel panel-danger"><div class="panel-heading">Inkorrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;
&lt;span&gt;Strunta _inte_ i indenteringen!&lt;/span&gt;
&lt;/p&gt;</code></pre></div></div><div class="panel panel-danger"><div class="panel-heading">Inkorrekt indentering</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;
  Indentera barn...
&lt;/p&gt;
  &lt;p&gt;
    ...men inte syskon!
  &lt;/p&gt;</code></pre></div></div><blockquote>HTML är förlåtande, men bara för att någonting <em>går</em> att göra behöver det inte betyda att det är <em>bra</em>.</blockquote><div class="page-header"><h2><a href="#head-och-body" name="head-och-body"><div class="icon-link"></div>HEAD &amp; BODY</a></h2></div><p>Ett validerande HTML-dokument måste alltså innehålla ett par saker. En dokumenttypsdeklaration, ett huvud, en titel och en kropp.</p><p>Nyssnämnt är alltså fånigt direktöversatta begrepp av begreppen DOCTYPE, HEAD och BODY. Låt oss återgå till tidigare nämnt kod-exempel (se nedan), och fundera över vilka element som är nästlade i andra element.</p><div class="panel panel-default"><div class="panel-heading">Ett minimalt HTML-dokument</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Page about kittenz! &lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Notera även att det absolut yttersta elementet är <code>&lt;html&gt;</code>. Ett HTML-dokument måste innehålla ett och endast ett <code>&lt;html&gt;</code>-element. I detta element måste det finnas ett och endast ett <code>&lt;head&gt;</code>- och respektive <code>&lt;body&gt;</code>-element. I huvudet måste vi även ange en sidtitel med hjälp av <code>&lt;title&gt;</code>. Detta är det minsta dokumentet vi kan skapa som validerar, och det är även så här <em>alla</em> html-dokument är strukturerade i botten.</p><h4>Head (meta-data)</h4><p>Så vad lägger vi då inanför <code>&lt;head&gt;</code>-taggarna? Det korta svaret är: meta-data.</p><p>Det längre svaret är att vi även laddar in externa referenser i huvudet. Följande kodruta är ett exempel på hur ett set av <code>&lt;head&gt;</code>-taggar skulle kunna se ut.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på HEAD</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">...
&lt;head&gt;
  &lt;title&gt; Hover cat &lt;/title&gt; 
  &lt;link rel="stylesheet" href="stylesheets/main.css"&gt;
  &lt;script src="javascripts/main.js"&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="keywords" content="Kittens,Hovercrafts"&gt;
&lt;/head&gt;
...</code></pre></div></div><p>Låt oss diskutera ovan kod rad för rad. </p><table class="table table-striped"><tr><th>Rad</th><th>Förklaring</th></tr><tr><td>3</td><td>Den titel som visas högst upp i en sidans "tab" i en webbläsare.</td></tr><tr><td>4</td><td>Säger åt webbläsaren att ladda in en <a href="#stylesheets">Stylesheet</a>-fil, som finns på platsen definerad av <code>href="sökväg-till-filen-här"</code>.</td></tr><tr><td>5</td><td>Säger åt webbläsaren att ladda in en <a href="#javascript">JavaScript</a>-fil, som finns på platsen definerad av <code>src="sökväg-till-filen-här"</code>.</td></tr><tr><td>6</td><td>Berättar för webbläsaren vilken "<a href="http://www.joelonsoftware.com/articles/Unicode.html">character encoding</a>" sidan är skriven i, så att tecken som åäö kan visas korrekt.</td></tr><tr><td>7</td><td>Definerar ett par <a href="http://www.w3schools.com/tags/tag_meta.asp">keywords</a> för sidan. Denna information används av bl.a. sökmotorer för att "förstå" sidans innehåll.</td></tr></table><h4>Body (Sidans faktiska innehåll)</h4><p>Om <code>&lt;head&gt;</code> beskrivs som sidans meta-content -- alltså content om content. Då skulle vi kunna säga att <code>&lt;body&gt;</code> är sidans faktiska content.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på innehåll i BODY</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">...
&lt;body&gt;
  &lt;h2&gt; Sidans titel &lt;/h2&gt; 
  &lt;p&gt; Det här är en paragraf med text. &lt;p&gt;
  &lt;p&gt;
      Och det här är en till, som innehåller en
      &lt;a href="http://uu.se"&gt;länk&lt;/a&gt; till UU.
  &lt;p&gt;
&lt;/body&gt;
...</code></pre></div></div><div class="page-header"><h2><a href="#lankar" name="lankar"><div class="icon-link"></div>Länkar</a></h2></div><p>En länk är ett klickbart område och kan vara en text eller bild. Interna länkar är kommunikationen mellan sidorna
i din webbplats och externa länkar leder till andra webbplatser. Märket för länkar är<code>&lt;a&gt;</code></p><p>(Anchor Hyperlink Reference).
Du kan även ange "ankare", bokmärken, på en sida och länka mellan dem. 
Den adress som länken leder till kallas även URL (Uniform Resource Locator) och kan vara absolut eller relativ. 
För att skapa en länk så kommer detta se ut såhär: <code>&lt;a href="http://im.uu.se"&gt;Information och Media&lt;/a&gt;</code></p><h3>Absoluta länkar</h3><p>En absolut URL innehåller kommunikationsprotokollet HTTP och följs av ett domännamn. 
Externa länkar som leder från en webbplats till en annan webbplats är absoluta. Exempel på absolut URL:
http://im.uu.se</p><h3>Relativa länkar</h3><p>En relativ URL används inom en webbplats och anger sökvägen mellan mappar och dokument. Inget 
kommunikationsprotokoll HTTP eller domännamn behöver anges. Exempel på relativ URL:
html/index.html.</p><h3>Länkar och effekter med CSS</h3><p>Med hjälp av CSS så kan man skapa olika effekter på sina länkar beroende på vilket state som länken har. Exempelvis
kan man få en länk att bli understruken när man "hovrar" över länken. följande CSS på till en länk gör detta. </p><pre><code class="language-css">a:link{ text-decoration:none; color:#CC3333; }
a:visited{ text-decoration:none; color:#CC3333; }
a:active{ text-decoration:none; color:#CC3333; }
a:hover{ text-decoration:underline; }</code></pre><p>Det finns flera andra rollover-effekter och du ser några exempel nedan.</p><pre><code class="language-css">a:hover{ color:#CC6600; }
a:hover{ background-color:#99CCFF; }
a:hover{ text-decoration:underline overline; }
a:hover{ font-style: italic; }
a:hover{ background-image:url('egen_bild.gif'); }
a:hover{ letter-spacing:5px}
a:hover{ cursor:help; }
a:hover{ cursor:e-resize}
a:hover{ color:#FFFFFF; background-color:#006699; }</code></pre><div class="page-header"><h2><a href="#lists" name="lists"><div class="icon-link"></div>Listor</a></h2></div><p>För att kunna skapa listor används ul som står för "Unordered list". För varje item används li. Som ni ser så är oordnad sådan att det är en punkt framför varje item. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på oordnad (icke-numrerad) lista</div><div class="panel-body"><pre><code class="language-markup">&lt;ul&gt;
  &lt;li&gt; Katt &lt;/li&gt;
  &lt;li&gt; Hund &lt;/li&gt;
  &lt;li&gt; Sköldpadda &lt;/li&gt;
&lt;/ul&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><ul><li>Katt</li><li>Hund</li><li>Sköldpadda</li></ul></div></div></div></div><p>För att skapa ordnade (numrerade) listor så används ol. </p><div class="panel panel-default"><div class="panel-heading">Exempel på ordnad (numrerad) lista</div><div class="panel-body"><pre><code class="language-markup">&lt;ol&gt;
  &lt;li&gt; Katt &lt;/li&gt;
  &lt;li&gt; Hund &lt;/li&gt;
  &lt;li&gt; Sköldpadda &lt;/li&gt;
&lt;/ol&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><ol><li>Katt</li><li>Hund</li><li>Sköldpadda</li></ol></div></div></div></div><div class="page-header"><h2><a href="#tables" name="tables"><div class="icon-link"></div>Tabeller</a></h2></div><p>Tabeller används när man behöver strukturera information</p><p>Förr i tiden så strukturerade och positionerade man sin sida med tabeller. Nu använder man div:ar för att fixa detta. Ibland behöver vi dock tabeller för att strukturera information på en hemsida. </p><div class="panel panel-default"><div class="panel-heading">Exempel på tabell</div><div class="panel-body"><pre><code class="language-markup">&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt; Djur&lt;/th&gt;
    &lt;th&gt; Bästa vän&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt; Hund&lt;/td&gt; 
    &lt;td&gt; Katt&lt;/td&gt; 
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt; Råtta&lt;/td&gt; 
    &lt;td&gt; Gris&lt;/td&gt; 
  &lt;/tr&gt;
&lt;/table&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><table style="width:auto;margin:auto 0;" class="table table-bordered"><tr><th>Djur</th><th>Bästa vän</th></tr><tr><td>Hund</td><td>Katt</td></tr><tr><td>Råtta</td><td>Gris</td></tr></table></div></div></div></div><p>Förklaring är att själva tabellen är &lt;table&gt; och att &lt;tr&gt; gör ny rad och varje &lt;td&gt; är en cell. På elementet table finns också border-attributet som är satt till 1. Denan skall göras korrekt med en CSS men används för förtydliga exemplet. </p><div class="page-header"><h2><a href="#formular" name="formular"><div class="icon-link"></div>Formulär</a></h2></div><p>För att användare av webbsidor ska kunna skicka data mellan olika sidor använder vi oss (bl.a.) av formulär.
För att vi som utvecklare ska kunna spara användardata i t.ex. en databas så behöver vi få in data ifrån "klient-sidan" (client-side) till "server-sidan" (server-side). Formulär ger oss ett mycket smidigt sätt att göra detta.</p><h3>Form-taggen </h3><p>Låt oss börja med att skapa ett skal till ett formulär. </p><div class="panel panel-default"><div class="panel-heading">Ett tomt formulär</div><div class="panel-body"><pre><code class="language-markup">&lt;form method="post" action="process-data.php"&gt;
   ...
&lt;/form&gt;</code></pre></div></div><p>Ovan kod resulterar rent visuellt inte i någonting. Under ytan så kommer ju ovan markup absolut att <em>finnas</em> i dokumentet, men rent visuellt ser användaren ingenting.</p><h3>Labels</h3><p>För att användaren ska veta vad hen ska fylla i vart, så använder vi oss av <code>&lt;label&gt;</code>'s.</p><p>Till synes så ser denna tagg inte mycket ut för världen eftersom den endast renderar ut som helt vanlig text. Men eftersom vi associerar labels med input-fält så gör (t.ex.) vissa browsers label-texten klickbar. För radiobuttons så innebär t.ex. ett klick på label:en då samma sak som ett klick på själva knappen.</p><p>Vi använder egenskapen <code>for</code> för att specificiera vilken formulärkontroll en viss label tillhör.</p><div class="panel panel-default"><div class="panel-heading">Exempel på label</div><div class="panel-body"><pre><code class="language-markup">&lt;label for="ett-input-id"&gt;Din e-post&lt;/label&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label>Din e-post</label></div></div><h3>Input, textarea &amp; select</h3><!-- p Så, låt oss lägga till någonting som faktiskt kan vara till användning. Frågan är alltså: hur kan vi ge användaren en möjlighet att skriva in data? Först och främst måste vi helt enkelt välja vad vi menar med data? Det är ju alltså formulär vi behandlar. Vill vi att användaren ska kunna skriva in "fri-text", eller välja mellan tre val, eller välja en/fler/ingen mellan tre val o.s.v. Det finns alltså ett antal olika input-metoder vi kan erbjuda en användare och några presenteras således nedan.--><p>För att skapa själva innehållet i formuläret använder vi oss i huvudsak av taggarna <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> och <code>&lt;select&gt;</code>.</p><p><code>&lt;input&gt;</code>-taggen kan vi använda till att skapa många olika typer av formulärsfält. Närmare bestämt: fritext, radioknappar, checkboxar och gömda fält. Vilken av dessa fält vi vill skapa bestämmer vi genom att sätta attributet <code>type</code>.</p><h4>Fritext (en rad)</h4><p>Följande är ett exempel på hur vi kan göra om vi vill ha ett en-rads-text-fält.</p><div class="row"><div class="col-md-6"><div class="panel panel-default"><div class="panel-heading">Input type text</div><div class="panel-body"><pre><code class="language-markup">&lt;input type="text" placeholder="Your email"&gt;</code></pre></div></div></div><div class="col-md-6"><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form><input type="text" placeholder="Your email" class="form-control"/></form></div></div></div></div><h4>Radio buttons</h4><p>Radio-knappar ger användaren möjligheten att välja ett och endast ett av flera alternativ. Låt oss se till ett exempel, och notera även hur egenskapen <code>for</code> används till att peka <code>&lt;label&gt;</code>'s.</p><div class="panel panel-default"><div class="panel-heading">Radio buttons med labels</div><div class="panel-body"><pre><code class="language-markup">&lt;label for="alt-yes"&gt;Ja&lt;/label&gt;
&lt;input type="radio" id="alt-yes" name="yes-or-no" value="yes"&gt;
&lt;label for="alt-no"&gt;Nej&lt;/label&gt;
&lt;input type="radio" id="alt-no" name="yes-or-no" value="no"&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form><div class="radio"><label for="alt-yes">Ja</label><input type="radio" name="yes-or-no" id="alt-yes"/></div><div class="radio"><label for="alt-no">Nej</label><input type="radio" name="yes-or-no" id="alt-no"/></div></form></div></div><p>Det som vi har här är alltså en formtagg och i denna så ligger två inputfält varav typen är text och name är namnet som vi kommer
använda om vi skulle vilja hämta upp dessa värden med exempelvis PHP. Size anger vilken storlek denna skall ha och maxlength hur
många bokstäver vi kan skriva in i textboxen.</p><h4>Checkboxes</h4><p>Checkboxes använder vi till skillnad ifrån radio buttons när vi vill ge användaren möjligheten att välja ett, eller flera alternativ av många. Mycket användbart när det kommer till frukt!</p><div class="panel panel-default"><div class="panel-heading">Exempel på checkboxes med labels</div><div class="panel-body"><pre><code class="language-markup">&lt;input type="checkbox" name="fruit" value="apple" id="alt-apple"&gt;
&lt;label for="alt-apple"&gt;Apple&lt;/label&gt;
&lt;input type="checkbox" name="fruit" value="banana" id="alt-banana"&gt;
&lt;label for="alt-banana"&gt;Banan&lt;/label&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><div class="checkbox"><input id="alt-apple" type="checkbox" name="fruit" value="apple"/><label for="alt-apple">Äpple</label></div><div class="checkbox"><input id="alt-banana" type="checkbox" name="fruit" value="banana"/><label for="alt-banana">Banan</label></div></div></div><h5>Förklaring av attribut</h5><p>Nedan gäller både för <code>radio button</code>'s och <code>checkbox</code>:ar.</p><table class="table table-hover"><tr><td>name</td><td>Namnet på den grupp som valet tillhör. Detta kommer även att vara "nyckeln" vi använder för att hitta det/de värde/-n användaren valt när denne väl skickat formuläret.</td></tr><tr><td>value</td><td>Eftersom detta inte är ett fritextfält så kommer värdet som skickas vara förbestämt. Med andra ord, detta attribut specificerar det värde vi kommer att se när användaren valt detta alternativ.</td></tr><tr><td>id</td><td>Alla element kan ha unika id:n. I detta fall behöver vi id:n eftersom vi vill kunna referera till input-boxen via vår label.</td></tr></table><h4>Select list</h4><p>Om vi vill erbjuda en användare många alternativ, som t.ex länder, kan radiobuttons och checkboxes ofta ta alldeles för stor plats. Då kan vi använda oss av <code>&lt;select&gt;</code>-listor. </p><div class="panel panel-default"><div class="panel-heading">Exempel på select-lista</div><div class="panel-body"><pre><code class="language-markup">&lt;select name="fruit"&gt;
&lt;option value="banana"&gt;Banan&lt;/option&gt;
&lt;option value="apple"&gt;Äpple&lt;/option&gt;
&lt;option value="grapes"&gt;Vindruvor&lt;/option&gt;
&lt;/select&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label for="select-fruit">Vad vill du äta till frukost?</label><select id="select-fruit" name="frukter" class="form-control"><option value="banan">Banan </option><option value="äpple">Äpple</option><option value="vindruvor">Vindruvor</option></select></div></div><h5>Multiple-choice select</h5><p>Om vi sätter egenskapen <code>multiple</code> så tillåter listan att användaren väljer flera alternativ genom att hålla in <code>ctrl</code> (Windows) eller <code>cmd</code> (Mac). Man kan även markera flera genom att trycka på en post, hålla ned <code>shift</code> och sen trycka på en till.</p><div class="panel panel-default"><div class="panel-heading">Exempel på select-lista</div><div class="panel-body"><pre><code class="language-markup">&lt;select name="fruit" multiple&gt;
...
&lt;/select&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><label for="select-fruit">Vad vill du äta till frukost?</label><select id="select-fruit" name="frukter" multiple="multiple" class="form-control"><option value="banan">Banan </option><option value="äpple">Äpple</option><option value="vindruvor">Vindruvor</option></select></div></div><h4>Submit</h4><p>För att skicka ett formulär måste vi in med en knapp, och använder oss då åter av taggen <code>&lt;input&gt;</code>, men denna gången med typ-attributet satt till <code>submit</code>.</p><p>Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på submit-knapp</div><div class="panel-body"><pre><code class="language-markup">&lt;input type="submit" value="Skicka!"&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><input type="submit" value="Skicka!" class="btn btn-default"/></div></div><h3>Att skicka formuläret</h3><p class="N">är användaren klickar på en submit-knapp i ett formulär så skickas det ifyllda datat med i nästa request. Knappen leder oss till en ny sida som defineras genom attributet <code>action</code></p><p>Tyvärr är det så att HTML i sig är otillräckligt för att göra någonting signifikant vad gäller processning av formulär-data. För att faktiskt spara datat i en databas eller på något annat sätt hantera det så behöver vi ett script-språk (ex: JavaScript, PHP, Ruby, ASP o.s.v.)</p><div class="panel panel-default"><div class="panel-heading">Exempel på action</div><div class="panel-body"><pre><code class="language-markup">&lt;form action="process-form-data.php"&gt;</code></pre></div></div><h4>HTTP Method</h4><p>När vi konstruerar ett formulär som ska skicka data till en annan sida så gör vi det genom en <a href="http://www.w3schools.com/tags/ref_httpmethods.asp" target="_blank">HTTP-metod</a>. För nu kan vi ignorera detta eftersom vi endast pysslar med front-end-språk (html), men det kan ändå vara bra att känna till varför attributet finns där.</p><p>Attributet <code>method</code> kan alterneras mellan de två värdena <code>POST</code> och <code>GET</code>. Dessa är två olika typer av HTTP requests, och skillnaderna innefattar bl.a.a att förstnämnda "gömmer" datat som skickas i request:et, medan sistnämnda visar datat i URL:en. Läs mer i ovan nämnd länk!</p><p>Som tumregel brukar man säga att anrop med "sido-effekter" bör utföras över <code>POST</code> och övriga  över <code>GET</code>. Uttryckt i mer klarspråk: om postningen av formuläret kommer att <em>förändra</em> någonting på servern (ofta spara någonting i en databas) (t.ex. en kommentar), så bör vi arbeta över <code>POST</code>. Om postningen däremot endast syftar till att <em>hämta</em> någonting ifrån servern (t.ex. en sökning) så bör vi arbeta över <code>GET</code>.</p><h3>Komplett exempel</h3><p>Här har vi skapat ett formulär som har två textfält där vi kan skriva in vårt namn och även vad vi skulle vilja heta. Koden för denna 
är som nedanstående:</p><div class="panel panel-default"><div class="panel-heading">Komplett formulär-exempel</div><div class="panel-body"><pre><code class="language-markup">&lt;form action="#" method="GET"&gt;
&lt;div class="form-group"&gt;
  &lt;label for="field-current-name"&gt;Nuvarande namn&lt;/label&gt;
  &lt;input type="text" id="field-current-name" name="current-name" placeholder="Ditt nuvarande namn" required&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
  &lt;label for="field-new-name"&gt;Önskat namn&lt;/label&gt;
  &lt;input type="text" id="field-new-name" name="new-name" placeholder="Ditt önskade namn" required&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
  &lt;div class="radio"&gt;
    &lt;label for="field-gender-man"&gt;Man&lt;/label&gt;
    &lt;input type="radio" id="field-gender-man" name="gender" value="man"&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
  &lt;div class="radio"&gt;
    &lt;label for="field-gender-woman"&gt;Kvinna&lt;/label&gt;
    &lt;input type="radio" id="field-gender-woman" name="gender" value="kvinna"&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;input type="submit" value="Skicka!"&gt;
&lt;/form&gt;</code></pre></div></div><blockquote class="text-danger">Notera att alla <code>div</code>-taggar i ovanstående exempel egentligen är överflödiga. De är endast där för att orsaka radbrytningar mellan varje formulärgrupp och ge oss möjligheten att applicera css-stilar.</blockquote><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><form action="#" method="GET"><div class="form-group"><label for="field-current-name">Nuvarande namn</label><input type="text" id="field-current-name" name="current-name" placeholder="Ditt nuvarande namn" required="required" class="form-control"/></div><div class="form-group"><label for="field-new-name">Önskat namn</label><input type="text" id="field-new-name" name="new-name" placeholder="Ditt önskade namn" required="required" class="form-control"/></div><p>Vänligen uppge ditt kön</p><div class="form-group"><div class="radio"><input id="field-gender-man" type="radio" name="gender" value="man" required="required"/><label for="field-gender-man">Man</label></div><div class="radio"><input id="field-gender-woman" type="radio" name="gender" value="woman" required="required"/><label for="field-gender-woman">Kvinna</label></div><div class="radio"><input id="field-gender-other" type="radio" name="gender" value="other" required="required"/><label for="field-gender-other">Övrigt</label></div></div><input type="submit" value="Skicka!" class="btn btn-default"/></form></div></div><blockquote class="text-info">Prova gärna att skicka formuläret och notera dels vad attributet <code>required</code> orsakar, samt vad som händer i webbläsarens adressfält.</blockquote><div class="page-header"><h2><a href="#doctypes" name="doctypes"><div class="icon-link"></div>Doctypes</a></h2></div><p>HTML har funnits i fler än ett par år, och det har länge funnits mer än en enda browser. Faktumet att de flesta browsers (självklarligen) vill äga majoriteten av marknaden har gett upphov till uttrycket <a href="http://en.wikipedia.org/wiki/Browser_wars" target="_blank">The Browser Wars</a>.</p><p>Detta (bland annat) har gett upphov till att webbläsare i olika skeden implementerat olika delar av HTML-, CSS- och JavaScript-specifikationerna. Med andra ord, att olika "dialekter" av samma språk varit tillåtet i olika webbläsare. Med andra ord att vi kan skriva vissa saker i vissa webbläsare och andra i andra, vilket gör att webbläsare A kanske inte förstår uttryck B, som webbläsare C förstår.</p><p>Detta (bland annat) har gjort att det är viktigt att deklarera vilken standard av HTML, ett visst dokument följer. Så att webbläsaren, "intelligent" (utan att gissa) kan "parse":a (läsa) vår fil enligt rätt specifikation.</p><p>Om du har svårt att förstå varför vi behöver dessa standarder, stanna upp och fundera över faktumet att html-dokument egentligen bara är text. Ingenting annat. Precis som med naturligt språk, så måste mottagaren av meddelandet förstå hur den ska avkoda informationen. Vi kan alltså se doctype-deklarationen lite som att vi berättar för webbläsaren som ska läsa filen vilket dialekt av HTML vi pratar. Löst uttryckt.</p><p>Vi definerar doctypes genom att använda syntaxen <code>&lt;!DOCTYPE x&gt;</code>, allra först i dokumentet. Där <code>x</code> ersätts med den faktiska doctype:en. Nedan följer ett par exempel för hur man deklarerar doctypes.</p><div class="panel panel-default"><div class="panel-heading">Detta dokument deklarerar standarden HTML5</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;Min sida&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h5>HTML 4.01 Strict</h5><p><code>HTML 4.01 Strict</code> tillåter alla HTML 4.01-element och -attribut, men tillåter inte de som exkluderats ("deprecated") ur HTML 4.01-standarden. Närmare bestämt, element och attribut som rör visuell presentation snarare än struktur och content, såsom elementet <code>&lt;font&gt;</code> eller attributet <code>bgcolor="#000000"</code>.</p><div class="panel panel-default"><div class="panel-heading">Doctype för HTML 4.01 Strict</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</code></pre></div></div><h5>HTML 4.01 Transitional</h5><p>Även <code>HTML 4.01 Transitional</code> tillåter alla element och attribut som är tillåtna i HTML 4.01, <em>inklusive</em> de som rör presentation (se förklaring i ovan paragraf).</p><div class="panel panel-default"><div class="panel-heading">Doctype för HTML 4.01 Transitional</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</code></pre></div></div><h5>Och så vidare...</h5><p>Det finns som sagt markant fler doctypes än dessa. Enklast numera är att helt enkelt hålla sig till <code>HTML5</code> och således deklarera <code>&lt;!DOCTYPE html&gt;</code>. Vill du läsa mer om doctypes kan du t.ex. göra det hos <a href="http://www.w3schools.com/tags/tag_doctype.asp" target="_blank">W3 Schools </a>eller på <a href="http://en.wikipedia.org/wiki/Document_type_declaration" target="_blank">Wikipedia</a>.</p><div class="page-header"><h2><a href="#encodings" name="encodings"><div class="icon-link"></div>Character encoding</a></h2></div><p>Kanske har du redan märkt att när man skapar html-dokument som innehåller tecken såsom <code>å</code>, <code>ä</code>, <code>ö</code> kan det hända att de ersätts med en uppsjö a mystiska tecken. Lösningen på detta är <code>character sets</code>.</p><p>För att göra en lång historia kort så var det alltså så att man i datorernas tidiga dagar representerade tecken som <a href="http://sv.wikipedia.org/wiki/ASCII" target="_blank">ASCII</a>-koder. T.ex. så representerades <code>A</code> genom <code>65</code> och <code>a</code> genom <code>97</code>.</p><p>ASCII-tabellen använde sig av 7 bitar, vilket resulterade i 128 olika tecken (eftersom <code>2^7=128</code>), varvid vissa var "unprintable" kontroll-tecken. Som du säkert kan tänka dig upptäckte man snabbt att detta var fullt otillräckligt för att lagra all världens olika tecken. Vi har ju förstås inte bara åäö att arbeta med, utan även kinesiska, grekiska, arabiska o.s.v.</p><blockquote>There is no such thing as plain text<footer>&mdash; <a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></footer></blockquote><p>Ovan citat understryker faktumet att datorer egentligen är väldigt korkade och bara gör det vi säger åt dem. Utan att berätta för en dokumentläsare på vilket sätt vi sparat ett visst tecken så har den ingen chans att veta vad det är för tecken, hur det ska visas, eller ens vart tecknet slutar.</p><p>In kommer <a href="http://sv.wikipedia.org/wiki/UTF-8" target="_blank">utf-8</a> och räddar dagen! Detta är kort sagt är ett sätt att representera <a href="http://sv.wikipedia.org/wiki/Unicode_transformationsformat" target="_blank">Unicode</a>-tecken. Och kort sagt möjliggör användning av världens alla tecken. Och som kort sagt blivit den vanligaste teckenkodningen för webbsidor.</p><p>Ett dokuments teckenkodning sätter vi genom att skapa en <code>&lt;meta&gt;</code>-tag med attributet <code>charset</code> satt till valfritt charset (såsom just utf-8). Eftersom detta tillhör meta-information om dokumentet skall vi placera taggen under <code>&lt;head&gt;</code>. Vidare bör vi även specificera vårt <code>charset</code> så <a href="http://stackoverflow.com/questions/5572471/in-head-which-comes-first-meta-or-title" target="_blank">tidigt som möjligt</a> i <code>&lt;head&gt;</code> eftersom webbläsaren behöver veta vilken teckenkodning vi använt för att ordentligt kunna läsa det dokument den redan läser.</p><div class="panel panel-default"><div class="panel-heading">Ett dokument som definierar character set:et utf-8</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;The utf-8, I speak!&lt;/title&gt;
  &lt;/head&gt;
&lt;/html&gt;</code></pre></div></div><div class="page-header"><h2><a name="bilder" id="bilder">Bilder</a></h2></div><p>Nu var det en massa snack om text, encoding, listor, och indentering hit och dit. Dags att bli lite mer visuella! Vad vi undrar är alltså &mdash; hur kan vi få in bilder i våra sidor?</p><p>Svaret är egentligen väldigt enkelt. Genom att använda <code>&lt;img&gt;</code>-taggen tillsammans med attributet <code>src</code>. Låt oss se till ett exempel.</p><div class="row"><div class="col-md-6"><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi kan lägga in en bild</div><div class="panel-body"><pre><code class="language-markup">&lt;img src="http://placekitten.com/g/60/60"&gt;</code></pre></div></div></div><div class="col-md-6"><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><img src="http://placekitten.com/g/60/60" alt="En mästerkatt utan stövlar"/></div></div></div></div><blockquote class="text-info">Prova gärna att klistra in adressen som bilden ovan pekar mot i webbläsaren och kolla vad som finns under adressen. </blockquote><p>Notera alltså att att adressen ovan (som antytt) pekar mot en URL som renderar en bild. (Tjänsten <a href="http://placekitten.com" target="_blank">placekitten</a> erbjuder helt enkelt bilder i olika storlekar under alla sina URL:er.) Således kan vi alltså ersätta den adressen med en bild som finns lokalt på vår dator, på vår egen server eller någon annanstans på internet. Attributet <code>src</code> förväntar sig helt enkelt en adress till en bild.</p><h3>Alternativ</h3><p>Men vad händer om en bild inte kan renderas? Och vad händer när en <a href="http://en.wikipedia.org/wiki/Screen_reader" target="_blank">screen reader</a> upptäcker en bild. In kommer <code>alt</code>-attributet och räddar dagen! Låt oss se till ett exempel innan vi går vidare.</p><div class="panel panel-default"><div class="panel-heading">Exempel på användning av alt-attributet</div><div class="panel-body"><pre><code class="language-markup">&lt;img src="http://placekitten.com/g/60/60" alt="En mästerkatt utan stövlar"&gt;</code></pre></div></div><p>Om vi nu försöker nå ovan bild genom någon form av läsare som inte kan rendera bilder så kommer vi istället få texten <em>En mästerkatt utan stövlar</em>. I annat fall kommer bilden att visas som vanligt och texten inte synas. Tänk på att attributet <code>alt</code> krävs för att en <code>&lt;img&gt;</code>-tagg ska vara <a href="http://www.w3schools.com/tags/tag_img.asp" target="_blank">valid</a>.</p><blockquote class="text-danger">Attributen <code>alt</code> och <code>src</code> krävs båda för att en <code>&lt;img&gt;</code>-tagg ska vara valid.</blockquote><h3>Bildtexter</h3><p>Om vi vill lägga till en bildtext till vår bild kommer de nya html5-elementen <code>&lt;figure&gt;</code> och <code>&lt;figcaption&gt;</code> väl till pass.</p><p>Dessa är <em>semantiska</em> attribut snarare än <em>visuella</em>. Med andra ord. Visst har <code>&lt;p&gt;</code>-taggen en semantisk innebörd &mdash; en paragraf representerar ju semantiskt ett stycke text, och således rimligen en tanke. Men i HTML så resulterar ju även en paragraf i någonting visuellt skillt ifrån plain-text och därmed </p><p>Elementen <code>figure</code> och <code>figcaption</code> är båda <em>semantiska</em> element snarare än direkt <em>visuella</em>. Med andra ord, om vi skulle välja att bara skriva ut vår bild följd av ett helt vanligt paragraf-element som innehåller vår bildtext, så skulle det visuella resultatet bli ungefär likadant som om vi använde figure och figcaption. Poängen med att dock istället använda figure och figcaption är att vi <a href="http://en.wikipedia.org/wiki/Semantic_HTML" target="_blank">berikar dokumentet med semantik</a>. Plus att vi har ett enhetligt sätt att angripa bildtexter ifrån våra stilmallar (css).</p><blockquote class="text-success"><code>&lt;figure&gt;</code> och <code>&lt;figcaption&gt;</code> är båda element med semantisk mening.</blockquote><div class="row"><div class="col-md-6"><div class="panel panel-default"><div class="panel-heading">Exempel på figurannotation med figcaption</div><div class="panel-body"><pre><code class="language-markup">&lt;figure&gt;
  &lt;img src="http://placekitten.com/g/130/130"&gt;
  &lt;figcaption&gt;
    En mästerkatt utan stövlar.
  &lt;/figcaption&gt;
&lt;/figure&gt;</code></pre></div></div></div><div class="col-md-6"><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><figure><img src="http://placekitten.com/g/130/130" alt="En mästerkatt utan stövlar"/><figcaption>En mästerkatt i stövlar.</figcaption></figure></div></div></div></div><h1>Cascading Stylesheets</h1><p class="lead">Om HTML beskriver en webbsidas innehåll så beskriver CSS hur detta innehåll ser ut. Om webben var en teaterpjäs skulle HTML vara manuset och CSS regissören. "Du ska stå där, du där och du där! Vänta nu, du behöver ha en grön hatt, och du behöver ha en mask och en cape!"</p><div class="page-header"><h2><a href="#css-intro" name="css-intro"><div class="icon-link"></div>Introduktion till CSS</a></h2></div><p>CSS &mdash; (Cascading StyleSheets) är stilmallar i praktiken används till att formge dokument. Formge färg, teckensnitt, positionering, justering, backgrunder, scroll, o.s.v. En enda CSS-mall kan styra tusentals dokument och det är då enkelt att ändra formateringen genom att det bara i CSS-mallen.</p><p>CSS har tagit HTML ett steg längre och möjliggjort formateringar och effekter som inte fanns i HTML standarden. En av fördelarna med CSS är att flera mallar kan användas  och de har då företräde inbördes så att en "huvudmall" med de övergripande formateringarna kan ersättas på en lägre nivå av en "lokal mall" som då gäller före huvudmallen. Det är detta som åsyftas när man säger att css är <code>cascading</code>.</p><blockquote>Med css kan vi separera innehåll och presentation.</blockquote><p>CSS är ett initiativ till att separera <b>innehåll</b> och <b>presentation</b>. Att definiera allt relaterat till presentation i en extern mall har många fördelar. Bland annat att:</p><ul><li>Vi kan återanvända presentationsreglerna över många sidor.</li><li>Sidorna laddas snabbare eftersom CSS-filen kan cachas av webbläsaren.</li><li>HTML-sidan lever rimligen längre eftersom vi kan förändra presentationen utan att behöva ändra avsevärt i innehållets struktur.</li></ul><h3>Tillgänglighet &amp; responsivitet</h3><p>En målsättning och effekt av att presentation separeras ifrån innehåll -- är adaptivitet. Om innehållet är helt "befriat ifrån" presentation så skulle man i teorin kunna visa innehållet med vilken typ av presentation som som helst.</p><p>För att göra det mer uppenbart, låt oss fundera över hur situationen såg ut tidigare. Om vi beblandar presentation (css) med vårt innehåll (html) så kommer det vara svårt för en maskin att avgöra vad som hör till presentationen och vad som hör till innehållet. Tänk t.ex. på radbrytningar. Används en radbrytning för att understryka att två paragrafer är skilda ifrån varandra, eller används den för att skapa ett bekvämt visuellt avstånd? Både fallen kan vara sanna. Detta är svårt för en maskin att avgöra.</p><p>I praktiken har detta t.ex. varit ett problem för syn- och hörselskadade. Tänk på <a href="http://en.wikipedia.org/wiki/Screen_reader">screen readers</a> t.ex. som genom text-to-speech försöker läsa upp en sidas innehåll för en användare. Hur skulle det vara om den började läsa saker som "blå bakgrund". </p><p>Ett av målen för W3C (standardsorganisationen för bl.a. css) är att underlätta för konumptionen av webbaserat innehåll på plattformar än just en dator. Det kan handla om allt ifrån Smartphones till enheter för talsyntes och punktskrift (Braille). Genom att separera innehåll ifrån presentation är det alltså markant lättare, eftersom maskinen inte behöver bry sig om att filtrera ut presentationen ifrån innehållet.</p><p>Detta betyder förstås att vi sedan lång tid tillbaka behövt lägga gamla troll som Frames, Iframes, Imagemaps, java applets, javascript, bilder utan ALT-text, GIF-animationer, Flash, Shockwave, PDF-dokument osv. Många funktioner som används idag går då alltså bort helt.</p><div class="page-header"><h2><a href="#css-selectorer" name="css-selectorer"><div class="icon-link"></div>CSS-selectorer</a></h2></div><h3>Vanliga selektorer och atttribut</h3><p>Man kan ju tycka att det borde räcka med att kunna hänvisa till element bara via deras typ, klass eller typer. Detta är dock inte sant, suck! Det går att använda att komma åt element på andra sätt och detta gör det lättare man slipper sätta klass eller id på allt. Nedanför finner ni olika selektorer och exempel. Observera att det finns flera....Never ending story! </p><h4>Selektor: *</h4><div class="panel panel-default"><div class="panel-heading">Exempel på HTML och CSS med * </div><div class="panel-body"><pre><code class="language-markup">&lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
    &lt;p&gt;En paragraf, yay!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><div class="panel-body"></div><pre><code class="language-css">*{
  font-size: 24px; 
  background:#ff6600;
 }</code></pre></div></div><h4>Selektor: E</h4><div class="panel panel-default"><div class="panel-heading">Exempel på HTML och CSS med E </div><div class="panel-body"><p>E står i detta fall att man använder elementets typ som selektor. </p><pre><code class="language-markup">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;En paragraf, yay!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="panel-body"><pre><code class="language-css">p{
  font-size: 24px; 
  background:#ff6600;
}</code></pre></div></div><h3>PseudoKlasser</h3><h4>E:link</h4><div class="panel panel-default"><div class="panel-heading">Exempel på ett element som är en länk som inte besökts än.</div><div class="panel-body"><pre><code class="language-markup">&lt;html&gt;
  &lt;body&gt;
    &lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="panel-body"><pre><code class="language-css">a:link{
  color:pink;
}</code></pre></div></div><h4>E:visited</h4><div class="panel panel-default"><div class="panel-heading">Exempel på ett element som har blivit besökt.</div><div class="panel-body"><pre><code class="language-markup">&lt;html&gt;
  &lt;body&gt;
    &lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="panel-body"><pre><code class="language-css">a:visited{
  color:blue;
}</code></pre></div></div><h4>E:hover</h4><div class="panel panel-default"><div class="panel-heading">Exempel på element som har muspekaren över sig.</div><div class="panel-body"><pre><code class="language-markup">&lt;html&gt;
  &lt;body&gt;
    &lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="panel-body"><pre><code class="language-css">a:hover{
  color:green;
}</code></pre></div></div><h4>E:active</h4><div class="panel panel-default"><div class="panel-heading">Exempel på länk som är aktivt (exempelvis när användaren trycker ner knappen)</div><div class="panel-body"><pre><code class="language-markup">&lt;html&gt;
  &lt;body&gt;
    &lt;a href="http://htmlhunden.se"&gt;Värsta grymma grejen!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="panel-body"><pre><code class="language-css">a:active{
  color:purple;
}</code></pre></div></div><h3>Kombinationer</h3><h4>EF</h4><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><p>Alla element F som kommer efter E. Alltså i detta fall alla tre första paragrafer. </p><pre><code class="language-markup">&lt;div class="yttre"&gt;
    &lt;p&gt;En första paragraf&lt;/p&gt;
    &lt;p&gt;En andra paragraf&lt;/p&gt;
    &lt;p&gt;En tredje paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En fjärde paragraf&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre></div><div class="panel-body"><pre><code class="language-css">.yttre p{
  color:pink;
}</code></pre></div></div><h4>E+F</h4><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><p>alla element som direkt föregås av E. Alltså i detta fall kommer andra och tredje paragrafen att påverkas. </p><pre><code class="language-markup">&lt;div class="yttre"&gt;
    &lt;p&gt;En första paragraf&lt;/p&gt;
    &lt;p&gt;En andra paragraf&lt;/p&gt;
    &lt;p&gt;En tredje paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En rubrik, yay!&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre></div><div class="panel-body"><pre><code class="language-css">p + p{
  color:pink;
}</code></pre></div></div><h4>E > F </h4><div class="panel panel-default"><div class="panel-heading">Exempel på element som är direkt barn av ett annat element. </div><div class="panel-body"><p>Observera att alla första och andra paragrafen kommer att bli rosa men inte den fjärde.</p><pre><code class="language-markup">&lt;div class="yttre"&gt;
    &lt;p&gt;En första paragraf&lt;/p&gt;
    &lt;p&gt;En andra paragraf&lt;/p&gt;
  &lt;div class="inre"&gt;
    &lt;p&gt;En rubrik, yay!&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre></div><div class="panel-body"><pre><code class="language-css">.yttre > p{
  color:pink;
}</code></pre></div></div><!-- TODO: This really needs more flesh when it comes to selectors--><!-- There is yet nothing about pseudo elements, nesting nor siblings or--><div class="page-header"><h2><a href="#css-syntax" name="css-syntax"><div class="icon-link"></div>CSS syntax och struktur</a></h2></div><p>För att enklare förstå hur CSS hanteras, föreställ dig att webbläsaren består av två ninjateams. Det första ninjateamet läser HTML-filen och skriver ut en massa text, bilder, listor, tabeller och länkar på skärmen. När första teamet hittar en referens till en CSS-fil, skickar de det till det andra ninjateamet. Det andra ninjateamet går då lös med färgkritor och klipper och klistrar tills allt ser snyggt ut.</p><p>Även om ovanstående exempel är orimligt oseriöst är poängen att rendering av en webbsida (metaforiskt) sker i olika "pass". Där det första är att få ut resultatet av HTML:en på skärmen, och det andra att visuellt ändra på resultatet av HTML:en enligt det som definierats i CSS-filen. Du kommer upptäcka att det finns fler "pass" (och att ordningen kan variera) när vi kommer till JavaScript, men det lämnar vi för nu.</p><p>Varför är det då viktigt att förstå att CSS kommer i det "andra passet"? Jo, eftersom det är viktigt att förstå att CSS <em>appliceras</em> på ett befintligt dokument. Med andra ord, ett CSS-dokument är i sig helt meningslöst. Eftersom ett CSS-dokument då appliceras på ett HTML-dokument så måste varje CSS-regel veta <em>vad</em> den ska appliceras på. Och det är här <code>selectors</code> kommer in i bilden. Låt oss se till ett exempel.</p><blockquote>En css-<code>selector</code> definierar vilka html-<code>element</code> som ska påverkas av en viss effekt.</blockquote><div class="panel panel-default"><div class="panel-heading">CSS-selector för HTML-element</div><div class="panel-body"><p>index.html</p><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;The morning&lt;/title&gt;
    &lt;link rel="stylesheet" href="main.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;As Gregor Samsa awoke one morning from uneasy dreams [..]&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>main.css</p><pre class="line-numbers"><code class="language-css">body{
  background-color: lightblue;
}
p{
  color: #ffffff;
}</code></pre><p>Resultat</p><div class="panel panel-default"><div style="background-color:lightblue; color:#ffffff;padding-top:23px;" class="panel-body"><p>As Gregor Samsa awoke one morning from uneasy dreams [..]</p></div></div></div></div><p>Hur ska vi nu tänka kring det här? De viktigaste sakerna att poängtera är:</p><ul><li><em>Rad 5</em> i html-dokumentet är det som gör att det som säger åt HTML-ninjorna att de behöver hämta CSS-ninjorna och att de ska läsa filen <code>main.css</code>.</li><li><em>Rad 1</em> i css-dokumentet är en <code>selector</code> vars <code>target</code> är <code>&lt;body&gt;</code>-elementet. Det betyder att allt mellan följande <a href="http://en.wikipedia.org/wiki/Bracket#Curly_brackets_or_braces_.7B_.7D" target="_blank">måsvingar</a> (<code>{...}</code>) kommer att appliceras på <em>alla</em> <code>&lt;body&gt;</code>-element i html-dokumentet. Nu bör det ju förstås bara finnas ett body-element men förhoppningsvis har du redan förstått att vi hade kunnat välja vilket annat html-element som helst.</li><li><em>Rad 2 och 5</em> i css-dokumentet är faktiskt css-<code>deklarationer</code>. Det är de som således bestämmer vilken visuell effekt som ska appliceras på just den selector vi definierat.</li></ul><blockquote>En css-<code>selector</code> kan vara vilket html-<code>element</code> som helst.</blockquote><p>Låt oss se det rent generellt. Syntaxen är alltså som följande.</p><div class="panel panel-default"><div class="panel-heading">CSS-syntax uttryckt generellt</div><div class="panel-body"><pre class="line-numbers"><code class="language-css">css-selector{
  declaration-property: declaration-value;
}</code></pre></div></div><p>Så, låt oss uttrycka syntaxen för <code>deklarationer</code> i ord: En css-<code>deklaration</code> består av en <code>egenskap</code> (även kallat: property, nyckel, key), följt av ett kolon (<code>&#58;</code>) som fungerar som en avgränsare mellan nyckeln och värdet. Vidare följt av det faktiska <code>värdet</code> (som kan ges i en mängd olika format, såsom exempelvis <code>left</code>, <code>-32px</code>, <code>233%</code> eller <code>light</code>, beroende på vilken egenskap vi sätter värdet för). Slutligen anger vi ett semikolon (<code>&#59;</code>) för att terminera raden. Det sistnämnda gör det möjligt att skriva flera deklarationer på samma rad (vilket dock oftast gör filen väldigt svårläslig).</p><blockquote>En css-<code>deklaration</code> består av en <code>property</code> (även kallat: nyckel, key, egenskap), ett kolon (<code>&#58;</code>), ett <code>värde</code> och slutligen ett semikolon (<code>&#59;</code>).</blockquote><h3>Exempel på selectors genom klass och ID</h3><p>Utöver att skriva css-selectors som träffar html-element så kan vi även skriva selectors för <code>ID</code>:n och <code>klasser</code>.</p><p>Vi använder ID:n för att defineira "unika" element. Vad menar vi med unika? Jo att om någonting har id:et <code>container</code> så får det endast finnas ett enda element på sidan som har just det ID:et. Vi kan självklart skriva flera css-regler som använder just den selectorn. Men i html-dokumentet får ID:t alltså endast förekomma en enda gång.</p><p>Behöver vi kunna referera till flera element så använder vi oss av klasser. Klasser fungerar på exakt samma sätt som ID:n förutom just det att det är tillåtet att flera element använder samma klass.</p><p>Enklast är nog att som vanligt se till ett exempel över hur detta fungerar.</p><div class="panel panel-default"><div class="panel-heading">Klasser och ID:n</div><div class="panel-body"><p>index.html</p><pre class="line-numbers"><code class="language-markup">...
&lt;p class="redish"&gt;As Gregor Samsa awoke one morning&lt;/p&gt;
&lt;p id="blueish"&gt;from uneasy dreams&lt;/p&gt;
&lt;p&gt;he found himself transformed in his bed&lt;/p&gt;
&lt;p class="redish"&gt;into a monstrous vermin.&lt;/p&gt;
...</code></pre><p>main.css</p><pre class="line-numbers"><code class="language-css">p{
  color: orange;
}
.redish{
  color: red;
}
#blueish{
  color: blue;
}</code></pre><p>Resultat</p><div class="panel panel-default"><div class="panel-body"><p style="color:red;">As Gregor Samsa awoke one morning</p><p style="color:blue;">from uneasy dreams</p><p style="color:orange;">he found himself transformed in his bed</p><p style="color:red;">into a monstrous vermin.</p></div></div></div></div><!-- TODO: This really needs more flesh when it comes to selectors--><!-- There is yet nothing about pseudo elements, nesting nor siblings or--><div class="page-header"><h2><a href="#css-placering" name="css-placering"><div class="icon-link"></div>Vart skall jag lägga CSS:en?</a></h2></div><p>När du använder CSS för att formatera en sida kan du infoga CSS-formateringen på tre sätt:</p><ol><li>Extern CSS-mall<br/>en extern CSS-mall som kopplas till dokumentet</li><li>I dokumentet<br/>i dokumentets huvud head-taggen</li><li>Direkt i element)<br/>i elementet där CSS-formateringen ska utföras </li></ol><h3>Extern CSS-mall</h3><p>Det här är den vanligaste användningen av CSS där ett externt dokument som innehåller formateringen kopplas till alla de 
sidor som ska tillämpa formatet. Namnet på CSS-mallen måste ha filtilläget .css och namnet på mallen i exemplet nedan är 
"mall.css". 
Den här metoden är mest effektiv, om formateringen ska ändras behöver du bara göra det i ett enda mall-dokument. 
Här uppfylls målet med att separera innehåll och struktur i dokumenten.
Så här kan koden för sidorna som kopplas till mallen se ut:</p><div class="panel panel-default"><div class="panel-heading">Exempel på referens till extern stilmall</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;link href="mall.css" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Du kan koppla flera externa CSS-mallar till samma dokument. Om samma selektorer förekommer i båda
mallarna men med olika formatering gäller den mall som angivits senast i radvis ordning. I exemplet nedan 
gäller alltså "mall2.css" före "mall.css": </p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med referenser till flera stilmallar</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;link href="mall.css" rel="stylesheet"&gt;
    &lt;link href="en_till_mall.css" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h3>I dokumentet</h3><p>CSS-formatering angiven direkt i dokumentet kan användas när vissa sidor ska avvika från 
huvudmallens formatering. Den här metoden är inte lika effektiv som att använda en extern CSS-mall.
Om formateringen ska ändras måste det utföras i varje dokument som använder formateringen.
Här formateras rubriken direkt i dokumentet:</p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med css definierad direkt i HEAD</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
    &lt;style type="text/css"&gt;
      h2 { font-size: 24px; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><h3>Direkt i elementet som ska formateras </h3><p>Den här metoden är minst effektiv och här uppfylls inte målet med att separera innehåll och
struktur i dokumenten. CSS-formateringen anges i anslutning till de elementsom ska formateras. 
När formatet ska användas i ett nytt elememnt måste CSS-koden anges på nytt och det innebär att sidorna 
innehåller mycket kod och tar längre tid att laddas i webbläsaren.
Så här kan koden se ut när rubriken formateras direkt i elementet:</p><div class="panel panel-default"><div class="panel-heading">Exempel på ett html-dokument med css definierad i ett element (även kallat: inline)</div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; Sidans namn &lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2 style="font-size:24px;"&gt;En rubrik, yay!&lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Prioriteringsordningen av formateringen är följande:</p><ol><li> HTML-formatering</li><li>CSS-kod i element eller avsnitt där formateringen ska tillämpas</li><li>CSS-kod i dokumentet</li><li>CSS i extern mall</li></ol><p>Detta innebär att du kan börja formateringen i en extern CSS-mall som du kopplar till dina dokument.
Vill du sedan ange avvikande format lokalt i ett dokument formaterar du CSS direkt i dokumentet 
(gäller då före den externa CSS-mallen). Om någon del av dokumentet ska avvika från övrig CSS-formatering 
anger du detta direkt i avsnittet/objektet (gäller då före både CSS i dokumentets HEAD och CSS i en extern
CSS-mall)</p><div class="page-header"><h2><a href="#css-cascade" name="css-cascade"><div class="icon-link"></div>Cascading</a></h2></div><p>Tänk på namnet &mdash; <em>Cascading Stylesheets</em> &mdash; stilmallar som "kaskadar". Vad menas egentligen med att de "kaskadar" och hur kan vi använda det till vår fördel?</p><p>Just ordet "<a href="http://sv.wikipedia.org/wiki/Kaskad" target="_blank">kaskad</a>" åsyftar idén om att någonting "faller" ned ifrån en nivå till en annan och så vidare i etapper. I relation till just CSS så handlar detta om att (de flesta) CSS-regler som appliceras på en förälder även gäller för alla förälderns barn.</p><p>Låt oss se till exempel för att bättre förstå vad vi pratar om.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en regel kaskadar igenom ifrån föräldern till barnen</div><div class="panel-body"><pre><code class="language-markup">&lt;body&gt;
  &lt;p&gt;First paragraph&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;Second paragraph&lt;/p&gt;
  &lt;div&gt;
&lt;/body&gt;</code></pre><pre><code class="language-css">body {
  color: green;
}</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="color: green;" class="panel-body"><p>First paragraph</p><div><p>Second paragraph</p></div></div></div></div></div><blockquote>Mer specifika regler skriver över mindre specifika regler oavsett i vilken ordning de dyker upp i css-filerna.</blockquote><p>Att mer specifika regler skriver över mindre specifika regler innebär att vi kan utnyttja kaskadet till vår fördel. Genom att således definiera generella regler på en "hög" nivå och sedan skriva över med de specika ändringar som vi vill göra.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en mer specifik regel <em>skriver över</em> en mindre specifik (kaskadad) regel</div><div class="panel-body"><pre><code class="language-markup">&lt;body&gt;
  &lt;p&gt;First paragraph&lt;/p&gt;
  &lt;div&gt;
    &lt;p&gt;Second paragraph&lt;/p&gt;
  &lt;div&gt;
&lt;/body&gt;</code></pre><pre><code class="language-css">body { color: green; }
div p { color: blue; }</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="color: green;" class="panel-body"><p>First paragraph</p><div><p style="color: blue;">Second paragraph</p></div></div></div></div></div><p>Låt oss se till ett till exempel där vi använder ett elements ID för att kunna skriva över stilarna specifikt. Notera hur den andra paragrafen fortsätter att vara <b>fetstilad</b> eftersom den "ärver" den regeln av sin förälder. Alltså, egenskapen kaskadar ned ifrån föräldern till barnet.</p><div class="panel panel-default"><div class="panel-heading">Ett exempel på hur en mer specifik regel <em>skriver över</em> en mindre specifik (kaskadad) regel</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt;First paragraph&lt;/p&gt;
&lt;p id="selected"&gt;Second paragraph&lt;/p&gt;
&lt;p&gt;Third paragraph&lt;/p&gt;</code></pre><pre><code class="language-css">p {
  color: red;
  font-weight: bold;
}
#selected {
  color: orange;
}</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div style="font-weight:bold; color:red;" class="panel-body"><p>First paragraph</p><p style="color: orange">Second paragraph</p><p>Third paragraph</p></div></div></div></div><div class="page-header"><h2><a href="#boxmodell" name="boxmodell"><div class="icon-link"></div>Boxmodellen</a></h2></div><p>Varje element som finns på en sida är egentligen en box. Därav så brukar man ofta prata om Boxmodellen för att se vad som </p>händer runt varje element<pre><code class="language-markup"> -------------------------------------------------------------------------
|                            Margin                                       |
|  ---------------------------------------------------------------------  |
| |                          Border                                     | |
| |  -----------------------------------------------------------------  | |
| | |                        Padding                                  | | | 
| | |  -------------------------------------------------------------  | | |
| | | |                      Content                                | | | |
| | | |                                                             | | | |
| | |  -------------------------------------------------------------  | | |
| | |                                                                 | | |
| |  -----------------------------------------------------------------  | |
| |                                                                     | |
|  ---------------------------------------------------------------------  |
|                                                                         |
--------------------------------------------------------------------------|</code></pre><p>Förklaring av de olika delarna:</p><ul><li>Margin är en transparant area runt ramen. </li><li>Border är en area runt som man kan sätta att ha en viss färg eller typ av border. </li><li>Padding är en area runt ett innehåll och den kommer att ha färgen som själva boxen är färgad i.</li><li>Content är helt enkelt innehållet av boxen som exempelvis kan vara text. </li></ul><div class="page-header"><h2><a href="#css-positionering" name="css-positionering"><div class="icon-link"></div>CSS Positionering</a></h2></div><p>Om man tar en sväng på internet och funderar lite på det vi hittills lärt oss om HTML och CSS så inser man snabbt att saker inte alls bara ligger rakt upp och ned i dokumentet. Texter ligger i mitten, vi har kolumner och rader, marginaler och boxar som verkar vara "sticky".</p><p>I det här kapitlet går vi igenom de olika värden vi kan ge css-attributet <code>position</code>, närmare bestämt <code>absolute</code>, <code>relative</code> och <code>static</code>.</p><p>Om vi inte anger någonting annat så är alla element statiskt placerade. Det är värt att notera att även om namnet på attributet <code>position</code> verkar antyda det så är det verkligen inte det enda sättet webbutvecklare positionerar saker genom. Men med rätt förståelse för attributet finns det knappt någon positionering vi inte kommer kunna åstadkomma.</p><h3>Static</h3><p>Om du inte anger någonting annat, kommer element att positioneras statiskt. Alltså följa sin naturliga plats i dokumentet.</p><p>Det är viktigt att uppmärksamma att ett statiskt element på de (tänk dig en sida som ett koordinatsystem) koordinaterna <code>{0,0}</code>, omöjliggör att ett statiskt placerat syskon också placeras på <code>{0,0}</code>. Med andra ord tar statiskt placerade element upp plats och således kan syskon inte ligga på varandra utan placeras istället under (om de är <a href="http://en.wikipedia.org/wiki/HTML_element#Block_elements" target="_blank">block-level element</a>) eller bredvid (om de är <a href="http://en.wikipedia.org/wiki/HTML_element#Inline_elements" target="_blank">inline-level element</a>) varandra.</p><blockquote>Statiska element tar upp plats</blockquote><p>Att ett statiskt element inte kan placeras på ett annat element gäller förstås bara element som är syskon. Ett elements barn placeras förstås naturligt "innuti" förälderelementet.</p><p>Med andra ord. Om ett förälderelement har de (hypotetiska) koordinaterna <code>{0,0}</code> så kommer även första barnet till det elementet ha koordinaterna <code>{0,0}</code>.</p><p>Låt oss se till några exempel.</p><div class="panel panel-default"><div class="panel-heading">Exempel på statisk positionering för två <code>&lt;div&gt;</code>:ar efter varandra.</div><div class="panel-body"><div style="width:100px;height:100px;background:red; margin-bottom:12px;"></div><div style="width:100px;height:100px;background:blue;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på statisk positionering för en <code>&lt;div&gt;</code> i en <code>&lt;div&gt;</code></div><div class="panel-body"><div style="width:100px;height:100px;background:red;"><div style="width:70px;height:70px;background:blue;"></div></div></div></div><h3>Fixed</h3><blockquote>Fixerade element tar inte upp plats</blockquote><p>Med fixerad positionering säger vi åt ett element att ignorera sin "normala" plats i dokumentflödet och istället placera sig på en position i relation till webbläsarfönstret.</p><p>Med andra ord så är alltså (den tänkta koordinaten) <code>{0,0}</code> högst upp till vänster i webbläsaren. Detta förutsatt att vi sätter föregående värden för egenskaperna <code>left</code> och <code>top</code> vilket då i ett kordinatsystem skulle motsvaras av <code>x</code> och <code>y</code>. Således kan vi sluta oss till att origo är högst upp till vänster i webbläsaren.</p><p>Vad som gör positionering i css intressant är att vi även kan vända steken och istället sätta värden för egenskaperna <code>right</code> och <code>bottom</code>. Vi hanterar då fortfarande <code>x</code> och <code>y</code> i bemärkelsen horisontellt och vertikalt men vi har nu flyttat origo ner till högra hörnet. Plus att vårt koordinatsystem nu fungerar "baklänges". Ett högre värde för right innebär att vi flyttar vårt element längre åt vänster. Sätt detta i relation till att ett högre värde för left flyttar vårt element längre åt höger.</p><blockquote>Tänk på positioneringsteknikerna <code>fixed</code>, <code>absolute</code> och <code>relative</code> som positionering genom i ett  koordinatsystem.</blockquote><p>Medan ovan kommentarer gäller för alla <code>position</code>-värden utom <code>static</code>, gäller följande endast för <code>position</code>-värdet <code>relative</code>.</p><p>Relative ignorerar hur användaren scrollar i ett dokument. En tänkt koordinat, säg <code>{100,120}</code>, står i relation till browserns storlek och endast browserns storlek och det "fönster" där browsern renderar sidan. Med andra ord, kommer elementet alltid att befinna sig 120px ifrån fönstrets topp, <em>inte</em> ifrån dokumentets topp (vilket är hur <code>absolute</code> positionering beteer sig).</p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#blue {
  position: fixed;
  top:  20px;
  left: 30px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Bilden i detta exempel har fixed positionering</div><div class="panel-body"><iframe id="example-css-position-fixed" style="width:100%; height:200px; border:1px solid #dedede; overflow:scroll;"></iframe></div></div><h3>Absolute</h3><p>Även med absolut positionering så säger vi åt ett element att ignorera sitt "normala" dokumentsflöde och istället placera sig på precis de koordinater vi specificierar.</p><p>Frågan är då bara &mdash; precis på de koordinaterna i relation till vad? I det normala fallet så betyder det i relation till fönstret. Men om någonting absolut positionerat befinner sig i någonting annat som är absolut eller relativt positionerat så räknar vi då i relation till den föräldern.</p><p>Ovan blir nog enklare att förstå om vi ser till ett par exempel.</p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#red {
  position: absolute;
  top:   0;
  right: 0;
}
#blue {
  position: absolute;
  bottom: 0px;
  left:   0px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på absolut positionering för två <code>&lt;div&gt;</code>:ar</div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:absolute;top:0;right:0;"></div><div style="width:70px;height:70px;background:blue;position:absolute;bottom:0;left:0;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på absolut positionering för en <code>&lt;div&gt;</code> i en absolut positionerad <code>&lt;div&gt;</code></div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:absolute;top:0;right:0;"><div style="width:70px;height:70px;background:blue;position:absolute;bottom:0;left:0;"></div></div></div></div><h3>Relative</h3><p>När vi positionerar ett element relativt så är det som om vi kombinerar metoderna statisk och absolut. Vi positionerar ett element relativt till dess statiska position.</p><p>Med andra ord, elementet antar först den position den bör få i det statiska flödet, och vi ser nu den platsen som "nollpunkten" (origo). Sedan tas elementet ut ur dokumentflödet och vi placerar det absolut (enligt de koordinater vi angett) i relation till sin statiska placering. </p><div class="panel panel-default"><div class="panel-heading">Följande exempel använder sig av nedan css</div><div class="panel-body"><pre><code class="language-css">#red {
  position: relative;
  top:  0;
  left: 0;
}
#blue {
  position: relative;
  top: -10px;
  left: 10px;
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på relativ positionering för två <code>&lt;div&gt;</code>:ar</div><div style="height:200px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:relative;top:0;left:0;"></div><div style="width:70px;height:70px;background:blue;position:relative;top:-10px;left:10px;"></div></div></div><div class="panel panel-default"><div class="panel-heading">Exempel på relativ positionering för en <code>&lt;div&gt;</code> i en relativt positionerad <code>&lt;div&gt;</code></div><div style="height:130px;position:relative;" class="panel-body"><div style="width:100px;height:100px;background:red;position:relative;top:0;right:0;"><div style="width:70px;height:70px;background:blue;position:relative;top:-10px;left:10px;"></div></div></div></div><h3>Video om centrering</h3><p>Om du finner ovan lite konfunderande finns nedan en film som applicerar några av dessa metoder i praktiken.</p><p>I videon är målet att centrera en <code>&lt;div&gt;</code> horisontellt och vertikalt på sidan. Detta vilket bl.a. leder oss in på en teknik som använder sig av positionering genom <code>absolute</code>.</p><div class="panel panel-default"><div class="panel-heading">En video om horisontell &amp; vertikal centrering med css</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/GqCj_sHxzGE?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><h1>JavaScript</h1><p class="lead">Den största limitationen med HTML och CSS skulle kunna beskrivas med ett att de är ett ord &mdash; statiska. De båda språken klarar av en viss nivå av interaktivitet, men i huvudsak behöver vi någonting mycket mer dynamiskt för att kunna uppnå seriös interaktivitet. Ridån faller.. och in kommer JavaScript!</p><div class="page-header"><h2><a href="#js-intro" name="js-intro"><div class="icon-link"></div>Introduktion till JavaScript</a></h2></div><p>Om du börjar jobba med HTML och CSS kommer du snabbt upptäcka att de båda teknikerna har sina limitationer. Limitationen skulle enkelt kunna beskrivas som avsaknaden av ett ord &mdash; interaktivitet!</p><h3>Problemet</h3><p>Visst, vi kan använda HTML för att strukturera content, och visst, vi kan använda CSS för att positionera, och style:a innehållet så att det inte bara är snyggt utan även kognitivt lättillgängligt för en människa. Men hur är det egentligen med interaktiveten?</p><p>Förvisso kan vi använda pseudo-selektorn <code>:hover</code> i css för att skapa effekter när användaren låter musen rulla över länkar (såsom t.ex. understrykning). Och visst, vi kan ju genom HTML skapa olika sidor som vi sedan sammanlänkar genom hyperlänkar (<code>&lt;a&gt;</code>-taggen), vilket alltså betyder att användaren interaktivt kan navigera sig emellan dessa sidor.</p><p>Onekligen är ovan två nämnda exempel just det, exempel på interaktiviet vi kan uppnå genom HTML och CSS. Men finns det interaktivitet vi skulle vilja skapa som vi inte kan uppnå med bara HTML och CSS? Föreställ dig en delete-knapp. Föreställ dig att vi har en applikation, vilken som helst, och det finns en knapp som säger "Ta bort mitt konto". Vore det inte då rimligt att be användaren att konfirmera att denne verkligen vill ta bort sitt konto när den trycker på knappen? Självklart.</p><p>Tänk på ovan exempel en stund. Hur skulle vi lösa det genom HTML? Om vi ignorerar galna lösningar (som jag inte alls skulle rekommendera) med <code>&lt;iframe&gt;</code>'s så har vi egentligen bara ett val. Säg att knappen ligger på en sida som heter <code>delete.html</code>. När man trycker på den knappen behöver vi skicka användaren till en annan sida, vi kallar den för <code>confirm_delete.html</code> där användaren presenteras med två möjligheter till. Alltså två nya länkar till två andra sidor. Kanske är dessa länkar samma sidor som innan, kanske inte. Om inte, så har vi skapat två sidor till, nämligen: <code>yes_delete.html</code> och <code>no_delete.html</code>. Rimligen ser du vilken soppa av sidor det här snabbt blir. Och rimligen har du nu kommit på att det är här JavaScript kommer in i bilden.</p><p>Vi diskuterar nu förstås lite halvsanningar eftersom lösningen skulle kunna bli enklare med ett server-side-språk. Men lita på oss när vi säger att JavaScript kommer göra det ännu enklare.</p><p>Låt oss se till hur vi skulle kunna lösa samma sak genom JavaScript.</p><script>$(function(){
  (function(){
    var $container = $('#example-js-confirmation');
    var setup = function(){
      $container.find('a').click(function(){
        if(confirm("Do you really want to delete your account?")){
          var photo = $container.html();
          $container.html('<p style="color:red !important;">La résistance est futile...... <br><br> ALL YOUR BASE ARE BELONG TO US. <br><br> Your account is sleeping with the fishes..<br><br> <a href="#" class="btn btn-info">Oh noes, click to turn back time!</a>');
          $container.find('a').click(function(){
            $container.html(photo);
            setup();
            return false;
          });
        }
        return false;
      });
    }
    setup();
  })();
});</script><div class="panel panel-default"><div class="panel-heading">Exempel på en confirmation dialog genom JS</div><div id="example-js-confirmation" class="panel-body"><a href="#" class="btn btn-large btn-danger">Delete my account</a></div></div><p>När du provat ovan exempel, finns det en till viktig sak att inse. Interaktiveten i ovan exempel sker "isolerat" i den lilla exempelrutan. Resten av sidan påverkas inte. Slutsatsen vi drar är alltså att vi kan använda JavaScript till att uppnå en nivå av interaktivet vi omöjligen kan uppnå med endast HTML och CSS utan att använda flera sidor.</p><blockquote>Med JavaScript kan vi låta användaren interaktivt interagera med sidan utan att den behöver "laddas om".</blockquote><div class="page-header"><h2><a href="#vart-ska-jag-skriva-javascript"><div class="icon-link"></div>Vart ska jag skriva JavaScript?</a></h2></div><p>Innan vi lärt oss ett dugg om JavaScript ska vi köra en djupdyk med näsan först, och skriva vårt första skript. Samtidigt kommer vi att diskutera var vi väljer att placera vår kod och hur man bör arbeta med JavaScript.</p><h3>Ett exempelskript</h3><p>Om det enkla skriptet i nästföljande figur körs på en webbsida så tar den helt sonika bort allt dokumentet innehåller och ersätter det med texten "Evil rabbits... osv". När vi använder det här skriptet som ett exempel i detta dokument så får du låtsas som om varje exempel-ruta är en egen webbsida. För om vis kulle köra <code class="language-javascript">document.write("");</code> på hela denna sida skulle vi ju rensa hela sidan vilket skulle göra det väldigt svårt för dig att fortsätta läsa denna text.</p><div class="panel panel-default"><div class="panel-heading">Exempelskriptet</div><div class="panel-body"><pre><code class="language-javascript">document.write("Evil rabbits are taking over our servers! Must find carrots!");</code></pre></div></div><p>Hursomhelst, låt oss nu istället diskutera lite olika platser vi skulle kunna lägga in detta skript på.</p><h3>Direkt i HEAD</h3><p>Ett ställe vi kan placera vår JavaScript på är rakt upp och ner i <code>&lt;HEAD&gt;</code>-taggen. Så länge som vi snurrar in vår JavaScript emellan starttaggen <code>&lt;script&gt;</code> och sluttaggen <code>&lt;/script&gt;</code>. Nedan följer ett exempel i ett minimalistiskt HTML-dokument. När du läser exemplet, tänk framförallt på vart <code>&lt;script&gt;</code>-taggarna och ovan nämn javascript-rad är placerad/-e.</p><div class="panel panel-danger"><div class="panel-heading">JavaScript i <code>&lt;HEAD&gt;</code>-taggen</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
    &lt;script&gt;
      document.write("Evil rabbits...");
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Denna text kommer inte att synas eftersom JavaScriptet skriver över den.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">Evil rabbits...</div></div><p>För att illustrera att detta är någonting som verkligen skapas av JavaScript, så tar vi och <em>kommenterar ut</em> rad 6 såsom nedan. Att kommentera ut en rad gör att den ignoreras av webbläsaren och således inte exekveras.</p><pre data-start="6" class="line-numbers"><code class="language-javascript">// document.write("Evil rabbits...");</code></pre><p>...så får vi istället nedan resultat.</p><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body">Denna text kommer inte att synas eftersom JavaScriptet skriver över den.</div></div></div></div><h3>onClick</h3><p>Ett annat ställe vi kan placera vår JavaScript-kod på är i onClick-attributet. Som namnet <code>onClick</code> antyder kommer då koden att exekveras just då &mdash; "on click". Alltså när användaren klickar på elementet i fråga.</p><p>Låt oss se till ett exempel, som använder sig av samma kod.</p><div class="panel panel-danger"><div class="panel-heading">Anonym funktion vid onClick</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;button&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;a onClick="document.write('Evil rabbits...');"&gt;Engage descrution!&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div id="example-js-onclick" class="panel-body"><button class="btn btn-warning">Click to engage destruction!</button><script>$(function(){
  $('#example-js-onclick button').click(function(e){
    $('#example-js-onclick').text('Evil rabbits...');
    e.preventDefault();
  });
});</script></div></div></div></div><p>I ovan exempel finns det tre viktiga skillnader att notera i relation till det första exemplet. Först och främst. Vår JavaScript ligger nu inte längre inom <code>&lt;HEAD&gt;</code>-taggen utan inom <code>&lt;BODY&gt;</code>. Det betyder alltså att vi har specificerat vårt skript bland vårt content och inte vårt meta-content. Eftersom skript inte är content så borde det här ringa en varningssignal om att vi sysslar med en dålig "practice", men det återkommer vi till senare.</p><p>Den andra viktiga skillnaden vi bör inse är att vi inte längre kör vårt JavaScript när sidan laddas utan istället när användaren klickar på en knapp. Vi har alltså inte bara lagt vårt skript rakt av, utan vi har lagt det som en <em>anonym funktion</em> som kommer att köras när <em>event lyssnaren</em> <code>onClick</code> avfyras. Vi kommer att prata mer om <em>event listeners</em> senare men för nu kan du helt enkelt tänka dig det så här. Egenskapen <code>onClick</code> är ett nyckel-värde-par där värdet är en sträng. Denna sträng kommer inte att tolkas som vilken sträng som helst, utan kommer att exekveras som JavaScript. Vi hade således kunnat skriva vilken arbiträr mängd JavaScript som helst mellan de två citationstecknena som delimiterade värdet. Låt oss se till ett exempel till för att verkligen förstå hur det fungerar.</p><div class="panel panel-danger"><div class="panel-heading">Anonym funktion vid onClick</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;a onClick="alert('Hello...'); alert('...you!');"&gt;Welcome me!&lt;/a&gt;</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div id="example-js-onclick" class="panel-body"><button onClick="alert('Hello...');alert('...you!');" class="btn btn-warning">Welcome me!</button></div></div></div></div><blockquote class="text-danger">Glöm nu allt du lärt dig om att skriva inline-javascript i <code>onClick</code> och glöm nästan allt du lärt dig om att skriva JavaScript direkt i <code>&lt;head&gt;</code> &mdash; det finns bättre sätt!</blockquote><p>Som vanligt är detta bättre sätt baserat på idéen om "<a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>" och innebär att vi flyttar vår JavaScript till en separat fil. Och det är detta vi kommer göra i nästa stycke.</p><h3>JS i separat fil</h3><p>Om du inte har en medveten anledning till varför du inte ska göra det så är det bästa sättet att hantera JavsScript &mdash; i en separat fil. På precis samma sätt som vi arbetar med CSS så skapar vi en ny fil som vi döper till <code>ett-schysst-filnamn.js</code>. Notera alltså ändelsen <code>.js</code>. Sedan gör vi på precis (nästan) samma sätt som när vi har en extern CSS-fil. Alltså, vi lägger in ett element i <code>&lt;head&gt;</code> som pekar på vår JavaScript-fil. Som så:</p><div class="panel panel-success"><div class="panel-heading">Ladda in en extern javascript-fil</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre class="line-numbers"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">document.write("Oh noes evil rabbits...");</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Oh noes evil rabbits...</p></div></div></div></div><p>Notera alltså rad 5 i ovan exempel. Det är just rad 5 som berättar för webbläsaren vart JavaScript-filen finns. Vi anger .js-filens plats med en relativ sökväg genom att bara skriva <code>filnamnet.js</code> rakt upp och ned. Så webbläsaren kommer alltså leta efter en fil vid namn <code>filnamnet.js</code> i <em>samma mapp</em> som index.html ligger.</p><div class="panel panel-warning"><div class="panel-heading">Överkurs</div><div class="panel-body"><p>Kanske har du märkt att många webbutvecklare laddar in sina JavaScript-filer i <code>&lt;body&gt;</code> och inte i <code>&lt;head&gt;</code>. Detta har med performance och göra, och är egentligen en superb idé! Låt oss prata om varför.</p><p>När en webbläsare renderar en webbsida så går den uppifrån och ned. Och när den stöter på ett request till en extern resurs, såsom en bild, en css-fil, eller en javascript-fil etc. så behöver den stanna, vänta, och ladda in filen. Tänk på det en stund. När vi lägger in en bild i ett html-dokument så lägger vi ju faktiskt inte in bilden utan endast en <em>referens till den plats <code>url</code> där bilden befinner sig</em>. Detta innebär att webbläsaren alltså måste <em>hämta</em> ("ladda ner") denna bild för att faktiskt kunna visa den.</p><p>Eftersom webbläsare endast kan hantera ett limiterat antal requests parallelt så betyder det att sidan lätt fastnar i en <a href="http://en.wikipedia.org/wiki/Bottleneck">flaskhals</a>. Standarden HTTP/1.1 specificerar att en browser max bör hålla <a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">två öppna connections per server</a>, detta vilket uppenbart orsakar en flaskhals ifall vi hämtar 10 bilder, 2 css-filer och 1 javascript-fil ifrån vår egen server.</p><p>Moderna browsers har dock valt att ignorera dessa maxtal och hanterar faktiskt fler <a href="http://www.browserscope.org/?category=network&v=top">parallella uppkopplingar</a> men trots detta har det blivit praxis att låta JavaScript-filerna laddas in allra sist i <code>&lt;body&gt;</code>. Anledningen till detta är alltså att om webbläsaren får en chans att parse:a hela <code>&lt;body&gt;</code>:n innan den krockar med det element som pekar på en javascript-fil, så betyder det att webbläsaren kommer ha en chans att visuellt printa ut sidan för användaren och <em>SEN</em> börja hämta denna javascript-fil.</p><p>Faktum är att det t.o.m. är <a href="http://www.w3schools.com/js/js_howto.asp">tillåtet enligt specifikation</a> att placera <code>&lt;script&gt;</code>-taggar i <code>&lt;body&gt;</code>. Låt oss se till ett exempel över hur detta skulle kunna se ut.</p><div class="panel panel-default"><div class="panel-heading">Ladda in JavaScript-filer i slutet av <code>&lt;body&gt;</code></div><div class="panel-body"><pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Exempel&lt;/title&gt; 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Först lägger vi allt vårt content&lt;/p&gt;
    &lt;p&gt;Och sen sist, laddar vi in js:&lt;/p&gt;
    &lt;script src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></div></div><p>Således används alltså denna teknik för att ge användaren en känsla av att sidan har laddat klart snabbare än den egentligen gör. Om vi lägger våra javascript-filer i <code>&lt;head&gt;</code> kommer webbläsaren alltså att "blocka" sidan och inte printa ut någonting visuellt förrän <em>hela</em> javascript-filen har laddats ned. Men om vi lägger referensen till vår javascript fil i slutet av <code>&lt;body&gt;</code> kommer webbläsaren att rendera hela <code>&lt;body&gt;</code>:n innan den börjar blocka och ladda in javascript-filen.</p><p>Såsom mycket annat i världen så är detta inte svart eller vitt, utan det finns många fall där vi faktiskt bör ladda in JavaScript i <code>&lt;head&gt;</code>. Du kan läsa mer om detta bl.a. <a href="http://stackoverflow.com/questions/14328449/when-do-you-put-javascript-in-body-when-in-head-and-when-use-doc-load">här</a>.</p></div></div><div class="page-header"><h2><a href="#js-variabler" name="js-variabler"><div class="icon-link"></div>Variabler</a></h2></div><p>Eftersom JavaScript, som namnet antyder, är ett skriptspråk har vi tillgång till mäktiga koncept såsom variabler och funktioner. En variabel kan metaforiskt ses som en box vi lägger någonting i, och det är just denna box vi kommer att fokusera på i detta kapitel.</p><h3>Vad är variabler?</h3><p>Variabler kan ses som en arbiträr box, av arbiträr storlek, där vi kan placera ett stycke, och endast ett stycke, arbiträr data. Tänk på det en stund. Låt oss formulera om samma sak. En variabel är en pekare mot en arbiträr plats i minnet, av arbiträr storlek, som innehåller arbiträr data. Det är lite närmare sanningen men fortfarande en metafor.</p><blockquote>Variabler kan ses som en arbiträr box, av arbiträr storlek, där vi kan placera ett och endast ett stycke arbiträr data.</blockquote><p>Så hur deklarerar vi då en variabel? Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Variabeldeklaration och tilldelning</div><div class="panel-body"><pre><code class="language-javascript">var name = "Dr. Zaius";</code></pre></div></div><p>I ovan exempel deklarerar ("skapar") vi alltså en variabel och tilldelar den värdet av texten "Dr. Zaius". Således finns det alltså två saker vi gör här. Vi (1) deklarerar, och vi (2) tilldelar. Låt oss se till ett nytt exempel där vi gör dessa steg för steg.</p><div class="panel panel-default"><div class="panel-heading">Deklarering och tilldelning</div><div class="panel-body"><pre><code class="language-javascript">// Deklaration
var name;     // name =&gt; undefined
var age;      // age  =&gt; undefined
 
 // Tilldelning
name = "Dr. Zaius";   // name =&gt; "Dr. Zaius"
age = 42;             // age  =&gt; 42
 
// Deklaration och tilldelning samtidigt
var species = "Orangutang";</code></pre></div></div><p>Notera alltså att ovan exempel illustrerar att det är fullt möjligt att först deklarera en variabel och sedan tilldela den ett värde, i två steg. Detta kommer sig av den enkla anledningen att tilldelning och deklaration är två olika saker.</p><dl class="dl-horizontal"><dt>Deklaration</dt><dd>Att säga att någonting <em>existerar</em>
(<code class="language-javascript">var foo;</code>)</dd><dt>Tilldelning</dt><dd>Att säga vad någonting <em>innehåller</em>
(<code class="language-javascript">foo = "bar";</code>)</dd></dl><p>I många språk deklarerar vi variabler som olika <em>typer</em> beroende på vad för typ av innehåll vi vill kunna lagra i variabeln (text, heltalsnummer, decimaltal etc.) men i JavaScript räcker det med att vi deklarerar att variabeln <em>finns</em>. Vilken typ den sedan är av, avgörs av vad vi sedan väljer att lagra i den. JavaScript är alltså vad vi brukar kalla för ett <a href="http://sv.wikipedia.org/wiki/Typsystem">Dynamiskt typat språk</a>.</p><h3>Video</h3><p>Nedan följer en kort videointroduktion till variabler i JavaScript.</p><div class="panel panel-default"><div class="panel-heading">Videointroduktion till variabler i JavaScript</div><div class="panel-body"><iframe width="100%" height="375" src="//www.youtube.com/embed/J_XO0AzXE6Q?rel=0&amp;vq=hd1080" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div></div><h3>Datatyper</h3><p>Vad kan vi lagra? Kort sagt: vad som helst som faller under JavaScripts tre <a href="http://msdn.microsoft.com/en-us/library/ie/7wkd9z69(v=vs.94).aspx" target="_blank">datatypskategorier</a>: primära datatyper, komposit-datatyper, eller speciella datatyper. Dessa är som följer:</p><table class="table table-condensed"><tr><th>Datatyp</th><th>Förklaring</th><th>Exempel (separerade med ;)</th></tr><tr><td colspan="3" class="table-divider">Primary datatypes</td></tr><tr><td><code>number</code></td><td>Siffror</td><td><code class="language-javascript">0;   12;   -432;   11.4;   -32.4;</code></td></tr><tr><td><code>string</code></td><td>Text</td><td><code class="language-javascript">"Ekonomikum 1A";</code></td></tr><tr><td><code>boolean</code></td><td>Sant eller falskt</td><td><code class="language-javascript">true;   false;</code></td></tr><tr><td colspan="3" class="table-divider">Composite datatypes</td></tr><tr><td><code>array</code></td><td>Listor innehållandes andra datatyper</td><td><code class="language-javascript">[1, 3, 2];   ["Hello", 123];</code></td></tr><tr><td><code>object</code></td><td>Nycklar som pekar på värden</td><td><code class="language-javascript">{ title:"Dr", name:"Snuggles" }</code></td></tr><tr><td colspan="3" class="table-divider">Special datatypes</td></tr><tr><td><code>null</code></td><td>Värdet för ingenting</td><td><code class="language-javascript">null;</code></td></tr><tr><td><code>undefined</code></td><td>Värdet för avsaknaden av ett värde</td><td><code class="language-javascript">undefined;</code></td></tr></table><h3>Likhetstecknet</h3><p>Någonting som ofta är förvirrande när det kommer till programmering är att likhetstecknet (<code>=</code>) i programmering skiljer sig signifikant ifrån likhetstecknet i matematik. Likhetstecknet i matematik implicerar ekvivalens medan likhetstecknet i programmering implicerar tilldelning. Vad är då skillnaden?</p><p>Om två uttryck är ekvivalenta menar vi att vi kan ersätta det första uttrycket med det andra och det betyder samma sak. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Ekvivalens i matematik</div><div class="panel-body"><pre>(1 + 1)  =  (2)</pre>De två uttrycken, isolerade av paranteser, är ekvivalenta och vänstra ledet kan således ersättas med det högra. Detta gäller inte i programmering.</div></div><blockquote>Likhetstecknet i matematik implicerar ekvivalens medan likhetstecknet i programmering implicerar tilldelning.</blockquote><p>Men om ekvivalens inte gäller i programmering, vad gäller då istället? Jo, tilldelning. Med matematisk ekvivalens menar vi att evalueringen (resultatet av att beräkna) av det vänstra ledet är exakt samma sak som evalueringen av det högra ledet. Med tilldelning däremot, menar vi att evalueringen (resultatet av beräkningen) av det högra ledet <em>representeras</em> av det vänstra ledet.</p><p>I matematik tänker vi ofta i termer av sanning, men för att lättare förstå hur imperativ programmering fungerar kan det vara fördelaktigt att istället försöka tänka i termer av att vi "räknar ut värden och lägger de i lådor (variabler)". Boxarna har ingen aning om vart värdena kom ifrån, och värdena har ingen aning om i vilka boxar de kommer placeras.</p><p>Kanske hade det varit lättare att förstå tilldelning om syntaxen (notationen) istället hade varit <code>a &lt;= 23</code>. Alltså: lagra värdet 23 i variabeln a.</p><div class="panel panel-default"><div class="panel-heading">Tilldelning i programmering</div><div class="panel-body"><pre><code class="language-javascript">var a = 1;            // a =&gt; 1
var b = a + 3;        // b =&gt; 4
var c = a + b;        // c =&gt; 5
var d = a + b + c;    // d =&gt; 10</code></pre>Läs ovan, rad för rad, och fundera över varför det resultat som sparas i variabeln blir det som visas i kommentaren till höger.</div></div><blockquote>När vi pratar om programmering är det lättare att tänka att vi "räknar ut värden och lägger resultaten i boxar".</blockquote><div class="page-header"><h2><a href="#funktioner"><div class="icon-link"></div>Funktioner</a></h2></div><p>Nu börjar vi närma oss de signifikant mer intressanta delarna av programmering. Funktioner! Funktioner i programmering kan med fördel jämföras med funktioner i matematik. En funktion är som en maskin. En maskin där du kan stoppa in ett ting och få ut ett annat ting. Alltså en funktion (<code>F</code>) som tar emot ett ting (<code>x</code>) och returnerar ett annat ting (<code>y</code>), där detta andra ting, i matematik, kan uttryckas som en funktion applicerad på det första (<code>F(x)</code>).</p><p>PS. Vänligen anmäl oss inte till Högeskoleverket om det skulle vara så att våra matematiska metaforer är inkorrekta. Vi försöker bara använda de här för att skapa en förståelse.</p><p>Innan vi fortsätter prata om hur funktioner fungerar, låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Funktionsdefinition</div><div class="panel-body"><pre><code class="language-javascript">var addition = function(x, y){
  return x + y;
}</code></pre><p>Ovan definerar vi en funktion, som vi namnger <code>addition</code>, och som returnerar resultatet av en addition av dess två parametrar. Motsvarande funktion skulle matematiskt kunna uttryckas:</p><pre>F(x, y) = x + y</pre></div></div><p>Vi har nu sett hur man definierar en funktion. Men hur använder vi den då? Låt oss återigen se till några exempel.</p><div class="panel panel-default"><div class="panel-heading">Funktionsanrop</div><div class="panel-body"><pre><code class="language-javascript">// Först definierar vi en funktion
var addition = function(x, y){
  return x + y;
}
 
// Sen anropar vi funktionen
addition(1, 1);                         // =&gt; 2
addition(30, 5);                        // =&gt; 35
addition(addition(1,2), 4)              // =&gt; 7
addition(addition(1,addition(1,1)), 4)  // =&gt; 7</code></pre><p>Låt oss uttrycka samma sak i matematik för att skapa ytterligare förståelse för vad vi gör:</p><pre><code>Först definierar vi funktionen...
F(x, y) = x + y
 
Sen använder vi den...
         F(1, 1) = 2
        F(30, 5) = 35
    F(F(1,2), 4) = 7
F(F(1,F(1,1), 4) = 7</code></pre></div></div><p>Notera alltså att vi kan skicka resultatet av en funktion som parameter (input) till en annan funktion. Precis som i matematik så måste den innersta beräkningen utföras först innan vi kan utföra den yttre.</p><blockquote>Precis som i matematik behöver det innersta uttrycket räknas ut först innan vi kan fortsätta "utåt".</blockquote><h3>Olika sätt att deklarera funktioner</h3><p>Eftersom JavaScript på gott och ont är väldigt flexibelt finns det olika sätt att deklarera funktioner.</p><h4>Function statement</h4><p>Detta är det klassiska sättet att deklarera funktioner i JavaScript.</p><pre><code class="language-javascript">function myFunc(){ //work };</code></pre><p>Denna metod gör att funktionsnamnet är tillgängligt i hela sitt scope. Även innan den är deklarerad.</p><pre><code class="language-javascript">console.log(myFunc());  // => Hello
function myFunc(){ return "Hello" };</code></pre><h4>Function expression</h4><p>Detta sätt att deklarera kan ses som att vi tilldelar en anonym funktion till en variabel.</p><pre><code class="language-javascript">var myFunc = function(){ //work };</code></pre><p>När vi deklarerar en funktion så här så är den inte tillgänglig före deklarationen, endast efter.</p><pre><code class="language-javascript">console.log(myFunc()); // => TypeError
var myFunc = function(){ return "Hello" };</code></pre><h4>Kombination</h4><p>Vi kan även kombinera ovan två metoder som så:</p><pre><code class="language-javascript">var myFunc = function myFunc(){ // work };</code></pre><h4>Vilket sätt bör vi använda?</h4><p>Så, istället för att gräva ned oss i vilket sätt man bör använda så föreslår vi att du följer <a href="http://www.unicodegirl.com/function-statement-versus-function-expression.html">Douglas Crockford's rekommendation</a> om att använda function expressions. Alltså:</p><pre><code class="language-javascript">var myFunc = function(){ //work };</code></pre><blockquote class="text-info">Välj function expressions över function statements, tills den dag kommer du då intresserar dig av att lära dig varför.</blockquote><div class="page-header"><h2><a href="#DOM"><div class="icon-link"></div>Document Object Model</a></h2></div><p>Document Object Model(DOM) är ett API för HTML och XML dokument. Den definierar den logiska strukturen och hur man kommer åt ett dokument och manipulerar det. </p><h3>Javascript och DOM </h3><p>Med denna modell kan vi nu med hjälp av Javascript kunna modifiera trädet och skapa dynamiska hemsidor. Det handlar alltså om att vi kan ta bort, komma åt, modifiera och lägga till element.</p><h3>Document</h3><p>Document är ett objekt som "Äger" alla andra objekt, med det menas att utifall du vill komma åt andra objekt i DOM:en görs detta genom <code> document.method()</code>. </p><table class="table table-condensed"><tr><th>Metod</th><th>Förklaring</th></tr><tr><td colspan="3" class="table-divider">Hitta element</td></tr><tr><td><code>document.getElementById()</code></td><td>Hämtar ett element med hjälp av dess ID </td></tr><tr></tr><tr><td><code>document.getElementsByTagName()</code></td><td>Hämtar alla element med hjälp av dess tagnamn </td></tr><tr></tr><tr><td><code>document.getElementsByClassName()</code></td><td>Hämtar ett element med hjälp av dess klassnamn</td></tr></table><h3>Element</h3><p>När vi hämtar ett element ur DOM:en genom någon av de metoder som diskuterades ovan, så kan vi sedan läsa och skriva information till det elementet. Ett element är alltså bara ännu ett objekt med ett antal egenskaper och metoder. Med andra ord kan vi inte bara läsa ifrån DOM:en, utan vi kan även förändra den. Nedan ser du några exempel på vad vi kan göra med ett element</p><table class="table table-condensed"><tr><td colspan="3" class="table-divider">Antag att vi har ett element i variabeln elem</td></tr><tr><td><code>elem.innerHTML</code></td><td>Ändrar den inre HTML:en av ett element</td></tr><tr><td><code>elem.attribute</code></td><td>Ändrar ett elements attribut.</td></tr><tr><td><code> elem.style</code></td><td>Ett objekt som vi kan läsa/skriva css från/till</td></tr></table><h3>Exempel</h3><p>Låt oss se till ett par exempel på hur vi kan manipulera DOM:en.</p><div class="panel panel-default"><div class="panel-heading">Exempel på att gömma ett element.</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="secret"&gt; LYSSNA PÅ MIG! &lt;/p&gt; </code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var p = document.getElementById("secret");
p.style.display = "none";</code></pre></div></div></div></div><p>Vad vi gör ovan är alltså helt enkelt att vi först hämtar elementet med hjälp av dess ID. Sedan hämtar vi <code>style</code>-objektet på elementet. På <code>style</code>-elementet sätter vi egenskapen <code>display</code> till värdet <code>none</code>. JavaScriptkoden skulle kunna komprimeras till att skrivas på en enda rad, vet du hur?</p><div class="panel panel-default"><div class="panel-heading">Exempel på att hämta med tagnamn.</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt; A &lt;/p&gt;
&lt;p&gt; B &lt;/p&gt;
&lt;p&gt; C &lt;/p&gt;
&lt;p&gt; D &lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript"> var as = menu.getElementsByTagName('p');  
 as[0].innerHTML = "Ett";
 as[1].innerHTML = "Två";
 as[3].innerHTML = as[1].innerHTML;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>Ett</p><p>Två</p><p>C</p><p>Två</p></div></div></div></div><p>Ok, nu kanske det krävs en liten förklaring. Om vi som i första exemplet hämtar med id då vet vi att vi endast får ett objekt tillbaka. I andra exemplet ovan ber vi om objekten med hjälp av tagnamnet och därför returneras dessa i en array. Med andra ord: när vi hämtar ett element genom ett ID kan vi alltid vara hundra på att det bara finns ett (eftersom ett ID endast får förekomma en gång i ett HTML-dokument). Men när vi söker element via tagnamn så kan vi omöjligen veta hur många instanser det finns av just den taggen. Således har man valt att låta <code>getElementsByTagName</code> returnera en array. Således är det även därför vi ovan använder bracket-notationen (<code>[x]</code>) för att arbeta med resultatet.</p><blockquote class="text-warning">Se till att du förstår varför outputen i exemplet ovan blir som den blir innan du går vidare</blockquote><h3>onload</h3><p>När vi skriver JavaScript som på något sätt interagerar med DOM:en, är det viktigt att vi är säkra på att DOM:en är redo (inladdad) innan vi börjar försöka nå den. Detta gör vi enkelt genom att använda oss av metoden <code>onload</code>.</p><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi använder onload.</div><div class="panel-body"><pre><code class="language-javascript">window.onload = function(){
  // do all fancy work here
}</code></pre></div></div><p>Varför gör vi alltså detta? Jo, om vi inte skulle göra det så finns alltså risken för att de element vi försöker komma åt inom funktionskroppen i ovan exempel ännu inte finns.</p><p>Ovan kan förstås lika gärna göras i två steg, genom att registrera en redan deklarerad funktion.</p><div class="panel panel-default"><div class="panel-heading">Exempel på hur vi använder onload.</div><div class="panel-body"><pre><code class="language-javascript">// Declare the init function
var init = function(){
}
 
// Register it as a listener to the onload event
window.onload = init;</code></pre></div></div><p>Vad vi har gjort nu kallas mer generellt för att registrera en funktion (en <code>event handler</code>) till ett <code>event</code>. Mer om detta i avsnittet om events.</p><div class="page-header"><h2><a href="#event-listners"><div class="icon-link"></div>Event listeners</a></h2></div><p>Nästa ämne vi ska prata om är eventlyssnare. Något som finns i många programmeringsspråk och som ofta beteer sig liknande, om än med olika syntax. För att förstå event listeners, fundera över följande: hur vet vi att en användare har klickat på en knapp?</p><p>Mer generellt uttryckt: Event listeners hjälper oss att exekvera specifik kod vid en specifik händelse. Det kan tyckas trivialt. Men tänk på när vi skriver ett program. Om vi inte hade events skulle hela programmet endast kunna köras i ett svep (rufft uttryckt). Programmet börjar exekveras, och oavsett hur mycket klasser och funktioner vi använder så kommer programmet att köras ifrån början till slut. Med events så kan vi däremot registrera vad som kallas för <code>lyssnare</code>. Programmets exekvering "fryser" inte. Programmet stannar alltså inte när vi registrerar en event listener utan fortsätter exekvera som vanligt. När den händelse som eventlyssnaren lyssnar efter (exempelvis en knapptryckning) händer så exekveras koden lyssnaren pekar på. Detta kallas ofta för <a href="http://en.wikipedia.org/wiki/Event-driven_programming">event-driven programming</a>.</p><p>Vi ska i det här kapitlet prata om metoden <code>addEventListener()</code>, men för att enklare förstå hur de fungerar behöver vi först prata om vad det betyder att JavaScript har en <code>Asynkron Event Model</code>. Beakta följande kodexempel:</p><div class="panel panel-default"><div class="panel-heading">Exempel på asynkron exekvering i JavaScript</div><div class="panel-body"><pre><code class="language-javascript">console.log("a");
 
 
// setTimeout är en funktion som kör en annan
// funktion efter en given väntetid i millisekunder
 
setTimeout(function(){
  console.log("b");
}, 1000)
 
 
console.log("c");</code></pre><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><p>a</p><p>c</p><p>b</p></div></div></div></div><p>Hur kan det komma sig att vi fick outputen i ovan ordning? Detta har alltså att göra med den asynkrona event modellen i JavaScript. Den funktion som körs av <code>setTimeout</code> körs inte förrän väntetiden på <code>1000 ms</code> har passerat. Men, eftersom JavaScript har asynkrona event, så registreras denna funktion som ett event. Således kommer programmet fortsätta att exekvera. När tiden sedan gått ut, och event-loopen är "ledig" så exekveras den givna funktionen.</p><p>Om <code>setTimeout</code> hade varit en synkron metod hade exekveringen avstannat ("fryst") vid anropet till <code>setTimeout</code>, och inte fortsatt förrän väntetiden passerat.</p><div class="panel panel-info"><div class="panel-heading">Kuriosa</div><div class="panel-body"><p>Även om vi hade satt timeout-tiden ovan till 0ms så hade vi fått samma output. Varför? Jo, för att även om väntetiden för <code>setTimeout</code> är 0 så registrerar den funktionen till event-loopen utan att exekvera den på en gång. Således kan den givna funktionen inte exekveras förrän nästa lediga "tick" i event-loopen.</p></div></div><p>Varför är detta då viktigt? Jo, detta gäller alltså även för när vi registrerar event-lyssnare.</p><h3>addEventListener</h3><p>Istället för att gräva ned oss i mer teori, låt oss kolla på ett exempel kring hur vi kan använda <a href="p Varför är detta då viktigt? Jo, detta gäller alltså även för när vi registrerar event-lyssnare.">addEventListener</a>.</p><div class="panel panel-default"><div class="panel-heading">Exempel på asynkron exekvering i JavaScript</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="eventlistener-example-1"&gt;
  hello
&lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var tag = document.getElementById('eventlistener-example-1');
tag.addEventListener("click", function(){
  if(tag.innerHTML == "hello")
    tag.innerHTML = "world";
  else
    tag.innerHTML = "hello";
});</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat (prova att klicka på texten!)</div><div class="panel-body"><p id="eventlistener-example-1">hello</p></div></div></div></div><script>var tag = document.getElementById('eventlistener-example-1');
tag.addEventListener("click", function(){
  if(tag.innerHTML == "hello")
    tag.innerHTML = "world";
  else
    tag.innerHTML = "hello";
});</script><h4>Webbläsarstöd</h4><p>Nu är en bra tid att prata om webbläsarstöd. Äldre webbläsare stödjer inte metoden addEventListener, så om ovan exempel inte fungerar för dig så betyder det att din webbläsare är för gammal. Internet Explorer, tidigare och upp till, 8 har en alternativ implementation där metoden heter <code>attachEvent</code>. Så för att ovan exempel även ska fungera i Internet Explorer 8 behöver vi välja vilken metod vi använder berodende på vilken som finns. Läs mer om det i denna tråd på <a href="http://stackoverflow.com/questions/6927637/addeventlistener-in-internet-explorer">Stack Overflow</a>.</p><h4>Återanvändbara event handlers</h4><p>Den funktion som körs när ett event avfyras, kallas för en <code>event handler</code>. Självklart hade vi ju kunnat skriva denna event handler som en function declaration eller function expression istället för att bara skriva den inline. Detta är bra eftersom vi då kan återanvända beteende. Såsom nedan:</p><div class="panel panel-default"><div class="panel-heading">Exempel på användning av addEventListener</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="eventlistener-example-2"&gt;
  hello
&lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var onClick = function(element){
  if(element.target.innerHTML == "hello")
    element.target.innerHTML = "world";
  else
    element.target.innerHTML = "hello";
}
 
document.getElementById('eventlistener-example-2-1').addEventListener('click', onClick);
document.getElementById('eventlistener-example-2-2').addEventListener('click', onClick);</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat (prova att klicka på olika texterna!)</div><div class="panel-body"><p id="eventlistener-example-2-1">hello</p><p id="eventlistener-example-2-2">world</p></div></div></div></div><script>var onClick = function(element){
  if(element.target.innerHTML == "hello")
    element.target.innerHTML = "world";
  else
    element.target.innerHTML = "hello";
}
document.getElementById('eventlistener-example-2-1').addEventListener('click', onClick);
document.getElementById('eventlistener-example-2-2').addEventListener('click', onClick);</script><p>Styrkan i ovan exempel är ju alltså att vi nu kan återanvända vår eventhandler och attacha den till flera olika events. En annan lärdom vi kan dra av ovan exempel är att eventhandlers anropas med argument. Detta kan vi använda för att upptäcka vilket element som faktiskt har avfyrat eventet.</p><!-- TODO: Need to write more about event handler arguments--><!-- TODO: Need to write about event--><div class="page-header"><h2><a href="#objekt"><div class="icon-link"></div>Objekt</a></h2></div><p>JavaScript är inte ett <a href="http://sv.wikipedia.org/wiki/Objektorienterad_programmering">objektorienterat</a> språk i den klassiska bemärkelsen utan istället ett <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototypbaserat</a> språk. Vad detta innebär kommer vi inte fokusera på i denna sektion, och därmed kommer vi inte syssla med instansiering. Istället kommer vi använda objekt som ett sätt att organisera vår kod.</p><h3>Vad är ett objekt?</h3><p>Om du programmerat i ett tidigare språk så kan du jämföra JavaScript-objekt med <code>map</code>'s eller <code>dictionary</code>'s. Om du inte har programmerat tidgare så kan du jämföra objekt med uppslagsverk. Va? Jo, precis så! Helt vanliga gamla bokuppslagsverk. Vänta nu? Va? Jo men tänk dig. Hur fungerar ett uppslagsverk. Om jag undrar vad ordet "katt" betyder så tar jag mitt fysiska uppslagsverk (objektet) och börjar leta efter uppslagsordet "katt" (nyckeln), och när jag väl hittat det så läser jag beskrivningen av vad en katt är (värdet).</p><p>Låt oss analysera de tre nyckelorden vi identifierat i ovan stycke.</p><dl class="dl-horizontal"><dt>Objekt</dt><dd>En datatyp som innehåller en kollektion av nycklar som pekar på värden (nyckel-värde-par)</dd><dt>Nyckel</dt><dd>En unik identifierare, såsom "namn", eller "nummer".</dd><dt>Värde</dt><dd>Ett värde kan vara av vilken annan datatyp som helst. Ett värde kan således vara 1 såväl som 32 såväl som "Kapten Haddock" såväl som ett annat objekt.</dd></dl><p>Innan vi snurrar vidare är det nog bäst att vi börjar undersöka syntaxen vi använder för att skapa objekt och således diskutera ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Object literals</div><div class="panel-body"><pre><code class="language-javascript">var haddock = {
  name : 'Kapten Haddock',
  beard: 'black as the night',
  rank: 1
}</code></pre><p>Nu har vi skapat ett objekt och lagrat det i variabeln <code>haddock</code>. Låt oss nu se hur vi kan interagera med objektet.</p><pre><code class="language-javascript">haddock.name;         // =&gt; "Haddock"
haddock.rank;         // =&gt; 1
haddock.beard;        // =&gt; "black as the night"
haddock.weapon;       // =&gt; undefined</code></pre><p>Vi kan nu alltså använda <em>punkt-notation</em> för att nå de värden som gömmer sig bakom ett objekts nycklar. Men faktum är att vi även kan nå värdena genom att använda samma notation vi använder för att nå värdena i en array. Enda skillnaden är att vi istället för att be om en arrays numeriska index ber vi om värdet bakom en viss nyckel. Låt oss se till ett exempel, och tänk på att det är exakt samma objekt som vi arbetar med i båda dessa två exempel.</p><pre><code class="language-javascript">haddock['name'];         // =&gt; 'Haddock'
haddock['rank'];         // =&gt; 1
haddock['beard'];        // =&gt; "black as the night"
haddock['vegetables'];   // =&gt; undefined</code></pre></div></div><div class="panel panel-warning"><div class="panel-heading">Överkurs</div><div class="panel-body"><p>Om vi jämför de två olika sätten att nå ett objekts värden märker vi snabbt att vi i det första exemplet skriver nyckelns namn rakt av, medan vi i det andra exemplet skriver nyckeln i formen av en sträng. Det betyder att vi skulle kunna byta ut denna <em>sträng</em> emot ett <em>uttryck</em>. Alltså en variabel, eller t.o.m. en funktion! Låt oss prova:</p><pre><code class="language-javascript">var prop = 'name';
haddock[prop];        // =&gt; 'Haddock'
prop = 'rank'
haddock[prop];        // =&gt; 1
prop = 'beard'
haddock[prop];        // =&gt; "black as the night"
prop = 'fruit'
haddock[prop];        // =&gt; undefined</code></pre><p>Beroende på vilket värde vi lägger i variabeln hämtar vi värdena vid olika nycklar. Men om det är så att vi inom klammrarna kan ha ett uttryck vilket som helst så skulle vi ju förstås kunna göra ännu galnare grejer.</p><pre><code class="language-javascript">haddock['na' + 'me'];     // =&gt; 'Haddock'
prop = 'na';
haddock[prop + 'na'];     // =&gt; 'Haddock'
 
// eller vad sägs om funktioner..
function getKey(){
  return 'name'
}
haddock[getKey()];        // =&gt; 'Haddock'</code></pre></div></div><h1>Open source</h1><p class="lead">Mycket av världens mjukvara drivs av open source. Alltså mjukvara vars källkod är öppen för allmänheten. Men vad är egentligen open source? Hur kan vi använda det? Hur kan vi bidra?</p><div class="page-header"><h2><a href="#open-source"><div class="icon-link"></div>Open Source</a></h2></div><p>Open-source, eller öppen källkod på svenska, är idéen om att lämna ut sin källkod till allmänheten så att vemsomhelst kan använda, modifiera eller bygga vidare på den. Idag är det nästan omöjligt att surfa omkring på internet utan att använda sådant som del- eller helvis står på axlarna av open-source.</p><p>Ett par exempel på lösningar som är drivna med öppen källkod är bloggmotorn <a href="http://sv.wikipedia.org/wiki/Wordpress">WordPress</a>, operativsystemet <a href="http://sv.wikipedia.org/wiki/Linux">Linux</a>, webbservern <a href="http://sv.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a> och databashanteraren <a href="http://sv.wikipedia.org/wiki/MySQL">MySQL</a>.</p><p>Om man ska diskutera de projekt som storskaligt verkligen haft influens på hur vi webbutvecklar är det nästan hädelse att inte nämna <a href="http://jquery.com">jQuery</a>. JavaScript-biblioteket med stort B, som hjälper oss att göra allt ifrån <a href="http://api.jquery.com/animate/">animation</a>, <a href="http://api.jquery.com/each/">iteration</a>, <a href="http://api.jquery.com/jQuery.post/">ajax</a> och att fånga <a href="http://api.jquery.com/category/events/keyboard-events/">tangentbordstryckningar</a>.</p><h1>jQuery</h1><p class="lead">Att koda JavaScript är en fröjd i många avseenden, men framförallt för att språket genomsyras av en fantastisk open-source-kultur där en multitud av problem redan är lösta. I den här sektionen pratar vi lite om open-source och js-bibliotek generellt. Men framförallt ska vi lära oss att skaka fram webbläsareffekter som en annan jQuery-Houdini. <code>slideIn(); fadeOut();</code></p><div class="page-header"><h2><a href="#jquery-snabbstart"><div class="icon-link"></div>jQuery snabbstart</a></h2></div><p><a href="http://jquery.com/">jQuery</a> är verkligen JavaScript-biblioteket med stort B. Biblioteket hjälper oss att göra allt ifrån <a href="http://api.jquery.com/animate/">animation</a>, <a href="http://api.jquery.com/each/">iteration</a>, till att bygga <a href="http://en.wikipedia.org/wiki/Single-page_application">one-pagers</a> som använder <a href="http://api.jquery.com/jQuery.post/">ajax</a> för att ladda in data, eller att bygga tangentbordsvänliga applikationer genom att fånga <a href="http://api.jquery.com/category/events/keyboard-events/">tangentbordstryckningar</a>. I detta kapitel ska vi dyka rakt in i och börja använda jQuery, utan att fundera särskilt mycket över varför saker fungerar som de fungerar.</p><h3>jQuery är ett bibliotek</h3><p>jQuery är ju alltså ett JavaScript-bibliotek. Ett bibliotek kan, oavsett språk, ses som någonting som utökar det språk vi skriver i för att underlätta vissa aktiviteter.</p><p>Säg att vi t.ex. ofta utför aktivitet <code>A</code>, <code>B</code> och <code>C</code> i följd. Någonting ett bibliotek ofta gör är då att t.ex. ge oss ett nytt namn &mdash; säg <code>Z</code>, vilket vi kan använda för att utföra alla tre aktiviteter samtidigt.</p><p>Ett bibliotek består då alltså av kod, i detta fall kod skriven i JavaScript. Så, för att kunna använda jQuery behöver vi "koppla in" jQuery i våra egna dokument. Låt oss uttrycka oss mer specifikt. Hela jQuery-biblioteket behöver laddas in på varje .html-sida som ska använda jQuery, innan vi försöker använda det.</p><h3>Ladda in jQuery</h3><p>Att ladda in jQuery är enkelt. Hela biblioteket får plats i fil. Vi har två alternativ. Antingen kan vi...</p><ol><li>Kopiera hela biblioteket, eller <a href="http://jquery.com/download/">ladda ned filen</a>, och spara filen i mappen som innehåller vår webbsida, eller..</li><li>Låta våra html-sidor ladda ned jQuery via internet ifrån vad som kallas för en <a href="http://en.wikipedia.org/wiki/Content_delivery_network">CDN</a>.</li></ol><p>För enkelhetens skull kommer vi att arbeta med det senare alternativet. Detta gör vi helt enkelt genom att placera följande script-element i vår .html-fil:</p><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre><code class="language-markup">&lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt;</code></pre></div></div><h3>Ladda in en fil som använder jQuery</h3><p>Så, nu har vi jQuery tillgängligt i vårt dokument. Men efter detta behöver vi ladda in en till JavaScript-fil där vi faktiskt <em>använder</em> jQuery. Låt oss alltså skapa en till .js-fil och ladda in den direkt efter som så:</p><div class="panel panel-default"><div class="panel-heading">index.html</div><div class="panel-body"><pre><code class="language-markup">&lt;script src="main.js"&gt;&lt;/script&gt;</code></pre></div></div><h3>Använda jQuery</h3><p>Låt oss nu faktiskt använda jQuery till att göra någonting. Vi fortsätter alltså skriva kod i filen <code>main.js</code>. Följande kod kommer att vänta tills <a href="http://sv.wikipedia.org/wiki/Document_Object_Model">DOM</a>:en (alltså HTML-trädet) har laddats in av webbläsaren, och sedan "poppa" up en alert-ruta. Prova att klistra in koden i <code>main.js</code> och ladda om din html-sida.</p><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">$(function(){
  alert("Hello from jQuery");
});</code></pre></div></div><p>Tada!! Vi har nu använt oss av biblioteket jQuery. Låt oss prova någonting annat. Följande kod identifierar alla länkar (<code>&lt;a&gt;</code>-taggar) på din html-sida. Inaktiverar deras vanliga funktionalitet, och gör istället så att de klistrar in bilder på en massa fantastiska katter varje gång du klickar. Tänk på att du alltså behöver lägga in länkar i din html-sida för att nedan kod ska ha någon effekt. Annars har vi ju inga länkar att klicka på.</p><div class="panel panel-default"><div class="panel-heading">main.js</div><div class="panel-body"><pre><code class="language-javascript">$(function(){
  var randomNum = function(){
    return Math.floor(Math.random()*101);
  }
 
  $('a').click(function(){
    e.preventDefault();
    var size = 75 + randomNum(),
    x = randomNum() + '%',
    y = randomNum() + '%',
 
    $img = $('&lt;img/&gt;');
    $img.attr('src', 'http://placekitten.com/'+size+'/'+size);
    $img.css({
      'position': 'fixed',
      'left'    : x,
      'top'     : y
    });
 
    $('body').append($img);
  });
});</code></pre></div></div><p>Om du inte själv har valt att implementera den fantastiska jQuery-koden ovan så kan du få en sneak-peak på vilken underbar värld som väntar genom att prova exemplet nedan!</p><div class="panel panel-default"><div class="panel-heading">Resultat (prova!)</div><div class="panel-body"><p><a class="btn btn-large btn-success jquery-intro-example-1">All your base!</a></p><p><a class="btn btn-large btn-danger jquery-intro-example-2">Reset (you will need it I promise);</a></p><script>$(function(){
 (function(){
   $('.jquery-intro-example-2').click(function(e){
     $('.jquery-intro-example-1-output').remove();
   });
   $('.jquery-intro-example-1').click(function(e){
     e.preventDefault();
     var randomNum = function(){
       return Math.floor(Math.random()*101);
     }
 
     var size = 75 + randomNum(),
     x = randomNum() + '%',
     y = randomNum() + '%',
 
     $img = $('<img/>');
     $img.attr('src', 'http://placekitten.com/'+size+'/'+size);
     $img.addClass('jquery-intro-example-1-output');
     $img.css({
       'position': 'fixed',
       'left'    : x,
       'top'     : y
     });
     
     $('body').append($img);
   });
 })();
});</script></div></div><p>Svårare än så är det inte! Så, när du använder jQuery behöver du helt enkelt komma ihåg tre saker.</p><ol><li>Se till att du laddar in jQuery-biblioteket.</li><li>Se till att din kod som använder jQuery laddas in efter själva biblioteket.</li><li>Se till att den kod som använder jQuery ligger inom <code class="language-javascript">$(document).ready(function(){ /* din kod här */ });</code>.</li></ol><p>Sedan är det bara att tuta och köra!</p><div class="panel panel-info"><div class="panel-heading">Tips!</div><div class="panel-body"><p>Ett kortare sätt att skriva..</p><pre><code class="language-javascript">$(document).ready(function(){
  /* din kod här */
});</code></pre><p>...är att skriva så här...</p><pre><code class="language-javascript">$(function(){
  // din kod här... 
});</code></pre><p>Båda sätten ger samma resultat.</p></div></div><div class="page-header"><h2><a href="#documentready"><div class="icon-link"></div>$(document).ready</a></h2></div><p>I vår första djupdykning in i jQuery pratade vi kort om att det är viktigt att vänta tills hela DOM:en är inladdad innan vi börjar exekvera vår jQuery-beroende kod. I det här kapitlet kollar vi närmare på hur just <code>.ready()</code>-funktionen fungerar. Detta kapitel hjälper dig att skapa en djupare förståelse för både jQuery såväl som JavaScript.</p><h3>När dokumentet är redo för manipulation</h3><p>Denna mystiska ovan nämnda metod vid namn <code>.ready()</code> är en metod vi använder för att kunna vänta med att exekvera jQuery-kod tills webbläsaren har hunnit ladda in ("ned") hela sidan. Låt oss först se till ett exempel och sen diskutera det:</p><div class="panel panel-default"><div class="panel-heading">Att säga åt jQuery att vänta tills DOM:en är inläst</div><div class="panel-body"><pre><code class="language-javascript">$(document).ready(function(){
  alert("Hello world from jQuery");
});</code></pre></div></div><p>Ovan exempel använder jQuery för att avvakta tills webbläsaren har laddat in hela sidan. Sedan använder vi helt vanlig JavaScript för att poppa up en alert-ruta med meddelandet "Hello world...". Låt oss dissekera ovan kod, rad för rad och del för del, för att faktiskt förstå vad det är som händer.</p><h4>$() är syntaktiskt socker för jQuery()</h4><p>Först ut är detta mystiska dollartecken. Förklaringen till vad detta <em>är</em>, är egentligen ganska enkel. Förklaringen till varför vi <em>använder</em> tecknet inte lika. Men låt oss först diskutera vad det är. <code>$</code>-tecknet är egentligen ingenting annat än <a href="http://sv.wikipedia.org/wiki/Syntaktiskt_socker">syntaktiskt socker</a>. Alltså ett annat sätt att skriva någonting. Detta någonting är jQuery's huvudmetod med samma namn, alltså <code>jQuery</code>. Så, när vi med andra ord säger <code class="language-javascript">$(document)</code> är det <em>exakt samma sak</em> som när vi säger <code class="language-javascript">jQuery(document)</code>. Det förstnämnda är helt enkelt bara ett kortare sätt att uttrycka det på för att vi som programmerare ska slippa skriva så mycket.</p><h4>Variabeln document är dokumentets rot</h4><p><code>document</code> är helt enkelt en <em>variabel</em>. Men notera här alltså att vi säger att document är en variabel, vi säger inte att det är ett keyword. Varför är det viktigt att tänka på? Jo, <code>var</code> är ett keyword, en <a href="http://en.wikipedia.org/wiki/Language_construct">language construct</a> som alltid finns i JavaScript oavsett vart vi kör språket. Variabeln window är däremot ett koncept som är uppfunnit sonika för browsers. Om vi kör en JavaScript-interpretator i en <a href="http://en.wikipedia.org/wiki/Bash_(Unix_shell)">terminal</a> (alltså inte en browser) så existerar inte variabeln <code>document</code>. I browsern däremot, för att överhuvudtaget kunna manipulera en webbsida, behöver vi något sätt att genom javascript komma åt noderna (elementen) i vårt HTML-dokument. Således är <code>document</code>, löst uttryckt, vår "entry-point" in till noderna i html-dokumentet. I variabeln <code>document</code> hittar vi elementet <code>&lt;html&gt;</code> och som barn till det elementet hittar vi förstås resten av noderna. För att sammanfatta så är alltså <code>document</code> den variabel som innehåller hela vårt html-dokument och således den variabel vi behöver interagera med för att manipulera vårt dokument.</p><h4>$(document) eller jQuery(document)</h4><p>Nu vet vi alltså att <code>$()</code> är en korthandssyntax, och således samma sak som att anropa <code>jQuery()</code>. Men vad gör då denna metod? Jo, metoden returnerar ett jQuery-objekt som innehåller det vi har skickat in till den. Vi kan alltså se det som att jQuery <em>dekorerar</em> det vi har skickat in med alla dessa fantastiska jQuery-metoder. Låt oss exemplifiera.</p><pre><code class="language-javascript">// Dekorerar alla länkar med jquery
// Sparar referensen i variabeln link
var link = $('a');</code></pre><p>Vi använder alltså denna "jquery-dekorerade version" av ett html-element för att anropa de fantastiska metoder jquery utökar våra element med. Låt oss exemplifiera.</p><pre><code class="language-javascript">// Fade:a ut alla länkar
$('a').fadeOut();
 
// Samma sak i två steg
var link = $('a');
link.fadeOut();</code></pre><p>Det kan snabbt bli virrigt gällande vilka variabler som är jquery-dekorerade och vilka som inte är det. <a href="http://en.wikipedia.org/wiki/Coding_conventions">Konventionen</a> brukar således vara döpa sina variabler med ett initial <code>$</code>-tecken. Som så:</p><pre><code class="language-javascript">// Konventionen är att döpa jquery variabler med ett intialt $-tecken
var $link = $('a');</code></pre><p>För att återgå till det här med <code class="language-javascript">$(document)</code>. Vad betyder det då alltså att skicka in dokumentet till jquerys dekorationsmetod? Jo att vi nu kan anropa alla de fantastiska metoderna jquery erbjuder på vår rotnod. Det vill säga hela dokumentet. Att dekorera dokumentet med jquery har egentligen exakt samma effekt som att dekorera ett enskilt element (t.ex. en länk).</p><h4>För att veta när dokumentet är redo använder vi .ready()</h4><p>Precis som rubriken säger så använder vi metoden för att helt enkelt veta när dokumentet (DOM:en) är färdigladdat. Tänk efter. Eftersom vi använder jQuery-metoden för att dekorera element i vårt dokument. Så är det viktigt att alla element är "konstruerade" innan vi försöker komma åt dem. Hur ska vi kunna hitta alla länkar om vi inte är säker på att webbläsaren har hunnit läsa in alla länkar?</p><p>Vi kan använda <a href="http://learn.jquery.com/using-jquery-core/document-ready/">.ready()</a>-metoden, men vi kan också använda <a href="http://api.jquery.com/load/">.load()</a>-metoden. Den första nöjer sig med att <a href="http://sv.wikipedia.org/wiki/Document_Object_Model">DOM</a>:en (vilket kan ses som dokumentets struktur) har laddat. Den senare väntar på att alla resurser såsom bilder o.s.v. har laddat.</p><h4>Funktionen skickad till ready körs när dokumentet är redo</h4><p>Så vad ska vi skicka som argument till denna funktion? Jo, en till funktion! Va? Vääänta nu. En funktion som tar en funktion som argument? Det låter ju helknäppt. Men det är faktiskt inte så knäppt. Faktum är att mycket kod vi skriver i JavaScript går ut på att just skicka funktioner till funktioner. För att kunna skapa <a href="http://en.wikipedia.org/wiki/Callback_(computer_programming)">"callbacks"</a>. Den funktion vi skickar till <code>.ready()</code>-funktionen kan ses som ett callback som körs när dokumentet har laddat.</p><p>Tänk dig.. vi anropar jquery ready-metoden, och säger "Hej, nu vill jag att du säger till mig när sidans DOM har laddat klart". Sedan skickar vi in en funktion till ready-metoden och då är det som att vi säger "..och när sidans DOM har laddat klart, då vill jag att du utför allt som står i den här andra funktionen". Inga konstigheter!</p><h4>Allt i ett svep</h4><p>Så, låt oss repetera den kod vi pratar om i helhet.</p><pre class="line-numbers"><code class="language-javascript">$(document).ready(function(){
  alert("Hello world from jQuery");
});</code></pre><p>Låt oss beskriva koden i ord, rad för rad.</p><ol><li>Skapa ett <code>jQuery</code>-objekt av innehållet i variabeln <code>document</code>. Anropa sedan funktionen <code>ready()</code> på det jquery-dekorerade dokumentet. Skicka en <em>anonym funktion</em> som argument.</li><li>Låt den anonyma funktionen innehålla en enda rad. Denna rad anropar JavaScript-funktionen <code>alert()</code>, med strängen "Hello world.." som argument, och kommer således att visa göra så att alert-ruta "poppar upp" med texten "Hello world..".</li><li>Stäng den anonyma funktionen med <code>}</code>. Stäng sedan funktionsanropet med <code>)</code>. Terminera raden med <code>;</code>.</li></ol><div class="page-header"><h2><a href="#jqueryobjects" name="objektet-jquery"><div class="icon-link"></div>Objektet jQuery</a></h2></div><p>I JavaScript-kapitlet använde vi rå JavaScript för att hämta och manipulera objekt i DOM:en. Vi har alltså direkt interagerat med DOM:ens API. Eftersom det lätt blir frustrerande att t.ex. skriva <code>document.getElementsByTagName</code> gång på gång så finns det ramverk som kan hjälpa oss. Därför ska vi nu istället göra detta med jQuery, och därför behöver vi prata om det mest grundläggande objektet i jQuery, själva jQuery-objektet. Således även reflektera över skillnaden mellan att arbeta med jQuery-objekt och <code>HTMLElement</code>-objekt.</p><h3>Varför?</h3><p>När vi hämtar element ifrån DOM:en m.h.a JavaScript får vi alltså tillbaka just DOM-element. Men när vi arbetar emot "råa" DOM-element blir många saker, som tidigare nämnt, ofta "tjatiga" och onödigt komplicerade. Beakta nedan exempel:</p><div class="panel panel-default"><div class="panel-heading">Hämta elementet <code>&lt;body&gt;</code></div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">Med JavaScript</div><div class="panel-body"><pre><code class="language-javascript">document.getElementsByTagName('body');</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('body')[0];</code></pre></div></div></div></div><p>Uppenbart kräver jQuery-exempelet ovan att vi skriver markant mindre kod. Onödigt, kanske du tänker nu. Visst, vinsten i ovan exempel är inte massiv. Men låt oss istället se till ett mer avancerat exempel. Anta att vi skulle vilja ta bort alla <code>&lt;p&gt;</code>-element ur ett dokument. Nedan ser du hur vi först skulle kunna lösa det med JavaScript och sedan med jQuery.</p><div class="panel panel-default"><div class="panel-heading">Ta bort alla <code>&lt;p&gt;</code>-element</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">Med JavaScript</div><div class="panel-body"><pre><code class="language-javascript">var all = document.getElementsByTagName('p');
for(i=all.length-1; i>=0; i--){
  all[i].parentNode.removeChild(all[i]);
}</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('p').remove();</code></pre></div></div></div></div><p>Förhoppningsvis ser du nu styrkan! jQuery försökt att ta hand om den del vanligt återkommande problem och således försökt erbjuda oss utvecklare lite mindre huvudvärk. Nu kanske du redan fått huvudvärk flera gånger och känner den komma igen av att du behöver lära dig någonting nytt &mdash; men lugn! När du väl fått kläm på syntaxen kommer jQuery hjälpa dig ofantligt, och förhoppningsvis kommer du vara arg på att vi försökte lära dig JavaScript först.</p><blockquote>Förutom att jQuery gör det lättare för oss att utföra omständiga DOM-operationer gör den också att vi får mer webbläsarkompatibel kod, eftersom jQuery bygger på mycket "best practices".</blockquote><h3>Vad är det?</h3><p>jQuery-objektet fungerar helt enkelt så att vi "wrappar" (omsluter/dekorerar) ett helt vanligt <code>HTMLElement</code> med jQuery. När vi har gjort det har vi helt plötsligt ett objekt som dels innehåller en referens till detta helt vanliga <code>HTMLElement</code> men även en massa smidiga hjälpmetoder som hjälper oss att interagera med detta <code>HTMLElement</code>.</p><p>jQuery-objekt kan göra mycket fler saker än att hämta och manipulera element men nu ska vi fokusera på att det kan göra just det sistnämnda &mdash; alltså hämta element, och sedan manipulera dem. Låt oss se till det tidigare diskuterade exempelet som tog bort alla <code>&lt;p&gt;</code>-element ur ett dokument.</p><div class="panel panel-default"><div class="panel-heading">Ta bort alla &lt;p&gt;-element med jQuery</div><div class="panel-body"><pre><code class="language-javascript">$('p').remove();</code></pre></div></div><p>Det viktigaste vi måste förstå med ovan exempel, är att jQuery opererar på kollektioner av element och inte på enstaka element. Nu är det ju förstås så att det är fullt möjligt att vår kollektion endast innehåller ett element, men det är ändock en kollektion. För att dra en parallell så kan du tänka på hur JavaScript-metoden <code>document.getElementsByTagName()</code> fungerar. Namnet på metoden är pluraliserad eftersom även den returnerar en kollektion av <code>HTMLElement</code>. Detta alltså till skillnad ifrån <code>document.getElementById</code> som i alla fall returnerar max ett <code>HTMLElement</code>.</p><blockquote>jQuery opererar på kollektioner av element.</blockquote><p>Men vad betyder då detta i praktiken? Jo, det betyder alltså att jQuery inte bryr sig om huruvida vi hittade ett eller flera element, när vi i ovan exempel anropar metoden <code>.remove()</code> så tar den alltså bort alla element i hela den kollektion den hade hittat. Låt oss se till ytterligare ett exempel för att illustrera detta:</p><div class="panel panel-default"><div class="panel-heading">Tänk på att jQuery alltid arbetar på kollektioner av element</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;p&gt; hello &lt;/p&gt;
&lt;p&gt; world &lt;/p&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">jQuery</div><div class="panel-body"><pre class="line-numbers"><code class="language-javascript">$('p')[0].innerHTML;    // => "hello"
$('p')[1].innerHTML;    // => "world"
$('p').text();          // => "hello world"</code></pre></div></div></div></div><p>Vi kan hantera jQuery-objektet som en array. På rad 1 och 2 i ovan exempel gör vi just det. När vi använder klammerparantesnotationen (<code>[i]</code>) och ger ett index, så hämtar vi alltså det <code>HTMLElement</code> som gömmer sig under det indexet. När vi sedan anropar <code>innerHTML</code> får vi ut den text som finns i just det <code>HTMLElementet</code>. När vi däremot på rad 3 anropar <code>text()</code>-metoden (som alltså är en jQuery-specifik metod) så opererar vi alltså på kollektionen av alla träffade element. Anledningen till att vi inte använder <code>text()</code>-metoden på rad 1 och 2 är alltså för att den metoden är specifik för jQuery. Eftersom vi på rad 1 och 2 redan plockat ut ett <code>HTMLElement</code> ur jQuery-objektet så har vi alltså inte längre tillgång till jQuery's metoder. Vice versa gäller alltså på rad 3. Eftersom vi inte plockat ut något <code>HTMLElement</code> ur jQuery-kollektionen kan vi inte använda "vanliga" <code>HTMLElement</code>-metoder (eftersom det är ett <code>jQuery object</code>) utan måste istället använda jQuery-specifika metoder. Vill vi använda de vanliga <code>HTMLElement</code>-metoderna behöver vi plocka ut ett specifikt element ur kollektionen.</p><h3>Hämta element</h3><p>Låt oss nu prata om vi hämtar element-kollektioner m.h.a. jQuery. Att hämta element med jQuery är egentligen mycket enkelt. Vi skriver helt enkelt <code>$(x)</code> där <code>x</code> ersätts med vilken css-selektor som helst. Med andra ord kan vi återanvända alla våra css-kunskaper nu när vi dyker in i jQuery.</p><p>Utan att snöa ner oss i svårare selektorer så kommer du förhoppningsvis ihåg de enklaste. De vanligaste css-selektorerna är:<dl class="dl-horizontal"><dt><code> x</code></dt><dd>Element av typ x</dd><dt><code>#x</code></dt><dd>Element med id x</dd><dt><code>.x</code></dt><dd>Element med klassen x</dd></dl></p><blockquote>Om du behöver läsa på om css-selektorer, läs mer i css-kapitlet!</blockquote><p>Ok, men nu var det ett väldigt generellt prat här. Låt oss istället se till några exempel där vi faktiskt använder dessa selektorer.</p><div class="panel panel-default"><div class="panel-heading">Hämta element av typ x</div><div class="panel-body"><pre><code class="language-markup">&lt;div&gt; Anta &lt;/div&gt;
&lt;div&gt; att vi har &lt;/div&gt;
&lt;div&gt; ett par div:ar &lt;/div&gt;</code></pre><pre><code class="language-javascript">// Då väljer vi alla så här:
var allaDivar = $('div');</code></pre></div></div><p>Ovan hämtade vi alltså element baserat på deras <code>tagName</code>. Låt oss nu istället hämta alla element, oavsett typ, som har en viss <code>class</code>.</p><div class="panel panel-default"><div class="panel-heading">Hämta element med klassnamn</div><div class="panel-body"><pre><code class="language-markup">&lt;div class="dog"&gt; Woof! &lt;/div&gt;
&lt;div class="cat"&gt; Mjau! &lt;/div&gt;
&lt;div class="dog"&gt; Bark! &lt;/div&gt;</code></pre><pre><code class="language-javascript"> // Använd klass-selektorn för att hämta alla element med en viss klass
 var dogs = $(".dog");
 
 // För att illustrara att det verkligen fungerar
 dogs.text();    // => "Woof! Bark!"</code></pre></div></div><p>Busenkelt! Du börjar se mönstret? Låt oss nu istället prova en sista gång genom att hämta alla element med ett visst <code>ID</code>.</p><div class="panel panel-default"><div class="panel-heading">Hämta element med ID</div><div class="panel-body"><pre><code class="language-markup">&lt;p id="super-woman"&gt;Kryptonite!&lt;/p&gt;
&lt;p id="cat-woman"&gt;In your house eating your cat food!&lt;/p&gt;
&lt;p id="modesty-blaise"&gt;Secret agent&lt;/p&gt;</code></pre><pre><code class="language-javascript">// Vi använder css-selektorn för ID
var hero = $('#super-woman');
 
// Och har nu valt rätt element
hero.text();   // => "Kryptonite!"</code></pre></div></div><div class="page-header"><h2><a href="#modifiera-element" name="modifiera-element"><div class="icon-link"></div>Modifiera element</a></h2></div><p>När vi väl lärt oss att välja element m.h.a. jQuery är det busenkelt att börja modifiera dessa. jQuery-objektet exponerar oss en mängd behändiga funktioner och egenskaper vi kan använda för att modifiera kollektionen av element som gömmer sig under objektet. I detta kapitel kommer vi att prata om några av de vanligaste.</p><h3>html()</h3><p>Metoden <code>html()</code> kan ses som jQuery's motsvarighet till JavaScript's <code>innerHTML</code>. Lagom straight forward så hämtar den eller sätter helt enkelt elements <code>innerHTML</code>.</p><h4>Exempel</h4><div class="panel panel-default"><div class="panel-heading">jQuery-metoden html()</div><div class="panel-body"><p>Om vi har följande html..<pre><code class="language-markup">&lt;p&gt;
  &lt;span&gt;En katt&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;satt i en hatt&lt;/p&gt;</code></pre></p><p>Kan vi läsa första paragrafen genom att säga...<pre><code class="language-javascript">$('p').html();         // => "&lt;span&gt;En katt&lt;/span&gt;"</code></pre></p><p>Men vi kan även modifiera den genom att säga...<pre><code class="language-javascript">$('p').html('En hund') // => Ändrar ALLA p-elements inre html till "En hund"</code></pre></p><p>Vilket förändrar vår html så att vi nu har...<pre><code class="language-markup">&lt;p&gt;En hund&lt;/p&gt;
&lt;p&gt;En hund&lt;/p&gt;</code></pre></p><p>Notera alltså att vi "blev av" med <code>&lt;span&gt;</code>-elementet. Samt att <b>båda</b> <code>&lt;p&gt;</code>-elementens inre html rensades.</p></div></div><p>Men vänta nu, vad hände nu? Om du var uppmärksam så märkte du att när vi använde metoden <code>html()</code> för att <b>läsa</b> ifrån en element-kollektion så fick vi endast värdet ifrån det första elementet i kollektionen. Men när vi däremot använda <code>html()</code>-funktionen för att <b>skriva</b> så opererade vi på alla element i objekt-kollektionen. Vad händer nu egentligen?</p><blockquote class="text-warning">Alla metoder på jQuery-objektet arbetar <u>inte alltid</u> på alla element i kollektionen.</blockquote><h3>Vilka metoder opererar över hela kollektionen?</h3><p>Oavsett vilket jQuery-metod vi använder är det alltså alltid viktigt att vara medveten om huruvida den arbetar på hela kollektionen eller ett specifikt element. En tumregel vi kan använda är att många av metoderna <b>läser ifrån det första</b> elementet i kollektionen och <b>skriver till alla</b> i kollektionen. Anropar vi alltså <code>html()</code> för att <b>läsa</b> kommer vi bara att få all inre html för det första elementet, medan om vi använder metoden till att skriva <code>html('something')</code> kommer vi förändra <code>innerHTML</code> för alla element i kollektionen.</p><blockquote class="info">En bra tumregel är att många jQuery-metoder läser ifrån första elementet i en objekt-kollektion, och skriver till alla.</blockquote><h3>text()</h3><p>Metoden <code>text()</code> påminner mycket om metoden <code>html()</code> förutom att den fantastiskt nog ger oss innehållet i det första elementet i en element-kollektion utan html. Vi får alltså allt som webbläsaren faktiskt uppfattat som text, utan all störande html. Detta är en mycket användbar metod! Vi kan förstås, precis som med metoden <code>html()</code> använda den för att även skriva text till alla element i en kollektion. Låt oss se till några exempel:</p><h4>Exempel</h4><div class="panel panel-default"><div class="panel-heading">jQuery-metoden html()</div><div class="panel-body"><p>Om vi har följande html..<pre><code class="language-markup">&lt;p&gt;
  En liten men 
  &lt;span&gt;mästerlig&lt;/span&gt;
  katt, satt en 
  &lt;span&gt;solig dag &lt;/span&gt;
  och beundrade en hatt.
&lt;/p&gt;</code></pre></p><p>Och sedan hämtar <code>&lt;p&gt;</code>-elementets text så här...<pre><code class="language-javascript">$('p').text();   // Hämtar all text i elementet fritt ifrån alla html-element</code></pre></p><p>Så får vi...<pre><code class="language-javascript">"En liten men mästerlig katt, satt en solig dag och beundrade en hatt."</code></pre></p><p>Vilket ju är fantastiskt, för om vi istället hade använt metoden <code>html()</code> eller JavaScript's egna <code>innerHTML</code> hade vi istället fått...<pre><code class="language-javascript">"En liten men &lt;span&gt;mästerlig&lt;/span&gt; katt, satt en &lt;span&gt;solig dag &lt;/span&gt; och beundrade en hatt."</code></pre></p><p>Vilket förstås skulle vara mycket jobbigt att arbeta med om det skulle vara så att vi faktiskt bara vill åt texten, oavsett dess inre elementstruktur.</p></div></div><h3>attr() &amp; prop()</h3><p>Låt oss nu prata om två metoder som till synes verkar likna varandra. Metoden <code>attr()</code> hämtar och sätter <code>attribut</code> (<code>attributes</code>), medan metoden <code>prop</code> hämtar och sätter <code>egenskaper</code> (<code>properties</code>). På samma sätt som <code>text()</code> och <code>html()</code> hämtar båda metoderna ifrån det första elementet, och skriver till alla i en kollektion. Men för att förstå skillnaderna mellan de två metoderna <code>attr()</code> och <code>prop()</code> behöver vi först förstå skillnaden mellan <code>attribut</code> och <code>egenskaper</code>.</p><h4>Attribut</h4><p>När vi pratar om attribut så pratar vi attribut på html-element. Exempel på attribut är alltså <code>id</code>, <code>class</code>, <code>name</code> och <code>name</code>, för att nämna några. Med andra ord, attribut är sådant som vi "tilldelar" ett element i vår html. Självklart kan vi både hämta och sätta attribut via JavaScript, men för att förstå skillnaden mellan attribut och egenskaper är det lättast att tänka på attribut som det som vi sätter i html. Nedan följer ett exempel på ett html-element med ett antal attribut.<div class="panel panel-default"><div class="panel-heading">Att läsa ett elements attribut</div><div class="panel-body"><p>Om vi har ett element med ett antal attribut...</p><pre><code class="language-markup">&lt;p class="quote" id="welcome"&gt;
  What a wonderful world
&lt;/p&gt;</code></pre><p>Så kan vi förstås läsa attributen med JavaScript som så...</p><pre><code class="language-javascript">document.getElementsByTagName('p')[0].getAttribute('class');
// => "quote"
 
document.getElementsByTagName('p')[0].getAttribute('id');
// => "welcome"</code></pre><p>Och förstås med jQuery som så...</p><pre><code class="language-javascript">$('p').attr('class');  // => "quote"
$('p').attr('id');     // => "welcome"</code></pre></div></div></p><h4>Egenskaper</h4><p>Egenskaper å andra sidan, refererar till egenskaper på ett <code>HTMLElement</code>-objekt när den hanteras i JavaScript. Med andra ord (löst uttryckt) publika instansvariabler på JavaScript-representationen av samma element. Vad skulle då egenskaper kunna vara för någonting?<div class="panel panel-default"><div class="panel-heading">Att läsa ett elements egenskaper</div><div class="panel-body"><p>Anta att vi har ett <code>&lt;p&gt;</code>-element på sidan..</p><pre><code class="language-javascript">var p = document.getElementsByTagName('p')[0];
var i = document.getElementsByTagName('input')[0];
 
p.tagName;  // => "P"
i.tagName;  // => "INPUT"</code></pre><p>Således kan vi förstås göra samma sak genom jQuery...</p><pre><code class="language-javascript">$('p').prop('tagName');       // => "P"
$('input').prop('tagName');   // => "INPUT"</code></pre></div></div></p><h4>Undantag</h4><p>Av historiska skäl och förändringar över tid så beteer sig ovan metoder, i tidigare versioner av jQuery, tyvärr inte alltid såsom man kan tänka sig. Du kan läsa mer om det i jQuery-dokumentationen för<a href="http://api.jquery.com/prop/">prop</a> eller<a href="http://api.jquery.com/attr/">attr</a> eller helt enkelt på följande tråd på <a href="http://stackoverflow.com/questions/5874652/prop-vs-attr">StackOverflow</a>.</p><div class="page-header"><h2><a href="#jquery-event-listeners" name="jquery-event-listeners"><div class="icon-link"></div>Event listeners i jQuery</a></h2></div><p>En av styrkorna med jQuery är att vi kan binda event-lyssnare till flera element samtidigt. Jämför detta med att behöva iterera över en array med element, plocka ut ett för ett och applicera samma lyssnare. Markant enklare att göra det på alla samtidigt!</p><p>jQuery har några generella metoder för att applicera event-lyssnare (som med fördel kan jämföras med JavaScripts <code>addEventListener()</code>). Men jQuery har även några specifika för vanligt förekommande events som <code>click</code> och <code>hover</code>. Låt oss kolla på ett exempel, och kom ihåg att jQuery arbetar på kollektioner av element, alltså flera stycken samtidigt.</p><div class="panel panel-default"><div class="panel-heading">Exempel att applicera lyssnare på alla divar samtidigt</div><div class="panel-body"><div class="panel panel-default"><div class="panel-heading">HTML</div><div class="panel-body"><pre><code class="language-markup">&lt;div&gt;Oh no no no...&lt;/div&gt;
&lt;div&gt;Please do not click me, oh no no, please...&lt;/div&gt;
&lt;div&gt;I don't want to fade, please...&lt;/div&gt;</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">jQuery</div><div class="panel-body"><pre><code class="language-javascript">var divs = $('div').click(function(){
  $(this).fadeOut();
});</code></pre></div></div><div class="panel panel-default"><div class="panel-heading">Resultat</div><div class="panel-body"><style>.jquery-events-example-1{
  width:100%; min-height:50px; background:rgb(200,200,200); margin:6px;
  padding:10px; text-align:center; font-size:20px;
}</style><div class="jquery-events-example-1">Oh no no no...</div><div class="jquery-events-example-1">Please do not click me, oh no no, please...</div><div class="jquery-events-example-1">I don't want to fade, please...</div><script>$('.jquery-events-example-1').click(function(){
  $(this).fadeOut();
});</script></div></div></div></div><p>Om du försöker bygga ovan exempel med ren JavaScript kommer du snabbt märka varför det gör livet så hiskelens mycket enklare att arbeta med ett JavaScript-bibliotek såsom jQuery.</p><h3>Vem avfyrade ett event?</h3><p>Som du kanske märkte i senaste exemplet, så använde vi oss av följande syntax: <code>$(this)</code>. Mystiskt kan tyckas, men mycket smidigt faktiskt. När vi kör jQuery-funktionen (<code>$()</code>) och ger den en css-selektor så kommer jQuery att välja alla element som matchar den selektorn. Men vi kan faktiskt också ge jQuery-metoden ett annat <code>HTMLElement</code>. T.ex. så här:</p><div class="panel panel-default"><div class="panel-heading">Wrappa ett HTMLElement i jQuery</div><div class="panel-body"><pre><code class="language-javascript">// First grab the first &lt;p&gt;-element using regular JavaScript
var paragraph = document.getElementsByTagName('p')[0];
 
// Then wrap it as a jQuery object
var $paragraph = $(paragrah);
 
// And now we can do all the regular cool jQuery stuff
$paragraph.fadeOut();</code></pre></div></div><p>Men vänta nu, i det tidigare diskuterade exemplet så skickade vi ju faktiskt inte ett html-element, utan vi skickade nyckelordet <code>this</code>. Löst uttryckt så refererar nyckelordet <code>this</code> i JavaScript alltid till den nuvarande kontexten. Det intressanta är alltså att om vi skickar den nuvarande kontexten till jQuery-metoden så kommer den försöka skapa ett jQuery-objekt av det. Om vi då befinner oss i en <code>event handler</code> (t.ex. den kod som exekveras när en knapp klickas på) så kommer det element som avfyrade elementet bli det objekt som hamnar i jQuery-objektet. Låt oss se till ett exempel.</p><div class="panel panel-default"><div class="panel-heading">Att identifiera den som avfyrade ett event med jQuery</div><div class="panel-body"><p>Om vi har följande html...<pre><code class="language-markup">&lt;p&gt;Hello world&lt;/p&gt;</code></pre></p><p>Kan vi göra följande i jQuery...<pre><code class="language-javascript">// First define a click function, that we want to
// execute whenever something is clicked.
var onClick = function(){
  var sender = $(this);  // Creates a jQuery object of the element that was clicked
  alert(sender.text());  // Sends a message with the contents of the clicked element
}
 
// Then we need to attach our click function to the &lt;p&gt;-element,
// so that it will be fired when the element is clicked.
$('p').click(onClick);</code></pre></p><p>Detta kommer nu alltså att ge oss följande...</p><div class="panel panel-default"><div class="panel-heading">Resultat (testa att klicka på paragrafen)</div><div class="panel-body"><p class="jquery-events-example-2">Hello world</p><script>$('p.jquery-events-example-2').click(function(){
  alert($(this).text());
});</script></div></div></div></div><p>Detta går självklart även att göra med helt vanlig JavaScript, såsom du förhoppningsvis kommer ihåg ifrån JavaScript-kapitlet. Att det är enklare att göra i jQuery är ju förstås ett plus! Men det viktiga att komma ihåg är här alltså att detta gör det möjligt för oss att skriva mycket mer generella <code>event handlers</code> (alltså metoden som körs när ett event avfyras). Om vi t.ex. har tre knappar som alla gör väldigt liknande saker, så finns det alltså ingen anledning att binda separata event-hanterare (<code>event handler</code>) för varje knapp. Istället generaliserar vi koden i event-hanteraren och binder alla events till samma hanterare. Sött som sylt!</p><h1>Epilog</h1><div class="page-header"><h2><a href="#efterord" name="efterord"><div class="icon-link"></div>Efterord</a></h2></div><p>HTML-hunden är skriven av <span class="authors"><em class="author">Christopher Okhravi</em> (<a href="http://twitter.com/chrokh" target="_blank">@chrokh</a>) och <em>Madelen Hermelin</em>. Guiden är skriven för att användas under kurser vid <a href="http://www.im.uu.se/" target="_blank">Institutionen för informatik och media</a> under <a href="http://www.uu.se" target="_blank">Uppsala universitet</a> men du är förstås välkommen att använda den vemän du är :) </span></p><p>Projektet har <a href="http://sv.wikipedia.org/wiki/%C3%96ppen_k%C3%A4llkod" target="_blank">öppen källkod</a>, och om du således är intresserad av att bidra på något sätt så välkomnar vi alla tankar, idéer och korrigeringar. Projektet tillsammans med dokumentation finns på <a href="https://github.com/chrokh/htmlhunden" target="_blank">GitHub</a>.</p></div></div><script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.0.3/js/bootstrap.min.js"></script><script src="assets/javascripts/prism.js"></script><script src="assets/javascripts/main.js"></script><script src="http://localhost:35729/livereload.js"></script>